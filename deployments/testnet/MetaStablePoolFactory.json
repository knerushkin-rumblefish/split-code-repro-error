{
  "address": "0x1b35d875d3b32ffCE91fe9189EA671f123B64a92",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IVault",
          "name": "vault",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        }
      ],
      "name": "PoolCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "constructorArgs",
          "type": "bytes"
        }
      ],
      "name": "_getCreationCodeWithArgs",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "code",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "amplificationParameter",
          "type": "uint256"
        },
        {
          "internalType": "contract IRateProvider[]",
          "name": "rateProviders",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "priceRateCacheDuration",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "swapFeePercentage",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "create",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCreationCode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCreationCodeContracts",
      "outputs": [
        {
          "internalType": "address",
          "name": "contractA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "contractB",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPauseConfiguration",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "pauseWindowDuration",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bufferPeriodDuration",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVault",
      "outputs": [
        {
          "internalType": "contract IVault",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool",
          "type": "address"
        }
      ],
      "name": "isPoolFromFactory",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xdb3c02a35178479d0d61d134011e7e64125c3aa986336ee78a7d37ea68f27afd",
  "receipt": {
    "to": null,
    "from": "0xe3908E4E1CE55F1af7Bf62e50a3194205Dd192cE",
    "contractAddress": "0x1b35d875d3b32ffCE91fe9189EA671f123B64a92",
    "transactionIndex": 0,
    "gasUsed": "634205",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x721fb3b65c0f8bdb82de30eb6d756202bb68b1842f60ebd05d49b1abcb637621",
    "transactionHash": "0xdb3c02a35178479d0d61d134011e7e64125c3aa986336ee78a7d37ea68f27afd",
    "logs": [],
    "blockNumber": 356831,
    "cumulativeGasUsed": "634205",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xA569923c4a4c80d0f30DaC668bd3e14662598DCf"
  ],
  "numDeployments": 2,
  "solcInputHash": "df7775f67061d1917be1f399f1ecae92",
  "metadata": "{\"compiler\":{\"version\":\"0.7.1+commit.f4a555be\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IVault\",\"name\":\"vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"constructorArgs\",\"type\":\"bytes\"}],\"name\":\"_getCreationCodeWithArgs\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"code\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amplificationParameter\",\"type\":\"uint256\"},{\"internalType\":\"contract IRateProvider[]\",\"name\":\"rateProviders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceRateCacheDuration\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreationCodeContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractB\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauseConfiguration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pauseWindowDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferPeriodDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"isPoolFromFactory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"_getCreationCodeWithArgs(bytes)\":{\"details\":\"Returns the creation code that will result in a contract being deployed with `constructorArgs`.\"},\"create(string,string,address[],uint256,address[],uint256[],uint256,address)\":{\"details\":\"Deploys a new `MetaStablePool`.\"},\"getCreationCode()\":{\"details\":\"Returns the creation code of the contract this factory creates.\"},\"getCreationCodeContracts()\":{\"details\":\"Returns the two addresses where the creation code of the contract crated by this factory is stored.\"},\"getPauseConfiguration()\":{\"details\":\"Returns the current `TemporarilyPausable` configuration that will be applied to Pools created by this factory. `pauseWindowDuration` will decrease over time until it reaches zero, at which point both it and `bufferPeriodDuration` will be zero forever, meaning deployed Pools will not be pausable.\"},\"getVault()\":{\"details\":\"Returns the Vault's address.\"},\"isPoolFromFactory(address)\":{\"details\":\"Returns true if `pool` was created by this factory.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/StablePool/meta/MetaStablePoolFactory.sol\":\"MetaStablePoolFactory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"contracts/Authentication.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\nimport \\\"./IAuthentication.sol\\\";\\n\\n/**\\n * @dev Building block for performing access control on external functions.\\n *\\n * This contract is used via the `authenticate` modifier (or the `_authenticateCaller` function), which can be applied\\n * to external functions to only make them callable by authorized accounts.\\n *\\n * Derived contracts must implement the `_canPerform` function, which holds the actual access control logic.\\n */\\nabstract contract Authentication is IAuthentication {\\n    bytes32 private immutable _actionIdDisambiguator;\\n\\n    /**\\n     * @dev The main purpose of the `actionIdDisambiguator` is to prevent accidental function selector collisions in\\n     * multi contract systems.\\n     *\\n     * There are two main uses for it:\\n     *  - if the contract is a singleton, any unique identifier can be used to make the associated action identifiers\\n     *    unique. The contract's own address is a good option.\\n     *  - if the contract belongs to a family that shares action identifiers for the same functions, an identifier\\n     *    shared by the entire family (and no other contract) should be used instead.\\n     */\\n    constructor(bytes32 actionIdDisambiguator) {\\n        _actionIdDisambiguator = actionIdDisambiguator;\\n    }\\n\\n    /**\\n     * @dev Reverts unless the caller is allowed to call this function. Should only be applied to external functions.\\n     */\\n    modifier authenticate() {\\n        _authenticateCaller();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts unless the caller is allowed to call the entry point function.\\n     */\\n    function _authenticateCaller() internal view {\\n        bytes32 actionId = getActionId(msg.sig);\\n        _require(_canPerform(actionId, msg.sender), Errors.SENDER_NOT_ALLOWED);\\n    }\\n\\n    function getActionId(bytes4 selector) public view override returns (bytes32) {\\n        // Each external function is dynamically assigned an action identifier as the hash of the disambiguator and the\\n        // function selector. Disambiguation is necessary to avoid potential collisions in the function selectors of\\n        // multiple contracts.\\n        return keccak256(abi.encodePacked(_actionIdDisambiguator, selector));\\n    }\\n\\n    function _canPerform(bytes32 actionId, address user) internal view virtual returns (bool);\\n}\\n\",\"keccak256\":\"0xea892213ec2967f53e26a0dd833bde01e4d9b6e49dd91e6c59ff00044f83c28d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BalancerErrors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n// solhint-disable\\n\\n/**\\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\n * supported.\\n */\\nfunction _require(bool condition, uint256 errorCode) pure {\\n    if (!condition) _revert(errorCode);\\n}\\n\\n/**\\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\n */\\nfunction _revert(uint256 errorCode) pure {\\n    // We're going to dynamically create a revert string based on the error code, with the following format:\\n    // 'BAL#{errorCode}'\\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\\n    //\\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\\n    // number (8 to 16 bits) than the individual string characters.\\n    //\\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\\n    assembly {\\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\\n        // the '0' character.\\n\\n        let units := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let tenths := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let hundreds := add(mod(errorCode, 10), 0x30)\\n\\n        // With the individual characters, we can now construct the full string. The \\\"BAL#\\\" part is a known constant\\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\\n        // characters to it, each shifted by a multiple of 8.\\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\\n        // array).\\n\\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\\n\\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\\n        // message will have the following layout:\\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\\n\\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\\n        // The string length is fixed: 7 characters.\\n        mstore(0x24, 7)\\n        // Finally, the string itself is stored.\\n        mstore(0x44, revertReason)\\n\\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\\n        revert(0, 100)\\n    }\\n}\\n\\nlibrary Errors {\\n    // Math\\n    uint256 internal constant ADD_OVERFLOW = 0;\\n    uint256 internal constant SUB_OVERFLOW = 1;\\n    uint256 internal constant SUB_UNDERFLOW = 2;\\n    uint256 internal constant MUL_OVERFLOW = 3;\\n    uint256 internal constant ZERO_DIVISION = 4;\\n    uint256 internal constant DIV_INTERNAL = 5;\\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\\n    uint256 internal constant INVALID_EXPONENT = 9;\\n\\n    // Input\\n    uint256 internal constant OUT_OF_BOUNDS = 100;\\n    uint256 internal constant UNSORTED_ARRAY = 101;\\n    uint256 internal constant UNSORTED_TOKENS = 102;\\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\\n    uint256 internal constant ZERO_TOKEN = 104;\\n\\n    // Shared pools\\n    uint256 internal constant MIN_TOKENS = 200;\\n    uint256 internal constant MAX_TOKENS = 201;\\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\\n    uint256 internal constant MINIMUM_BPT = 204;\\n    uint256 internal constant CALLER_NOT_VAULT = 205;\\n    uint256 internal constant UNINITIALIZED = 206;\\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\\n    uint256 internal constant EXPIRED_PERMIT = 209;\\n    uint256 internal constant NOT_TWO_TOKENS = 210;\\n\\n    // Pools\\n    uint256 internal constant MIN_AMP = 300;\\n    uint256 internal constant MAX_AMP = 301;\\n    uint256 internal constant MIN_WEIGHT = 302;\\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\\n    uint256 internal constant MAX_IN_RATIO = 304;\\n    uint256 internal constant MAX_OUT_RATIO = 305;\\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\\n    uint256 internal constant INVALID_TOKEN = 309;\\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\\n    uint256 internal constant ZERO_INVARIANT = 311;\\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\\n    uint256 internal constant ORACLE_BAD_SECS = 316;\\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\\n    uint256 internal constant SWAPS_DISABLED = 327;\\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\\n    uint256 internal constant UNHANDLED_BY_INVESTMENT_POOL = 339;\\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\\n    uint256 internal constant INVALID_INITIALIZATION = 342;\\n\\n    // Lib\\n    uint256 internal constant REENTRANCY = 400;\\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\\n    uint256 internal constant PAUSED = 402;\\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\\n\\n    // Vault\\n    uint256 internal constant INVALID_POOL_ID = 500;\\n    uint256 internal constant CALLER_NOT_POOL = 501;\\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\\n    uint256 internal constant INVALID_SIGNATURE = 504;\\n    uint256 internal constant EXIT_BELOW_MIN = 505;\\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\\n    uint256 internal constant SWAP_LIMIT = 507;\\n    uint256 internal constant SWAP_DEADLINE = 508;\\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\\n    uint256 internal constant INSUFFICIENT_ETH = 516;\\n    uint256 internal constant UNALLOCATED_ETH = 517;\\n    uint256 internal constant ETH_TRANSFER = 518;\\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\\n    uint256 internal constant TOKENS_MISMATCH = 520;\\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\\n    uint256 internal constant POOL_NO_TOKENS = 527;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\\n\\n    // Fees\\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\\n}\\n\",\"keccak256\":\"0x7a697c1ffbd94649e71264715963d45ea6a2d8f725a059c61446062018c60afb\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/BalancerPoolToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ERC20/ERC20.sol\\\";\\nimport \\\"../ERC20/ERC20Permit.sol\\\";\\n\\nimport \\\"../vault/IVault.sol\\\";\\n\\n/**\\n * @title Highly opinionated token implementation\\n * @author Balancer Labs\\n * @dev\\n * - Includes functions to increase and decrease allowance as a workaround\\n *   for the well-known issue with `approve`:\\n *   https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n * - Allows for 'infinite allowance', where an allowance of 0xff..ff is not\\n *   decreased by calls to transferFrom\\n * - Lets a token holder use `transferFrom` to send their own tokens,\\n *   without first setting allowance\\n * - Emits 'Approval' events whenever allowance is changed by `transferFrom`\\n * - Assigns infinite allowance for all token holders to the Vault\\n */\\ncontract BalancerPoolToken is ERC20, ERC20Permit {\\n    IVault private immutable _vault;\\n\\n    constructor(\\n        string memory tokenName,\\n        string memory tokenSymbol,\\n        IVault vault\\n    ) ERC20(tokenName, tokenSymbol) ERC20Permit(tokenName) {\\n        _vault = vault;\\n    }\\n\\n    function getVault() public view returns (IVault) {\\n        return _vault;\\n    }\\n\\n    // Overrides\\n\\n    /**\\n     * @dev Override to grant the Vault infinite allowance, causing for Pool Tokens to not require approval.\\n     *\\n     * This is sound as the Vault already provides authorization mechanisms when initiation token transfers, which this\\n     * contract inherits.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return super.allowance(owner, spender);\\n    }\\n\\n    /**\\n     * @dev Override to allow for 'infinite allowance' and let the token owner use `transferFrom` with no self-allowance\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        uint256 currentAllowance = allowance(sender, msg.sender);\\n        _require(msg.sender == sender || currentAllowance >= amount, Errors.ERC20_TRANSFER_EXCEEDS_ALLOWANCE);\\n\\n        _transfer(sender, recipient, amount);\\n\\n        if (msg.sender != sender && currentAllowance != uint256(-1)) {\\n            // Because of the previous require, we know that if msg.sender != sender then currentAllowance >= amount\\n            _approve(sender, msg.sender, currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Override to allow decreasing allowance by more than the current amount (setting it to zero)\\n     */\\n    function decreaseAllowance(address spender, uint256 amount) public override returns (bool) {\\n        uint256 currentAllowance = allowance(msg.sender, spender);\\n\\n        if (amount >= currentAllowance) {\\n            _approve(msg.sender, spender, 0);\\n        } else {\\n            // No risk of underflow due to if condition\\n            _approve(msg.sender, spender, currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    // Internal functions\\n\\n    function _mintPoolTokens(address recipient, uint256 amount) internal {\\n        _mint(recipient, amount);\\n    }\\n\\n    function _burnPoolTokens(address sender, uint256 amount) internal {\\n        _burn(sender, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xf2844047259d8a1c14fa2b58351a344f4153d59561b7368fb35b5eed702e8bf5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/BaseGeneralPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./BasePool.sol\\\";\\nimport \\\"./IGeneralPool.sol\\\";\\n\\n/**\\n * @dev Extension of `BasePool`, adding a handler for `IGeneralPool.onSwap`.\\n *\\n * Derived contracts must call `BasePool`'s constructor, and implement `_onSwapGivenIn` and `_onSwapGivenOut` along with\\n * `BasePool`'s virtual functions. Inheriting from this contract lets derived contracts choose the General\\n * specialization setting.\\n */\\nabstract contract BaseGeneralPool is IGeneralPool, BasePool {\\n    // Swap Hooks\\n\\n    function onSwap(\\n        SwapRequest memory swapRequest,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) public virtual override onlyVault(swapRequest.poolId) returns (uint256) {\\n        _validateIndexes(indexIn, indexOut, _getTotalTokens());\\n        uint256[] memory scalingFactors = _scalingFactors();\\n\\n        return\\n        swapRequest.kind == IVault.SwapKind.GIVEN_IN\\n        ? _swapGivenIn(swapRequest, balances, indexIn, indexOut, scalingFactors)\\n        : _swapGivenOut(swapRequest, balances, indexIn, indexOut, scalingFactors);\\n    }\\n\\n    function _swapGivenIn(\\n        SwapRequest memory swapRequest,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut,\\n        uint256[] memory scalingFactors\\n    ) internal returns (uint256) {\\n        // Fees are subtracted before scaling, to reduce the complexity of the rounding direction analysis.\\n        swapRequest.amount = _subtractSwapFeeAmount(swapRequest.amount);\\n\\n        _upscaleArray(balances, scalingFactors);\\n        swapRequest.amount = _upscale(swapRequest.amount, scalingFactors[indexIn]);\\n\\n        uint256 amountOut = _onSwapGivenIn(swapRequest, balances, indexIn, indexOut);\\n\\n        // amountOut tokens are exiting the Pool, so we round down.\\n        return _downscaleDown(amountOut, scalingFactors[indexOut]);\\n    }\\n\\n    function _swapGivenOut(\\n        SwapRequest memory swapRequest,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut,\\n        uint256[] memory scalingFactors\\n    ) internal returns (uint256) {\\n        _upscaleArray(balances, scalingFactors);\\n        swapRequest.amount = _upscale(swapRequest.amount, scalingFactors[indexOut]);\\n\\n        uint256 amountIn = _onSwapGivenOut(swapRequest, balances, indexIn, indexOut);\\n\\n        // amountIn tokens are entering the Pool, so we round up.\\n        amountIn = _downscaleUp(amountIn, scalingFactors[indexIn]);\\n\\n        // Fees are added after scaling happens, to reduce the complexity of the rounding direction analysis.\\n        return _addSwapFeeAmount(amountIn);\\n    }\\n\\n    /*\\n     * @dev Called when a swap with the Pool occurs, where the amount of tokens entering the Pool is known.\\n     *\\n     * Returns the amount of tokens that will be taken from the Pool in return.\\n     *\\n     * All amounts inside `swapRequest` and `balances` are upscaled. The swap fee has already been deducted from\\n     * `swapRequest.amount`.\\n     *\\n     * The return value is also considered upscaled, and will be downscaled (rounding down) before returning it to the\\n     * Vault.\\n     */\\n    function _onSwapGivenIn(\\n        SwapRequest memory swapRequest,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) internal virtual returns (uint256);\\n\\n    /*\\n     * @dev Called when a swap with the Pool occurs, where the amount of tokens exiting the Pool is known.\\n     *\\n     * Returns the amount of tokens that will be granted to the Pool in return.\\n     *\\n     * All amounts inside `swapRequest` and `balances` are upscaled.\\n     *\\n     * The return value is also considered upscaled, and will be downscaled (rounding up) before applying the swap fee\\n     * and returning it to the Vault.\\n     */\\n    function _onSwapGivenOut(\\n        SwapRequest memory swapRequest,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) internal virtual returns (uint256);\\n\\n    function _validateIndexes(\\n        uint256 indexIn,\\n        uint256 indexOut,\\n        uint256 limit\\n    ) private pure {\\n        _require(indexIn < limit && indexOut < limit, Errors.OUT_OF_BOUNDS);\\n    }\\n}\\n\",\"keccak256\":\"0xe8f3331b8af0cfaadbe412c3c84114a2fd6ed0ceeafb385b256314369adf21d9\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/BaseMinimalSwapInfoPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./BasePool.sol\\\";\\nimport \\\"./IMinimalSwapInfoPool.sol\\\";\\n\\n/**\\n * @dev Extension of `BasePool`, adding a handler for `IMinimalSwapInfoPool.onSwap`.\\n *\\n * Derived contracts must call `BasePool`'s constructor, and implement `_onSwapGivenIn` and `_onSwapGivenOut` along with\\n * `BasePool`'s virtual functions. Inheriting from this contract lets derived contracts choose the Two Token or Minimal\\n * Swap Info specialization settings.\\n */\\nabstract contract BaseMinimalSwapInfoPool is IMinimalSwapInfoPool, BasePool {\\n    // Swap Hooks\\n\\n    function onSwap(\\n        SwapRequest memory request,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    ) public virtual override onlyVault(request.poolId) returns (uint256) {\\n        uint256 scalingFactorTokenIn = _scalingFactor(request.tokenIn);\\n        uint256 scalingFactorTokenOut = _scalingFactor(request.tokenOut);\\n\\n        if (request.kind == IVault.SwapKind.GIVEN_IN) {\\n            // Fees are subtracted before scaling, to reduce the complexity of the rounding direction analysis.\\n            uint256 amountInMinusSwapFees = _subtractSwapFeeAmount(request.amount);\\n\\n            // Process the (upscaled!) swap fee.\\n            uint256 swapFee = request.amount - amountInMinusSwapFees;\\n            _processSwapFeeAmount(request.tokenIn, _upscale(swapFee, scalingFactorTokenIn));\\n\\n            request.amount = amountInMinusSwapFees;\\n\\n            // All token amounts are upscaled.\\n            balanceTokenIn = _upscale(balanceTokenIn, scalingFactorTokenIn);\\n            balanceTokenOut = _upscale(balanceTokenOut, scalingFactorTokenOut);\\n            request.amount = _upscale(request.amount, scalingFactorTokenIn);\\n\\n            uint256 amountOut = _onSwapGivenIn(request, balanceTokenIn, balanceTokenOut);\\n\\n            // amountOut tokens are exiting the Pool, so we round down.\\n            return _downscaleDown(amountOut, scalingFactorTokenOut);\\n        } else {\\n            // All token amounts are upscaled.\\n            balanceTokenIn = _upscale(balanceTokenIn, scalingFactorTokenIn);\\n            balanceTokenOut = _upscale(balanceTokenOut, scalingFactorTokenOut);\\n            request.amount = _upscale(request.amount, scalingFactorTokenOut);\\n\\n            uint256 amountIn = _onSwapGivenOut(request, balanceTokenIn, balanceTokenOut);\\n\\n            // amountIn tokens are entering the Pool, so we round up.\\n            amountIn = _downscaleUp(amountIn, scalingFactorTokenIn);\\n\\n            // Fees are added after scaling happens, to reduce the complexity of the rounding direction analysis.\\n            uint256 amountInPlusSwapFees = _addSwapFeeAmount(amountIn);\\n\\n            // Process the (upscaled!) swap fee.\\n            uint256 swapFee = amountInPlusSwapFees - amountIn;\\n            _processSwapFeeAmount(request.tokenIn, _upscale(swapFee, scalingFactorTokenIn));\\n\\n            return amountInPlusSwapFees;\\n        }\\n    }\\n\\n    /*\\n     * @dev Called when a swap with the Pool occurs, where the amount of tokens entering the Pool is known.\\n     *\\n     * Returns the amount of tokens that will be taken from the Pool in return.\\n     *\\n     * All amounts inside `swapRequest`, `balanceTokenIn` and `balanceTokenOut` are upscaled. The swap fee has already\\n     * been deducted from `swapRequest.amount`.\\n     *\\n     * The return value is also considered upscaled, and will be downscaled (rounding down) before returning it to the\\n     * Vault.\\n     */\\n    function _onSwapGivenIn(\\n        SwapRequest memory swapRequest,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    ) internal virtual returns (uint256);\\n\\n    /*\\n     * @dev Called when a swap with the Pool occurs, where the amount of tokens exiting the Pool is known.\\n     *\\n     * Returns the amount of tokens that will be granted to the Pool in return.\\n     *\\n     * All amounts inside `swapRequest`, `balanceTokenIn` and `balanceTokenOut` are upscaled.\\n     *\\n     * The return value is also considered upscaled, and will be downscaled (rounding up) before applying the swap fee\\n     * and returning it to the Vault.\\n     */\\n    function _onSwapGivenOut(\\n        SwapRequest memory swapRequest,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    ) internal virtual returns (uint256);\\n\\n    /**\\n     * @dev Called whenever a swap fee is charged. Implementations should call their parents via super, to ensure all\\n     * implementations in the inheritance tree are called.\\n     *\\n     * Callers must call one of the three `_processSwapFeeAmount` functions when swap fees are computed,\\n     * and upscale `amount`.\\n     */\\n    function _processSwapFeeAmount(\\n        uint256, /*index*/\\n        uint256 /*amount*/\\n    ) internal virtual {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function _processSwapFeeAmount(IERC20 token, uint256 amount) internal {\\n        _processSwapFeeAmount(_tokenAddressToIndex(token), amount);\\n    }\\n\\n    function _processSwapFeeAmounts(uint256[] memory amounts) internal {\\n        InputHelpers.ensureInputLengthMatch(amounts.length, _getTotalTokens());\\n\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            _processSwapFeeAmount(i, amounts[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the index of `token` in the Pool's token array (i.e. the one `vault.getPoolTokens()` would return).\\n     *\\n     * A trivial (and incorrect!) implementation is already provided for Pools that don't override\\n     * `_processSwapFeeAmount` and skip the entire feature. However, Pools that do override `_processSwapFeeAmount`\\n     * *must* override this function with a meaningful implementation.\\n     */\\n    function _tokenAddressToIndex(\\n        IERC20 /*token*/\\n    ) internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xe1f2660395efb1ee2bc18f72b6b6afdafd7c28705f4eb0f7406f9a178ee1f732\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/BasePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Math.sol\\\";\\nimport \\\"../FixedPoint.sol\\\";\\nimport \\\"../InputHelpers.sol\\\";\\nimport \\\"../utils/TemporarilyPausable.sol\\\";\\nimport \\\"../StablePool/WordCodec.sol\\\";\\nimport \\\"../ERC20/ERC20.sol\\\";\\n\\nimport \\\"../vault/IVault.sol\\\";\\n\\nimport \\\"../IAssetManager.sol\\\";\\n\\nimport \\\"./BalancerPoolToken.sol\\\";\\nimport \\\"./BasePoolAuthorization.sol\\\";\\nimport \\\"../vault/IBasePool.sol\\\";\\n\\n// solhint-disable max-states-count\\n\\n/**\\n * @dev Reference implementation for the base layer of a Pool contract that manages a single Pool with optional\\n * Asset Managers, an admin-controlled swap fee percentage, and an emergency pause mechanism.\\n *\\n * Note that neither swap fees nor the pause mechanism are used by this contract. They are passed through so that\\n * derived contracts can use them via the `_addSwapFeeAmount` and `_subtractSwapFeeAmount` functions, and the\\n * `whenNotPaused` modifier.\\n *\\n * No admin permissions are checked here: instead, this contract delegates that to the Vault's own Authorizer.\\n *\\n * Because this contract doesn't implement the swap hooks, derived contracts should generally inherit from\\n * BaseGeneralPool or BaseMinimalSwapInfoPool. Otherwise, subclasses must inherit from the corresponding interfaces\\n * and implement the swap callbacks themselves.\\n */\\nabstract contract BasePool is IBasePool, BasePoolAuthorization, BalancerPoolToken, TemporarilyPausable {\\n    using WordCodec for bytes32;\\n    using FixedPoint for uint256;\\n\\n    uint256 private constant _MIN_TOKENS = 2;\\n\\n    uint256 private constant _MINIMUM_BPT = 1e6;\\n\\n    // 1e18 corresponds to 1.0, or a 100% fee\\n    uint256 private constant _MIN_SWAP_FEE_PERCENTAGE = 1e12; // 0.0001%\\n    uint256 private constant _MAX_SWAP_FEE_PERCENTAGE = 1e17; // 10% - this fits in 64 bits\\n\\n    // Storage slot that can be used to store unrelated pieces of information. In particular, by default is used\\n    // to store only the swap fee percentage of a pool. But it can be extended to store some more pieces of information.\\n    // The swap fee percentage is stored in the most-significant 64 bits, therefore the remaining 192 bits can be\\n    // used to store any other piece of information.\\n    bytes32 private _miscData;\\n    uint256 private constant _SWAP_FEE_PERCENTAGE_OFFSET = 192;\\n\\n    bytes32 private immutable _poolId;\\n\\n    event SwapFeePercentageChanged(uint256 swapFeePercentage);\\n\\n    constructor(\\n        IVault vault,\\n        IVault.PoolSpecialization specialization,\\n        string memory name,\\n        string memory symbol,\\n        IERC20[] memory tokens,\\n        address[] memory assetManagers,\\n        uint256 swapFeePercentage,\\n        uint256 pauseWindowDuration,\\n        uint256 bufferPeriodDuration,\\n        address owner\\n    )\\n        // Base Pools are expected to be deployed using factories. By using the factory address as the action\\n        // disambiguator, we make all Pools deployed by the same factory share action identifiers. This allows for\\n        // simpler management of permissions (such as being able to manage granting the 'set fee percentage' action in\\n        // any Pool created by the same factory), while still making action identifiers unique among different factories\\n        // if the selectors match, preventing accidental errors.\\n        Authentication(bytes32(uint256(msg.sender)))\\n        BalancerPoolToken(name, symbol, vault)\\n        BasePoolAuthorization(owner)\\n        TemporarilyPausable(pauseWindowDuration, bufferPeriodDuration)\\n    {\\n        _require(tokens.length >= _MIN_TOKENS, Errors.MIN_TOKENS);\\n        _require(tokens.length <= _getMaxTokens(), Errors.MAX_TOKENS);\\n\\n        // The Vault only requires the token list to be ordered for the Two Token Pools specialization. However,\\n        // to make the developer experience consistent, we are requiring this condition for all the native pools.\\n        // Also, since these Pools will register tokens only once, we can ensure the Pool tokens will follow the same\\n        // order. We rely on this property to make Pools simpler to write, as it lets us assume that the\\n        // order of token-specific parameters (such as token weights) will not change.\\n        InputHelpers.ensureArrayIsSorted(tokens);\\n\\n        _setSwapFeePercentage(swapFeePercentage);\\n\\n        bytes32 poolId = vault.registerPool(specialization);\\n\\n        vault.registerTokens(poolId, tokens, assetManagers);\\n\\n        // Set immutable state variables - these cannot be read from during construction\\n        _poolId = poolId;\\n    }\\n\\n    // Getters / Setters\\n\\n    function getPoolId() public view override returns (bytes32) {\\n        return _poolId;\\n    }\\n\\n    function _getTotalTokens() internal view virtual returns (uint256);\\n\\n    function _getMaxTokens() internal pure virtual returns (uint256);\\n\\n    function _getMinimumBpt() internal pure virtual returns (uint256) {\\n        return _MINIMUM_BPT;\\n    }\\n\\n    function getSwapFeePercentage() public view returns (uint256) {\\n        return _miscData.decodeUint64(_SWAP_FEE_PERCENTAGE_OFFSET);\\n    }\\n\\n    function setSwapFeePercentage(uint256 swapFeePercentage) external virtual authenticate whenNotPaused {\\n        _setSwapFeePercentage(swapFeePercentage);\\n    }\\n\\n    function _setSwapFeePercentage(uint256 swapFeePercentage) private {\\n        _require(swapFeePercentage >= _MIN_SWAP_FEE_PERCENTAGE, Errors.MIN_SWAP_FEE_PERCENTAGE);\\n        _require(swapFeePercentage <= _MAX_SWAP_FEE_PERCENTAGE, Errors.MAX_SWAP_FEE_PERCENTAGE);\\n\\n        _miscData = _miscData.insertUint64(swapFeePercentage, _SWAP_FEE_PERCENTAGE_OFFSET);\\n        emit SwapFeePercentageChanged(swapFeePercentage);\\n    }\\n\\n    function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)\\n    public\\n    virtual\\n    authenticate\\n    whenNotPaused\\n    {\\n        _setAssetManagerPoolConfig(token, poolConfig);\\n    }\\n\\n    function _setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig) private {\\n        bytes32 poolId = getPoolId();\\n        (, , , address assetManager) = getVault().getPoolTokenInfo(poolId, token);\\n\\n        IAssetManager(assetManager).setConfig(poolId, poolConfig);\\n    }\\n\\n    function setPaused(bool paused) external authenticate {\\n        _setPaused(paused);\\n    }\\n\\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {\\n        return\\n        (actionId == getActionId(this.setSwapFeePercentage.selector)) ||\\n        (actionId == getActionId(this.setAssetManagerPoolConfig.selector));\\n    }\\n\\n    function _getMiscData() internal view returns (bytes32) {\\n        return _miscData;\\n    }\\n\\n    /**\\n     * Inserts data into the least-significant 192 bits of the misc data storage slot.\\n     * Note that the remaining 64 bits are used for the swap fee percentage and cannot be overloaded.\\n     */\\n    function _setMiscData(bytes32 newData) internal {\\n        _miscData = _miscData.insertBits192(newData, 0);\\n    }\\n\\n    // Join / Exit Hooks\\n\\n    modifier onlyVault(bytes32 poolId) {\\n        _require(msg.sender == address(getVault()), Errors.CALLER_NOT_VAULT);\\n        _require(poolId == getPoolId(), Errors.INVALID_POOL_ID);\\n        _;\\n    }\\n\\n    function onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\\n        uint256[] memory scalingFactors = _scalingFactors();\\n\\n        if (totalSupply() == 0) {\\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\\n                poolId,\\n                sender,\\n                recipient,\\n                scalingFactors,\\n                userData\\n            );\\n\\n            // On initialization, we lock _getMinimumBpt() by minting it for the zero address. This BPT acts as a\\n            // minimum as it will never be burned, which reduces potential issues with rounding, and also prevents the\\n            // Pool from ever being fully drained.\\n            _require(bptAmountOut >= _getMinimumBpt(), Errors.MINIMUM_BPT);\\n            _mintPoolTokens(address(0), _getMinimumBpt());\\n            _mintPoolTokens(recipient, bptAmountOut - _getMinimumBpt());\\n\\n            // amountsIn are amounts entering the Pool, so we round up.\\n            _downscaleUpArray(amountsIn, scalingFactors);\\n\\n            return (amountsIn, new uint256[](_getTotalTokens()));\\n        } else {\\n            _upscaleArray(balances, scalingFactors);\\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\\n                poolId,\\n                sender,\\n                recipient,\\n                balances,\\n                lastChangeBlock,\\n                protocolSwapFeePercentage,\\n                scalingFactors,\\n                userData\\n            );\\n\\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\\n\\n            _mintPoolTokens(recipient, bptAmountOut);\\n\\n            // amountsIn are amounts entering the Pool, so we round up.\\n            _downscaleUpArray(amountsIn, scalingFactors);\\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\\n\\n            return (amountsIn, dueProtocolFeeAmounts);\\n        }\\n    }\\n\\n    function onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\\n        uint256[] memory scalingFactors = _scalingFactors();\\n        _upscaleArray(balances, scalingFactors);\\n\\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            scalingFactors,\\n            userData\\n        );\\n\\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\\n\\n        _burnPoolTokens(sender, bptAmountIn);\\n\\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\\n        _downscaleDownArray(amountsOut, scalingFactors);\\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\\n\\n        return (amountsOut, dueProtocolFeeAmounts);\\n    }\\n\\n    // Query functions\\n\\n    /**\\n     * @dev Returns the amount of BPT that would be granted to `recipient` if the `onJoinPool` hook were called by the\\n     * Vault with the same arguments, along with the number of tokens `sender` would have to supply.\\n     *\\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\\n     * data, such as the protocol swap fee percentage and Pool balances.\\n     *\\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\\n     * explicitly use eth_call instead of eth_sendTransaction.\\n     */\\n    function queryJoin(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\\n\\n        _queryAction(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            userData,\\n            _onJoinPool,\\n            _downscaleUpArray\\n        );\\n\\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\\n        // and we don't need to return anything here - it just silences compiler warnings.\\n        return (bptOut, amountsIn);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\\n     *\\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\\n     * data, such as the protocol swap fee percentage and Pool balances.\\n     *\\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\\n     * explicitly use eth_call instead of eth_sendTransaction.\\n     */\\n    function queryExit(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\\n\\n        _queryAction(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            userData,\\n            _onExitPool,\\n            _downscaleDownArray\\n        );\\n\\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\\n        // and we don't need to return anything here - it just silences compiler warnings.\\n        return (bptIn, amountsOut);\\n    }\\n\\n    // Internal hooks to be overridden by derived contracts - all token amounts (except BPT) in these interfaces are\\n    // upscaled.\\n\\n    /**\\n     * @dev Called when the Pool is joined for the first time; that is, when the BPT total supply is zero.\\n     *\\n     * Returns the amount of BPT to mint, and the token amounts the Pool will receive in return.\\n     *\\n     * Minted BPT will be sent to `recipient`, except for _getMinimumBpt(), which will be deducted from this amount and\\n     * sent to the zero address instead. This will cause that BPT to remain forever locked there, preventing total BTP\\n     * from ever dropping below that value, and ensuring `_onInitializePool` can only be called once in the entire\\n     * Pool's lifetime.\\n     *\\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\\n     * be downscaled (rounding up) before being returned to the Vault.\\n     */\\n    function _onInitializePool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) internal virtual returns (uint256 bptAmountOut, uint256[] memory amountsIn);\\n\\n    /**\\n     * @dev Called whenever the Pool is joined after the first initialization join (see `_onInitializePool`).\\n     *\\n     * Returns the amount of BPT to mint, the token amounts that the Pool will receive in return, and the number of\\n     * tokens to pay in protocol swap fees.\\n     *\\n     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when\\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\\n     *\\n     * Minted BPT will be sent to `recipient`.\\n     *\\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\\n     * be downscaled (rounding up) before being returned to the Vault.\\n     *\\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onJoinPool`). These\\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\\n     */\\n    function _onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n    internal\\n    virtual\\n    returns (\\n        uint256 bptAmountOut,\\n        uint256[] memory amountsIn,\\n        uint256[] memory dueProtocolFeeAmounts\\n    );\\n\\n    /**\\n     * @dev Called whenever the Pool is exited.\\n     *\\n     * Returns the amount of BPT to burn, the token amounts for each Pool token that the Pool will grant in return, and\\n     * the number of tokens to pay in protocol swap fees.\\n     *\\n     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when\\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\\n     *\\n     * BPT will be burnt from `sender`.\\n     *\\n     * The Pool will grant tokens to `recipient`. These amounts are considered upscaled and will be downscaled\\n     * (rounding down) before being returned to the Vault.\\n     *\\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onExitPool`). These\\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\\n     */\\n    function _onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n    internal\\n    virtual\\n    returns (\\n        uint256 bptAmountIn,\\n        uint256[] memory amountsOut,\\n        uint256[] memory dueProtocolFeeAmounts\\n    );\\n\\n    // Internal functions\\n\\n    /**\\n     * @dev Adds swap fee amount to `amount`, returning a higher value.\\n     */\\n    function _addSwapFeeAmount(uint256 amount) internal view returns (uint256) {\\n        // This returns amount + fee amount, so we round up (favoring a higher fee amount).\\n        return amount.divUp(FixedPoint.ONE.sub(getSwapFeePercentage()));\\n    }\\n\\n    /**\\n     * @dev Subtracts swap fee amount from `amount`, returning a lower value.\\n     */\\n    function _subtractSwapFeeAmount(uint256 amount) internal view returns (uint256) {\\n        // This returns amount - fee amount, so we round up (favoring a higher fee amount).\\n        uint256 feeAmount = amount.mulUp(getSwapFeePercentage());\\n        return amount.sub(feeAmount);\\n    }\\n\\n    // Scaling\\n\\n    /**\\n     * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if\\n     * it had 18 decimals.\\n     */\\n    function _computeScalingFactor(IERC20 token) internal view returns (uint256) {\\n        if (address(token) == address(this)) {\\n            return FixedPoint.ONE;\\n        }\\n\\n        // Tokens that don't implement the `decimals` method are not supported.\\n        uint256 tokenDecimals = ERC20(address(token)).decimals();\\n\\n        // Tokens with more than 18 decimals are not supported.\\n        uint256 decimalsDifference = Math.sub(18, tokenDecimals);\\n        return FixedPoint.ONE * 10**decimalsDifference;\\n    }\\n\\n    /**\\n     * @dev Returns the scaling factor for one of the Pool's tokens. Reverts if `token` is not a token registered by the\\n     * Pool.\\n     *\\n     * All scaling factors are fixed-point values with 18 decimals, to allow for this function to be overridden by\\n     * derived contracts that need to apply further scaling, making these factors potentially non-integer.\\n     *\\n     * The largest 'base' scaling factor (i.e. in tokens with less than 18 decimals) is 10**18, which in fixed-point is\\n     * 10**36. This value can be multiplied with a 112 bit Vault balance with no overflow by a factor of ~1e7, making\\n     * even relatively 'large' factors safe to use.\\n     *\\n     * The 1e7 figure is the result of 2**256 / (1e18 * 1e18 * 2**112).\\n     */\\n    function _scalingFactor(IERC20 token) internal view virtual returns (uint256);\\n\\n    /**\\n     * @dev Same as `_scalingFactor()`, except for all registered tokens (in the same order as registered). The Vault\\n     * will always pass balances in this order when calling any of the Pool hooks.\\n     */\\n    function _scalingFactors() internal view virtual returns (uint256[] memory);\\n\\n    function getScalingFactors() external view returns (uint256[] memory) {\\n        return _scalingFactors();\\n    }\\n\\n    /**\\n     * @dev Applies `scalingFactor` to `amount`, resulting in a larger or equal value depending on whether it needed\\n     * scaling or not.\\n     */\\n    function _upscale(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\\n        // Upscale rounding wouldn't necessarily always go in the same direction: in a swap for example the balance of\\n        // token in should be rounded up, and that of token out rounded down. This is the only place where we round in\\n        // the same direction for all amounts, as the impact of this rounding is expected to be minimal (and there's no\\n        // rounding error unless `_scalingFactor()` is overriden).\\n        return FixedPoint.mulDown(amount, scalingFactor);\\n    }\\n\\n    /**\\n     * @dev Same as `_upscale`, but for an entire array. This function does not return anything, but instead *mutates*\\n     * the `amounts` array.\\n     */\\n    function _upscaleArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            amounts[i] = FixedPoint.mulDown(amounts[i], scalingFactors[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\\n     * whether it needed scaling or not. The result is rounded down.\\n     */\\n    function _downscaleDown(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\\n        return FixedPoint.divDown(amount, scalingFactor);\\n    }\\n\\n    /**\\n     * @dev Same as `_downscaleDown`, but for an entire array. This function does not return anything, but instead\\n     * *mutates* the `amounts` array.\\n     */\\n    function _downscaleDownArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            amounts[i] = FixedPoint.divDown(amounts[i], scalingFactors[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\\n     * whether it needed scaling or not. The result is rounded up.\\n     */\\n    function _downscaleUp(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\\n        return FixedPoint.divUp(amount, scalingFactor);\\n    }\\n\\n    /**\\n     * @dev Same as `_downscaleUp`, but for an entire array. This function does not return anything, but instead\\n     * *mutates* the `amounts` array.\\n     */\\n    function _downscaleUpArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            amounts[i] = FixedPoint.divUp(amounts[i], scalingFactors[i]);\\n        }\\n    }\\n\\n    function _getAuthorizer() internal view override returns (IAuthorizer) {\\n        // Access control management is delegated to the Vault's Authorizer. This lets Balancer Governance manage which\\n        // accounts can call permissioned functions: for example, to perform emergency pauses.\\n        // If the owner is delegated, then *all* permissioned functions, including `setSwapFeePercentage`, will be under\\n        // Governance control.\\n        return getVault().getAuthorizer();\\n    }\\n\\n    function _queryAction(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData,\\n        function(bytes32, address, address, uint256[] memory, uint256, uint256, uint256[] memory, bytes memory)\\n        internal\\n        returns (uint256, uint256[] memory, uint256[] memory) _action,\\n        function(uint256[] memory, uint256[] memory) internal view _downscaleArray\\n    ) private {\\n        // This uses the same technique used by the Vault in queryBatchSwap. Refer to that function for a detailed\\n        // explanation.\\n\\n        if (msg.sender != address(this)) {\\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\\n            // the preceding if statement will be executed instead.\\n\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = address(this).call(msg.data);\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n            // This call should always revert to decode the bpt and token amounts from the revert reason\\n                switch success\\n                case 0 {\\n                // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\\n                // stored there as we take full control of the execution and then immediately return.\\n\\n                // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\\n                // there was another revert reason and we should forward it.\\n                    returndatacopy(0, 0, 0x04)\\n                    let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\\n\\n                // If the first 4 bytes don't match with the expected signature, we forward the revert reason.\\n                    if eq(eq(error, 0x43adbafb00000000000000000000000000000000000000000000000000000000), 0) {\\n                        returndatacopy(0, 0, returndatasize())\\n                        revert(0, returndatasize())\\n                    }\\n\\n                // The returndata contains the signature, followed by the raw memory representation of the\\n                // `bptAmount` and `tokenAmounts` (array: length + data). We need to return an ABI-encoded\\n                // representation of these.\\n                // An ABI-encoded response will include one additional field to indicate the starting offset of\\n                // the `tokenAmounts` array. The `bptAmount` will be laid out in the first word of the\\n                // returndata.\\n                //\\n                // In returndata:\\n                // [ signature ][ bptAmount ][ tokenAmounts length ][ tokenAmounts values ]\\n                // [  4 bytes  ][  32 bytes ][       32 bytes      ][ (32 * length) bytes ]\\n                //\\n                // We now need to return (ABI-encoded values):\\n                // [ bptAmount ][ tokeAmounts offset ][ tokenAmounts length ][ tokenAmounts values ]\\n                // [  32 bytes ][       32 bytes     ][       32 bytes      ][ (32 * length) bytes ]\\n\\n                // We copy 32 bytes for the `bptAmount` from returndata into memory.\\n                // Note that we skip the first 4 bytes for the error signature\\n                    returndatacopy(0, 0x04, 32)\\n\\n                // The offsets are 32-bytes long, so the array of `tokenAmounts` will start after\\n                // the initial 64 bytes.\\n                    mstore(0x20, 64)\\n\\n                // We now copy the raw memory array for the `tokenAmounts` from returndata into memory.\\n                // Since bpt amount and offset take up 64 bytes, we start copying at address 0x40. We also\\n                // skip the first 36 bytes from returndata, which correspond to the signature plus bpt amount.\\n                    returndatacopy(0x40, 0x24, sub(returndatasize(), 36))\\n\\n                // We finally return the ABI-encoded uint256 and the array, which has a total length equal to\\n                // the size of returndata, plus the 32 bytes of the offset but without the 4 bytes of the\\n                // error signature.\\n                    return(0, add(returndatasize(), 28))\\n                }\\n                default {\\n                // This call should always revert, but we fail nonetheless if that didn't happen\\n                    invalid()\\n                }\\n            }\\n        } else {\\n            uint256[] memory scalingFactors = _scalingFactors();\\n            _upscaleArray(balances, scalingFactors);\\n\\n            (uint256 bptAmount, uint256[] memory tokenAmounts, ) = _action(\\n                poolId,\\n                sender,\\n                recipient,\\n                balances,\\n                lastChangeBlock,\\n                protocolSwapFeePercentage,\\n                scalingFactors,\\n                userData\\n            );\\n\\n            _downscaleArray(tokenAmounts, scalingFactors);\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n            // We will return a raw representation of `bptAmount` and `tokenAmounts` in memory, which is composed of\\n            // a 32-byte uint256, followed by a 32-byte for the array length, and finally the 32-byte uint256 values\\n            // Because revert expects a size in bytes, we multiply the array length (stored at `tokenAmounts`) by 32\\n                let size := mul(mload(tokenAmounts), 32)\\n\\n            // We store the `bptAmount` in the previous slot to the `tokenAmounts` array. We can make sure there\\n            // will be at least one available slot due to how the memory scratch space works.\\n            // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\\n                let start := sub(tokenAmounts, 0x20)\\n                mstore(start, bptAmount)\\n\\n            // We send one extra value for the error signature \\\"QueryError(uint256,uint256[])\\\" which is 0x43adbafb\\n            // We use the previous slot to `bptAmount`.\\n                mstore(sub(start, 0x20), 0x0000000000000000000000000000000000000000000000000000000043adbafb)\\n                start := sub(start, 0x04)\\n\\n            // When copying from `tokenAmounts` into returndata, we copy the additional 68 bytes to also return\\n            // the `bptAmount`, the array 's length, and the error signature.\\n                revert(start, add(size, 68))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2db06ff34c2573aff6217f5a6be46c32fbb2cb376ad674a77572b00ea28775d2\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/BasePoolAuthorization.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../Authentication.sol\\\";\\nimport \\\"../vault/IAuthorizer.sol\\\";\\n\\nimport \\\"./BasePool.sol\\\";\\n\\n/**\\n * @dev Base authorization layer implementation for Pools.\\n *\\n * The owner account can call some of the permissioned functions - access control of the rest is delegated to the\\n * Authorizer. Note that this owner is immutable: more sophisticated permission schemes, such as multiple ownership,\\n * granular roles, etc., could be built on top of this by making the owner a smart contract.\\n *\\n * Access control of all other permissioned functions is delegated to an Authorizer. It is also possible to delegate\\n * control of *all* permissioned functions to the Authorizer by setting the owner address to `_DELEGATE_OWNER`.\\n */\\nabstract contract BasePoolAuthorization is Authentication {\\n    address private immutable _owner;\\n\\n    address private constant _DELEGATE_OWNER = 0xBA1BA1ba1BA1bA1bA1Ba1BA1ba1BA1bA1ba1ba1B;\\n\\n    constructor(address owner) {\\n        _owner = owner;\\n    }\\n\\n    function getOwner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function getAuthorizer() external view returns (IAuthorizer) {\\n        return _getAuthorizer();\\n    }\\n\\n    function _canPerform(bytes32 actionId, address account) internal view override returns (bool) {\\n        if ((getOwner() != _DELEGATE_OWNER) && _isOwnerOnlyAction(actionId)) {\\n            // Only the owner can perform \\\"owner only\\\" actions, unless the owner is delegated.\\n            return msg.sender == getOwner();\\n        } else {\\n            // Non-owner actions are always processed via the Authorizer, as \\\"owner only\\\" ones are when delegated.\\n            return _getAuthorizer().canPerform(actionId, account, address(this));\\n        }\\n    }\\n\\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual returns (bool);\\n\\n    function _getAuthorizer() internal view virtual returns (IAuthorizer);\\n}\\n\",\"keccak256\":\"0xd4557d881d2d284a53ec4deddef4993d6ff962597354d6d5e6af3b2601fc4dee\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/BasePoolSplitCodeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./BaseSplitCodeFactory.sol\\\";\\nimport \\\"../vault/IVault.sol\\\";\\n\\n/**\\n * @dev Same as `BasePoolFactory`, for Pools whose creation code is so large that the factory cannot hold it.\\n */\\nabstract contract BasePoolSplitCodeFactory is BaseSplitCodeFactory {\\n    IVault private immutable _vault;\\n    mapping(address => bool) private _isPoolFromFactory;\\n\\n    event PoolCreated(address indexed pool);\\n\\n    constructor(IVault vault, bytes memory creationCode) BaseSplitCodeFactory(creationCode) {\\n        _vault = vault;\\n    }\\n\\n    /**\\n     * @dev Returns the Vault's address.\\n     */\\n    function getVault() public view returns (IVault) {\\n        return _vault;\\n    }\\n\\n    /**\\n     * @dev Returns true if `pool` was created by this factory.\\n     */\\n    function isPoolFromFactory(address pool) external view returns (bool) {\\n        return _isPoolFromFactory[pool];\\n    }\\n\\n    function _create(bytes memory constructorArgs) internal override returns (address) {\\n        address pool = super._create(constructorArgs);\\n\\n        _isPoolFromFactory[pool] = true;\\n        emit PoolCreated(pool);\\n\\n        return pool;\\n    }\\n}\\n\",\"keccak256\":\"0x058f182ae8a935461eba91b348cd892a9adb16ca00e60ff2bcb9fb3e9b4d1041\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/BaseSplitCodeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../CodeDeployer.sol\\\";\\n\\n/**\\n * @dev Base factory for contracts whose creation code is so large that the factory cannot hold it. This happens when\\n * the contract's creation code grows close to 24kB.\\n *\\n * Note that this factory cannot help with contracts that have a *runtime* (deployed) bytecode larger than 24kB.\\n */\\nabstract contract BaseSplitCodeFactory {\\n    // The contract's creation code is stored as code in two separate addresses, and retrieved via `extcodecopy`. This\\n    // means this factory supports contracts with creation code of up to 48kB.\\n    // We rely on inline-assembly to achieve this, both to make the entire operation highly gas efficient, and because\\n    // `extcodecopy` is not available in Solidity.\\n\\n    // solhint-disable no-inline-assembly\\n\\n    address private immutable _creationCodeContractA;\\n    uint256 private immutable _creationCodeSizeA;\\n\\n    address private immutable _creationCodeContractB;\\n    uint256 private immutable _creationCodeSizeB;\\n\\n    /**\\n     * @dev The creation code of a contract Foo can be obtained inside Solidity with `type(Foo).creationCode`.\\n     */\\n    constructor(bytes memory creationCode) {\\n        uint256 creationCodeSize = creationCode.length;\\n\\n        // We are going to deploy two contracts: one with approximately the first half of `creationCode`'s contents\\n        // (A), and another with the remaining half (B).\\n        // We store the lengths in both immutable and stack variables, since immutable variables cannot be read during\\n        // construction.\\n        uint256 creationCodeSizeA = creationCodeSize / 2;\\n        _creationCodeSizeA = creationCodeSizeA;\\n\\n        uint256 creationCodeSizeB = creationCodeSize - creationCodeSizeA;\\n        _creationCodeSizeB = creationCodeSizeB;\\n\\n        // To deploy the contracts, we're going to use `CodeDeployer.deploy()`, which expects a memory array with\\n        // the code to deploy. Note that we cannot simply create arrays for A and B's code by copying or moving\\n        // `creationCode`'s contents as they are expected to be very large (> 24kB), so we must operate in-place.\\n\\n        // Memory: [ code length ] [ A.data ] [ B.data ]\\n\\n        // Creating A's array is simple: we simply replace `creationCode`'s length with A's length. We'll later restore\\n        // the original length.\\n\\n        bytes memory creationCodeA;\\n        assembly {\\n            creationCodeA := creationCode\\n            mstore(creationCodeA, creationCodeSizeA)\\n        }\\n\\n        // Memory: [ A.length ] [ A.data ] [ B.data ]\\n        //         ^ creationCodeA\\n\\n        _creationCodeContractA = CodeDeployer.deploy(creationCodeA);\\n\\n        // Creating B's array is a bit more involved: since we cannot move B's contents, we are going to create a 'new'\\n        // memory array starting at A's last 32 bytes, which will be replaced with B's length. We'll back-up this last\\n        // byte to later restore it.\\n\\n        bytes memory creationCodeB;\\n        bytes32 lastByteA;\\n\\n        assembly {\\n            // `creationCode` points to the array's length, not data, so by adding A's length to it we arrive at A's\\n            // last 32 bytes.\\n            creationCodeB := add(creationCode, creationCodeSizeA)\\n            lastByteA := mload(creationCodeB)\\n            mstore(creationCodeB, creationCodeSizeB)\\n        }\\n\\n        // Memory: [ A.length ] [ A.data[ : -1] ] [ B.length ][ B.data ]\\n        //         ^ creationCodeA                ^ creationCodeB\\n\\n        _creationCodeContractB = CodeDeployer.deploy(creationCodeB);\\n\\n        // We now restore the original contents of `creationCode` by writing back the original length and A's last byte.\\n        assembly {\\n            mstore(creationCodeA, creationCodeSize)\\n            mstore(creationCodeB, lastByteA)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the two addresses where the creation code of the contract crated by this factory is stored.\\n     */\\n    function getCreationCodeContracts() public view returns (address contractA, address contractB) {\\n        return (_creationCodeContractA, _creationCodeContractB);\\n    }\\n\\n    /**\\n     * @dev Returns the creation code of the contract this factory creates.\\n     */\\n    function getCreationCode() public view returns (bytes memory) {\\n        return _getCreationCodeWithArgs(\\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the creation code that will result in a contract being deployed with `constructorArgs`.\\n     */\\n    function _getCreationCodeWithArgs(bytes memory constructorArgs) public view returns (bytes memory code) {\\n        // This function exists because `abi.encode()` cannot be instructed to place its result at a specific address.\\n        // We need for the ABI-encoded constructor arguments to be located immediately after the creation code, but\\n        // cannot rely on `abi.encodePacked()` to perform concatenation as that would involve copying the creation code,\\n        // which would be prohibitively expensive.\\n        // Instead, we compute the creation code in a pre-allocated array that is large enough to hold *both* the\\n        // creation code and the constructor arguments, and then copy the ABI-encoded arguments (which should not be\\n        // overly long) right after the end of the creation code.\\n\\n        // Immutable variables cannot be used in assembly, so we store them in the stack first.\\n        address creationCodeContractA = _creationCodeContractA;\\n        uint256 creationCodeSizeA = _creationCodeSizeA;\\n        address creationCodeContractB = _creationCodeContractB;\\n        uint256 creationCodeSizeB = _creationCodeSizeB;\\n\\n        uint256 creationCodeSize = creationCodeSizeA + creationCodeSizeB;\\n        uint256 constructorArgsSize = constructorArgs.length;\\n\\n        uint256 codeSize = creationCodeSize + constructorArgsSize;\\n\\n        assembly {\\n            // First, we allocate memory for `code` by retrieving the free memory pointer and then moving it ahead of\\n            // `code` by the size of the creation code plus constructor arguments, and 32 bytes for the array length.\\n            code := mload(0x40)\\n            mstore(0x40, add(code, add(codeSize, 32)))\\n\\n            // We now store the length of the code plus constructor arguments.\\n            mstore(code, codeSize)\\n\\n            // Next, we concatenate the creation code stored in A and B.\\n            let dataStart := add(code, 32)\\n            extcodecopy(creationCodeContractA, dataStart, 0, creationCodeSizeA)\\n            extcodecopy(creationCodeContractB, add(dataStart, creationCodeSizeA), 0, creationCodeSizeB)\\n        }\\n\\n        // Finally, we copy the constructorArgs to the end of the array. Unfortunately there is no way to avoid this\\n        // copy, as it is not possible to tell Solidity where to store the result of `abi.encode()`.\\n        uint256 constructorArgsDataPtr;\\n        uint256 constructorArgsCodeDataPtr;\\n        assembly {\\n            constructorArgsDataPtr := add(constructorArgs, 32)\\n            constructorArgsCodeDataPtr := add(add(code, 32), creationCodeSize)\\n        }\\n\\n        _memcpy(constructorArgsCodeDataPtr, constructorArgsDataPtr, constructorArgsSize);\\n    }\\n\\n    /**\\n     * @dev Deploys a contract with constructor arguments. To create `constructorArgs`, call `abi.encode()` with the\\n     * contract's constructor arguments, in order.\\n     */\\n    function _create(bytes memory constructorArgs) internal virtual returns (address) {\\n        bytes memory creationCode = _getCreationCodeWithArgs(constructorArgs);\\n\\n        address destination;\\n        assembly {\\n            destination := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        if (destination == address(0)) {\\n            // Bubble up inner revert reason\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        return destination;\\n    }\\n\\n    // From\\n    // https://github.com/Arachnid/solidity-stringutils/blob/b9a6f6615cf18a87a823cbc461ce9e140a61c305/src/strings.sol\\n    function _memcpy(\\n        uint256 dest,\\n        uint256 src,\\n        uint256 len\\n    ) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint256 mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe13b059ef0f2a075d87335c2d7e4d98c5aecad8461e1e04530f1ac001b195ec9\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/FactoryWidePauseWindow.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Utility to create Pool factories for Pools that use the `TemporarilyPausable` contract.\\n *\\n * By calling `TemporarilyPausable`'s constructor with the result of `getPauseConfiguration`, all Pools created by this\\n * factory will share the same Pause Window end time, after which both old and new Pools will not be pausable.\\n */\\ncontract FactoryWidePauseWindow {\\n    // This contract relies on timestamps in a similar way as `TemporarilyPausable` does - the same caveats apply.\\n    // solhint-disable not-rely-on-time\\n\\n    uint256 private constant _INITIAL_PAUSE_WINDOW_DURATION = 90 days;\\n    uint256 private constant _BUFFER_PERIOD_DURATION = 30 days;\\n\\n    // Time when the pause window for all created Pools expires, and the pause window duration of new Pools becomes\\n    // zero.\\n    uint256 private immutable _poolsPauseWindowEndTime;\\n\\n    constructor() {\\n        _poolsPauseWindowEndTime = block.timestamp + _INITIAL_PAUSE_WINDOW_DURATION;\\n    }\\n\\n    /**\\n     * @dev Returns the current `TemporarilyPausable` configuration that will be applied to Pools created by this\\n     * factory.\\n     *\\n     * `pauseWindowDuration` will decrease over time until it reaches zero, at which point both it and\\n     * `bufferPeriodDuration` will be zero forever, meaning deployed Pools will not be pausable.\\n     */\\n    function getPauseConfiguration() public view returns (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\\n        uint256 currentTime = block.timestamp;\\n        if (currentTime < _poolsPauseWindowEndTime) {\\n            // The buffer period is always the same since its duration is related to how much time is needed to respond\\n            // to a potential emergency. The Pause Window duration however decreases as the end time approaches.\\n\\n            pauseWindowDuration = _poolsPauseWindowEndTime - currentTime; // No need for checked arithmetic.\\n            bufferPeriodDuration = _BUFFER_PERIOD_DURATION;\\n        } else {\\n            // After the end time, newly created Pools have no Pause Window, nor Buffer Period (since they are not\\n            // pausable in the first place).\\n\\n            pauseWindowDuration = 0;\\n            bufferPeriodDuration = 0;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7d764b70fdb9f4d2b07f2914ff5deec66f1bc193741017afef2fa14be57dc4ef\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/IGeneralPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../vault/IBasePool.sol\\\";\\n\\n/**\\n * @dev IPools with the General specialization setting should implement this interface.\\n *\\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will\\n * grant to the pool in a 'given out' swap.\\n *\\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\\n * indeed the Vault.\\n */\\ninterface IGeneralPool is IBasePool {\\n    function onSwap(\\n        SwapRequest memory swapRequest,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) external returns (uint256 amount);\\n}\\n\",\"keccak256\":\"0x789e1fa2b43a91a73ca03a9c356beb2b67d3cb26717e519bd7682d60768c0fe9\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BasePool/IMinimalSwapInfoPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../vault/IBasePool.sol\\\";\\n\\n/**\\n * @dev Pool contracts with the MinimalSwapInfo or TwoToken specialization settings should implement this interface.\\n *\\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will grant\\n * to the pool in a 'given out' swap.\\n *\\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\\n * indeed the Vault.\\n */\\ninterface IMinimalSwapInfoPool is IBasePool {\\n    function onSwap(\\n        SwapRequest memory swapRequest,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) external returns (uint256 amount);\\n}\\n\",\"keccak256\":\"0x7ff63c9310b52a08ab01ff6b18576041b5602033019f234fffd17d5c83c7149b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/CodeDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Library used to deploy contracts with specific code. This can be used for long-term storage of immutable data as\\n * contract code, which can be retrieved via the `extcodecopy` opcode.\\n */\\nlibrary CodeDeployer {\\n    // During contract construction, the full code supplied exists as code, and can be accessed via `codesize` and\\n    // `codecopy`. This is not the contract's final code however: whatever the constructor returns is what will be\\n    // stored as its code.\\n    //\\n    // We use this mechanism to have a simple constructor that stores whatever is appended to it. The following opcode\\n    // sequence corresponds to the creation code of the following equivalent Solidity contract, plus padding to make the\\n    // full code 32 bytes long:\\n    //\\n    // contract CodeDeployer {\\n    //     constructor() payable {\\n    //         uint256 size;\\n    //         assembly {\\n    //             size := sub(codesize(), 32) // size of appended data, as constructor is 32 bytes long\\n    //             codecopy(0, 32, size) // copy all appended data to memory at position 0\\n    //             return(0, size) // return appended data for it to be stored as code\\n    //         }\\n    //     }\\n    // }\\n    //\\n    // More specifically, it is composed of the following opcodes (plus padding):\\n    //\\n    // [1] PUSH1 0x20\\n    // [2] CODESIZE\\n    // [3] SUB\\n    // [4] DUP1\\n    // [6] PUSH1 0x20\\n    // [8] PUSH1 0x00\\n    // [9] CODECOPY\\n    // [11] PUSH1 0x00\\n    // [12] RETURN\\n    //\\n    // The padding is just the 0xfe sequence (invalid opcode).\\n    bytes32\\n        private constant _DEPLOYER_CREATION_CODE = 0x602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe;\\n\\n    /**\\n     * @dev Deploys a contract with `code` as its code, returning the destination address.\\n     *\\n     * Reverts if deployment fails.\\n     */\\n    function deploy(bytes memory code) internal returns (address destination) {\\n        bytes32 deployerCreationCode = _DEPLOYER_CREATION_CODE;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let codeLength := mload(code)\\n\\n            // `code` is composed of length and data. We've already stored its length in `codeLength`, so we simply\\n            // replace it with the deployer creation code (which is exactly 32 bytes long).\\n            mstore(code, deployerCreationCode)\\n\\n            // At this point, `code` now points to the deployer creation code immediately followed by `code`'s data\\n            // contents. This is exactly what the deployer expects to receive when created.\\n            destination := create(0, code, add(codeLength, 32))\\n\\n            // Finally, we restore the original length in order to not mutate `code`.\\n            mstore(code, codeLength)\\n        }\\n\\n        // The create opcode returns the zero address when contract creation fails, so we revert if this happens.\\n        _require(destination != address(0), Errors.CODE_DEPLOYMENT_FAILED);\\n    }\\n}\\n\",\"keccak256\":\"0xfeb244ff55cfa33a17a1cef41ea065c651cb00f375d4139e1c6de805c7d9c17d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/ERC20/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _HASHED_NAME = keccak256(bytes(name));\\n        _HASHED_VERSION = keccak256(bytes(version));\\n        _TYPE_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _domainSeparatorV4(), structHash));\\n    }\\n\\n    function _getChainId() private view returns (uint256 chainId) {\\n        // Silence state mutability warning without generating bytecode.\\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\\n        // https://github.com/ethereum/solidity/issues/2691\\n        this;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0cf3ec5d6130aac057e69df14b1ff87baf9c6c2cb13bc545952def004e629ac0\",\"license\":\"MIT\"},\"contracts/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            msg.sender,\\n            _allowances[sender][msg.sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_ALLOWANCE)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender].sub(subtractedValue, Errors.ERC20_DECREASED_ALLOWANCE_BELOW_ZERO)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        _require(sender != address(0), Errors.ERC20_TRANSFER_FROM_ZERO_ADDRESS);\\n        _require(recipient != address(0), Errors.ERC20_TRANSFER_TO_ZERO_ADDRESS);\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_BALANCE);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function mint(address account, uint256 amount) external {\\n        _mint(account, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        _require(account != address(0), Errors.ERC20_BURN_FROM_ZERO_ADDRESS);\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, Errors.ERC20_BURN_EXCEEDS_ALLOWANCE);\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xac2d52e844fc7561944bda133950d8477df597c4fd1874cd1fceb4838af28ac0\",\"license\":\"MIT\"},\"contracts/ERC20/ERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./EIP712.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    mapping(address => uint256) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private immutable _PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        // solhint-disable-next-line not-rely-on-time\\n        _require(block.timestamp <= deadline, Errors.EXPIRED_PERMIT);\\n\\n        uint256 nonce = _nonces[owner];\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonce, deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ecrecover(hash, v, r, s);\\n        _require((signer != address(0)) && (signer == owner), Errors.INVALID_SIGNATURE);\\n\\n        _nonces[owner] = nonce + 1;\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view override returns (uint256) {\\n        return _nonces[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n}\\n\",\"keccak256\":\"0x28f96497e4b653b5ae3b3f1f34ce749dab19c1034304f77398c4958e8af7e900\",\"license\":\"MIT\"},\"contracts/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xd828a935a72a6d182912abba290e4debb8c684c36fd756088f7acb30e0b2bb76\",\"license\":\"MIT\"},\"contracts/ERC20/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xffe929ce55ef0cbdcc60eee8bc9375c295757ad13afe3d757646538aa0429ff5\",\"license\":\"MIT\"},\"contracts/ERC20/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, Errors.SUB_OVERFLOW);\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, uint256 errorCode) internal pure returns (uint256) {\\n        _require(b <= a, errorCode);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0x093533affa761201172041c9799b8531f01a6d68deee74a5a97f76ba957d836e\",\"license\":\"MIT\"},\"contracts/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./LogExpMath.sol\\\";\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((aInflated - 1) / b) + 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return sub(raw, maxError);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        return add(raw, maxError);\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf11b46d44740391d1bf1454e1ea3ccaa743e131599e675ab867a00165a306a44\",\"license\":\"GPL-3.0-or-later\"},\"contracts/IAssetManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC20/IERC20.sol\\\";\\n\\ninterface IAssetManager {\\n    /**\\n     * @notice Emitted when asset manager is rebalanced\\n     */\\n    event Rebalance(bytes32 poolId);\\n\\n    /**\\n     * @notice Sets the config\\n     */\\n    function setConfig(bytes32 poolId, bytes calldata config) external;\\n\\n    /**\\n     * Note: No function to read the asset manager config is included in IAssetManager\\n     * as the signature is expected to vary between asset manager implementations\\n     */\\n\\n    /**\\n     * @notice Returns the asset manager's token\\n     */\\n    function getToken() external view returns (IERC20);\\n\\n    /**\\n     * @return the current assets under management of this asset manager\\n     */\\n    function getAUM(bytes32 poolId) external view returns (uint256);\\n\\n    /**\\n     * @return poolCash - The up-to-date cash balance of the pool\\n     * @return poolManaged - The up-to-date managed balance of the pool\\n     */\\n    function getPoolBalances(bytes32 poolId) external view returns (uint256 poolCash, uint256 poolManaged);\\n\\n    /**\\n     * @return The difference in tokens between the target investment\\n     * and the currently invested amount (i.e. the amount that can be invested)\\n     */\\n    function maxInvestableBalance(bytes32 poolId) external view returns (int256);\\n\\n    /**\\n     * @notice Updates the Vault on the value of the pool's investment returns\\n     */\\n    function updateBalanceOfPool(bytes32 poolId) external;\\n\\n    /**\\n     * @notice Determines whether the pool should rebalance given the provided balances\\n     */\\n    function shouldRebalance(uint256 cash, uint256 managed) external view returns (bool);\\n\\n    /**\\n     * @notice Rebalances funds between the pool and the asset manager to maintain target investment percentage.\\n     * @param poolId - the poolId of the pool to be rebalanced\\n     * @param force - a boolean representing whether a rebalance should be forced even when the pool is near balance\\n     */\\n    function rebalance(bytes32 poolId, bool force) external;\\n\\n    /**\\n     * @notice allows an authorized rebalancer to remove capital to facilitate large withdrawals\\n     * @param poolId - the poolId of the pool to withdraw funds back to\\n     * @param amount - the amount of tokens to withdraw back to the pool\\n     */\\n    function capitalOut(bytes32 poolId, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0xcab501c5bd9bcb0ed50029fab387bcd0546b4e13ce3a8970663f97568deaf3a1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/IAuthentication.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IAuthentication {\\n    /**\\n     * @dev Returns the action identifier associated with the external function described by `selector`.\\n     */\\n    function getActionId(bytes4 selector) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xfd687ced203d2c6da8189792e1719a5182faf45956129388b231ee76740b99a6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/InputHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ERC20/IERC20.sol\\\";\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\nlibrary InputHelpers {\\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\\n        _require(a == b, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureInputLengthMatch(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) internal pure {\\n        _require(a == b && b == c, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\\n        address[] memory addressArray;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addressArray := array\\n        }\\n        ensureArrayIsSorted(addressArray);\\n    }\\n\\n    function ensureArrayIsSorted(address[] memory array) internal pure {\\n        if (array.length < 2) {\\n            return;\\n        }\\n\\n        address previous = array[0];\\n        for (uint256 i = 1; i < array.length; ++i) {\\n            address current = array[i];\\n            _require(previous < current, Errors.UNSORTED_ARRAY);\\n            previous = current;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9687cff775a4c7e280c656b24ec084320b736673c77b756a50741c149c74e6da\",\"license\":\"GPL-3.0-or-later\"},\"contracts/LogCompression.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./LogExpMath.sol\\\";\\n\\n/**\\n * @dev Library for encoding and decoding values stored inside a 256 bit word. Typically used to pack multiple values in\\n * a single storage slot, saving gas by performing less storage accesses.\\n *\\n * Each value is defined by its size and the least significant bit in the word, also known as offset. For example, two\\n * 128 bit values may be encoded in a word by assigning one an offset of 0, and the other an offset of 128.\\n */\\nlibrary LogCompression {\\n    int256 private constant _LOG_COMPRESSION_FACTOR = 1e14;\\n    int256 private constant _HALF_LOG_COMPRESSION_FACTOR = 0.5e14;\\n\\n    /**\\n     * @dev Returns the natural logarithm of `value`, dropping most of the decimal places to arrive at a value that,\\n     * when passed to `fromLowResLog`, will have a maximum relative error of ~0.05% compared to `value`.\\n     *\\n     * Values returned from this function should not be mixed with other fixed-point values (as they have a different\\n     * number of digits), but can be added or subtracted. Use `fromLowResLog` to undo this process and return to an\\n     * 18 decimal places fixed point value.\\n     *\\n     * Because so much precision is lost, the logarithmic values can be stored using much fewer bits than the original\\n     * value required.\\n     */\\n    function toLowResLog(uint256 value) internal pure returns (int256) {\\n        int256 ln = LogExpMath.ln(int256(value));\\n\\n        // Rounding division for signed numerator\\n        int256 lnWithError = (ln > 0 ? ln + _HALF_LOG_COMPRESSION_FACTOR : ln - _HALF_LOG_COMPRESSION_FACTOR);\\n        return lnWithError / _LOG_COMPRESSION_FACTOR;\\n    }\\n\\n    /**\\n     * @dev Restores `value` from logarithmic space. `value` is expected to be the result of a call to `toLowResLog`,\\n     * any other function that returns 4 decimals fixed point logarithms, or the sum of such values.\\n     */\\n    function fromLowResLog(int256 value) internal pure returns (uint256) {\\n        return uint256(LogExpMath.exp(value * _LOG_COMPRESSION_FACTOR));\\n    }\\n}\\n\",\"keccak256\":\"0x3ac3f142c4c6d52740809fb69de999d67a1ac37e3d7998a74d8dd625c44d4930\",\"license\":\"GPL-3.0-or-later\"},\"contracts/LogExpMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\\n// documentation files (the \\u201cSoftware\\u201d), to deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\\n// Software.\\n\\n// THE SOFTWARE IS PROVIDED \\u201cAS IS\\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        if (y == 0) {\\n            // We solve the 0^0 indetermination by making it equal one.\\n            return uint256(ONE_18);\\n        }\\n\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n        // x^y = exp(y * ln(x)).\\n\\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\\n        int256 x_int256 = int256(x);\\n\\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\\n        int256 y_int256 = int256(y);\\n\\n        int256 logx_times_y;\\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n            int256 ln_36_x = _ln_36(x_int256);\\n\\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n            // (downscaled) last 18 decimals.\\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\\n        } else {\\n            logx_times_y = _ln(x_int256) * y_int256;\\n        }\\n        logx_times_y /= ONE_18;\\n\\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n        _require(\\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n            Errors.PRODUCT_OUT_OF_BOUNDS\\n        );\\n\\n        return uint256(exp(logx_times_y));\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\\n\\n        if (x < 0) {\\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n            // Fixed point division requires multiplying by ONE_18.\\n            return ((ONE_18 * ONE_18) / exp(-x));\\n        }\\n\\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n        // decomposition.\\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest x_n.\\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n        // decomposition.\\n\\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n        // it and compute the accumulated product.\\n\\n        int256 firstAN;\\n        if (x >= x0) {\\n            x -= x0;\\n            firstAN = a0;\\n        } else if (x >= x1) {\\n            x -= x1;\\n            firstAN = a1;\\n        } else {\\n            firstAN = 1; // One with no decimal places\\n        }\\n\\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n        // smaller terms.\\n        x *= 100;\\n\\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n        int256 product = ONE_20;\\n\\n        if (x >= x2) {\\n            x -= x2;\\n            product = (product * a2) / ONE_20;\\n        }\\n        if (x >= x3) {\\n            x -= x3;\\n            product = (product * a3) / ONE_20;\\n        }\\n        if (x >= x4) {\\n            x -= x4;\\n            product = (product * a4) / ONE_20;\\n        }\\n        if (x >= x5) {\\n            x -= x5;\\n            product = (product * a5) / ONE_20;\\n        }\\n        if (x >= x6) {\\n            x -= x6;\\n            product = (product * a6) / ONE_20;\\n        }\\n        if (x >= x7) {\\n            x -= x7;\\n            product = (product * a7) / ONE_20;\\n        }\\n        if (x >= x8) {\\n            x -= x8;\\n            product = (product * a8) / ONE_20;\\n        }\\n        if (x >= x9) {\\n            x -= x9;\\n            product = (product * a9) / ONE_20;\\n        }\\n\\n        // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n        // The first term is simply x.\\n        term = x;\\n        seriesSum += term;\\n\\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n        term = ((term * x) / ONE_20) / 2;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 3;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 4;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 5;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 6;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 7;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 8;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 9;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 10;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 11;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 12;\\n        seriesSum += term;\\n\\n        // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n        // and then drop two digits to return an 18 decimal value.\\n\\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n        // upscaling.\\n\\n        int256 logBase;\\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n            logBase = _ln_36(base);\\n        } else {\\n            logBase = _ln(base) * ONE_18;\\n        }\\n\\n        int256 logArg;\\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n            logArg = _ln_36(arg);\\n        } else {\\n            logArg = _ln(arg) * ONE_18;\\n        }\\n\\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n        return (logArg * ONE_18) / logBase;\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        // The real natural logarithm is not defined for negative numbers or zero.\\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n            return _ln_36(a) / ONE_18;\\n        } else {\\n            return _ln(a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        if (a < ONE_18) {\\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n            // Fixed point division requires multiplying by ONE_18.\\n            return (-_ln((ONE_18 * ONE_18) / a));\\n        }\\n\\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest a_n.\\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n        // ONE_18 to convert them to fixed point.\\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n        // by it and compute the accumulated sum.\\n\\n        int256 sum = 0;\\n        if (a >= a0 * ONE_18) {\\n            a /= a0; // Integer, not fixed point division\\n            sum += x0;\\n        }\\n\\n        if (a >= a1 * ONE_18) {\\n            a /= a1; // Integer, not fixed point division\\n            sum += x1;\\n        }\\n\\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n        sum *= 100;\\n        a *= 100;\\n\\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n        if (a >= a2) {\\n            a = (a * ONE_20) / a2;\\n            sum += x2;\\n        }\\n\\n        if (a >= a3) {\\n            a = (a * ONE_20) / a3;\\n            sum += x3;\\n        }\\n\\n        if (a >= a4) {\\n            a = (a * ONE_20) / a4;\\n            sum += x4;\\n        }\\n\\n        if (a >= a5) {\\n            a = (a * ONE_20) / a5;\\n            sum += x5;\\n        }\\n\\n        if (a >= a6) {\\n            a = (a * ONE_20) / a6;\\n            sum += x6;\\n        }\\n\\n        if (a >= a7) {\\n            a = (a * ONE_20) / a7;\\n            sum += x7;\\n        }\\n\\n        if (a >= a8) {\\n            a = (a * ONE_20) / a8;\\n            sum += x8;\\n        }\\n\\n        if (a >= a9) {\\n            a = (a * ONE_20) / a9;\\n            sum += x9;\\n        }\\n\\n        if (a >= a10) {\\n            a = (a * ONE_20) / a10;\\n            sum += x10;\\n        }\\n\\n        if (a >= a11) {\\n            a = (a * ONE_20) / a11;\\n            sum += x11;\\n        }\\n\\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n        // Let z = (a - 1) / (a + 1).\\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n        // division by ONE_20.\\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n        int256 z_squared = (z * z) / ONE_20;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 11;\\n\\n        // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n        seriesSum *= 2;\\n\\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n        // value.\\n\\n        return (sum + seriesSum) / 100;\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n        // worthwhile.\\n\\n        // First, we transform x to a 36 digit fixed point value.\\n        x *= ONE_18;\\n\\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n        // division by ONE_36.\\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n        int256 z_squared = (z * z) / ONE_36;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 11;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 13;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 15;\\n\\n        // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // All that remains is multiplying by 2 (non fixed point).\\n        return seriesSum * 2;\\n    }\\n}\\n\",\"keccak256\":\"0x3649ab52cd8c59ca022f2798cb7d276b68da284553421323258230becfc7e659\",\"license\":\"MIT\"},\"contracts/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\\n * Adapted from OpenZeppelin's SafeMath library\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers of 256 bits.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers of 256 bits.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        _require(a == 0 || c / a == b, Errors.MUL_OVERFLOW);\\n        return c;\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        bool roundUp\\n    ) internal pure returns (uint256) {\\n        return roundUp ? divUp(a, b) : divDown(a, b);\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n        return a / b;\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            return 1 + (a - 1) / b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x197a9106dedcccfb77dcf5979f7bdd2735dbe4106155ff34b1c2271c9aa5c668\",\"license\":\"MIT\"},\"contracts/StablePool/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nlibrary Buffer {\\n    // The buffer is a circular storage structure with 1024 slots.\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    uint256 internal constant SIZE = 1024;\\n\\n    /**\\n     * @dev Returns the index of the element before the one pointed by `index`.\\n     */\\n    function prev(uint256 index) internal pure returns (uint256) {\\n        return sub(index, 1);\\n    }\\n\\n    /**\\n     * @dev Returns the index of the element after the one pointed by `index`.\\n     */\\n    function next(uint256 index) internal pure returns (uint256) {\\n        return add(index, 1);\\n    }\\n\\n    /**\\n     * @dev Returns the index of an element `offset` slots after the one pointed by `index`.\\n     */\\n    function add(uint256 index, uint256 offset) internal pure returns (uint256) {\\n        return (index + offset) % SIZE;\\n    }\\n\\n    /**\\n     * @dev Returns the index of an element `offset` slots before the one pointed by `index`.\\n     */\\n    function sub(uint256 index, uint256 offset) internal pure returns (uint256) {\\n        return (index + SIZE - offset) % SIZE;\\n    }\\n}\\n\",\"keccak256\":\"0x272437be650c98f504e9f06c5539c728fe7c0081931cc8795bcfedcf56762f25\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/IPoolPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IPoolPriceOracle {\\n    /**\\n     * @dev Returns the raw data of the sample at `index`.\\n     */\\n    function getSample(uint256 index)\\n        external\\n        view\\n        returns (\\n            int256 logPairPrice,\\n            int256 accLogPairPrice,\\n            int256 logBptPrice,\\n            int256 accLogBptPrice,\\n            int256 logInvariant,\\n            int256 accLogInvariant,\\n            uint256 timestamp\\n        );\\n\\n    /**\\n     * @dev Returns the total number of samples.\\n     */\\n    function getTotalSamples() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xe62a9f142a46914331f14f84ca557297735898e7da2228a0af5488a45db3593c\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Interface for querying historical data from a Pool that can be used as a Price Oracle.\\n *\\n * This lets third parties retrieve average prices of tokens held by a Pool over a given period of time, as well as the\\n * price of the Pool share token (BPT) and invariant. Since the invariant is a sensible measure of Pool liquidity, it\\n * can be used to compare two different price sources, and choose the most liquid one.\\n *\\n * Once the oracle is fully initialized, all queries are guaranteed to succeed as long as they require no data that\\n * is not older than the largest safe query window.\\n */\\ninterface IPriceOracle {\\n    // The three values that can be queried:\\n    //\\n    // - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\\n    //   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\\n    //   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\\n    //   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\\n    //\\n    // - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\\n    //   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\\n    //   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\\n    //\\n    // - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\\n    enum Variable { PAIR_PRICE, BPT_PRICE, INVARIANT }\\n\\n    /**\\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\\n     * decimal fixed point values.\\n     */\\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\\n        external\\n        view\\n        returns (uint256[] memory results);\\n\\n    /**\\n     * @dev Returns latest sample of `variable`. Prices are represented as 18 decimal fixed point values.\\n     */\\n    function getLatest(Variable variable) external view returns (uint256);\\n\\n    /**\\n     * @dev Information for a Time Weighted Average query.\\n     *\\n     * Each query computes the average over a window of duration `secs` seconds that ended `ago` seconds ago. For\\n     * example, the average over the past 30 minutes is computed by settings secs to 1800 and ago to 0. If secs is 1800\\n     * and ago is 1800 as well, the average between 60 and 30 minutes ago is computed instead.\\n     */\\n    struct OracleAverageQuery {\\n        Variable variable;\\n        uint256 secs;\\n        uint256 ago;\\n    }\\n\\n    /**\\n     * @dev Returns largest time window that can be safely queried, where 'safely' means the Oracle is guaranteed to be\\n     * able to produce a result and not revert.\\n     *\\n     * If a query has a non-zero `ago` value, then `secs + ago` (the oldest point in time) must be smaller than this\\n     * value for 'safe' queries.\\n     */\\n    function getLargestSafeQueryWindow() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the accumulators corresponding to each of `queries`.\\n     */\\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\\n        external\\n        view\\n        returns (int256[] memory results);\\n\\n    /**\\n     * @dev Information for an Accumulator query.\\n     *\\n     * Each query estimates the accumulator at a time `ago` seconds ago.\\n     */\\n    struct OracleAccumulatorQuery {\\n        Variable variable;\\n        uint256 ago;\\n    }\\n}\\n\",\"keccak256\":\"0x54025df019033dae6f6c224ca4de8ffd83ee3e0df163781ac09faf7ef1f88e3b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/IRateProvider.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IRateProvider {\\n    function getRate() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x12b72d4097b6de68069ae2e24993476764536fbcb3d6b9a6932cd815dacd75bf\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/OracleMiscData.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./WordCodec.sol\\\";\\n\\n/**\\n * @dev This module provides an interface to store different pieces of information used by pools with a price oracle.\\n *\\n * These pieces of information are all kept together in a single storage slot to reduce the number of storage reads. In\\n * particular, it stores reduced-precision versions of the total BPT supply and invariant, which lets us not access\\n * nor compute these values when producing oracle updates during a swap.\\n *\\n * Data is stored with the following structure:\\n *\\n * [### not used ### | oracle enabled | oracle index | oracle sample initial timestamp | log supply | log invariant ]\\n * [     uint170     |      bool      |    uint10    |              uint31             |    int22   |     int22     ]\\n *\\n * Note that we are not using the most-significant 170 bits.\\n */\\nlibrary OracleMiscData {\\n    using WordCodec for bytes32;\\n    using WordCodec for uint256;\\n\\n    uint256 private constant _LOG_INVARIANT_OFFSET = 0;\\n    uint256 private constant _LOG_TOTAL_SUPPLY_OFFSET = 22;\\n    uint256 private constant _ORACLE_SAMPLE_CREATION_TIMESTAMP_OFFSET = 44;\\n    uint256 private constant _ORACLE_INDEX_OFFSET = 75;\\n    uint256 private constant _ORACLE_ENABLED_OFFSET = 85;\\n\\n    /**\\n     * @dev Returns the cached logarithm of the invariant.\\n     */\\n    function logInvariant(bytes32 data) internal pure returns (int256) {\\n        return data.decodeInt22(_LOG_INVARIANT_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns the cached logarithm of the total supply.\\n     */\\n    function logTotalSupply(bytes32 data) internal pure returns (int256) {\\n        return data.decodeInt22(_LOG_TOTAL_SUPPLY_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns the timestamp of the creation of the oracle's latest sample.\\n     */\\n    function oracleSampleCreationTimestamp(bytes32 data) internal pure returns (uint256) {\\n        return data.decodeUint31(_ORACLE_SAMPLE_CREATION_TIMESTAMP_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns the index of the oracle's latest sample.\\n     */\\n    function oracleIndex(bytes32 data) internal pure returns (uint256) {\\n        return data.decodeUint10(_ORACLE_INDEX_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns true if the oracle is enabled.\\n     */\\n    function oracleEnabled(bytes32 data) internal pure returns (bool) {\\n        return data.decodeBool(_ORACLE_ENABLED_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Sets the logarithm of the invariant in `data`, returning the updated value.\\n     */\\n    function setLogInvariant(bytes32 data, int256 _logInvariant) internal pure returns (bytes32) {\\n        return data.insertInt22(_logInvariant, _LOG_INVARIANT_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Sets the logarithm of the total supply in `data`, returning the updated value.\\n     */\\n    function setLogTotalSupply(bytes32 data, int256 _logTotalSupply) internal pure returns (bytes32) {\\n        return data.insertInt22(_logTotalSupply, _LOG_TOTAL_SUPPLY_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Sets the timestamp of the creation of the oracle's latest sample in `data`, returning the updated value.\\n     */\\n    function setOracleSampleCreationTimestamp(bytes32 data, uint256 _initialTimestamp) internal pure returns (bytes32) {\\n        return data.insertUint31(_initialTimestamp, _ORACLE_SAMPLE_CREATION_TIMESTAMP_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Sets the index of the  oracle's latest sample in `data`, returning the updated value.\\n     */\\n    function setOracleIndex(bytes32 data, uint256 _oracleIndex) internal pure returns (bytes32) {\\n        return data.insertUint10(_oracleIndex, _ORACLE_INDEX_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Enables or disables the oracle in `data`, returning the updated value.\\n     */\\n    function setOracleEnabled(bytes32 data, bool _oracleEnabled) internal pure returns (bytes32) {\\n        return data.insertBool(_oracleEnabled, _ORACLE_ENABLED_OFFSET);\\n    }\\n}\\n\",\"keccak256\":\"0xa0b4a7695c89ce8fcd7eb61c85b1641fb8f85514e145ed2714a2b38ea7492115\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/PoolPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\n\\nimport \\\"./IPriceOracle.sol\\\";\\nimport \\\"./IPoolPriceOracle.sol\\\";\\n\\nimport \\\"./Buffer.sol\\\";\\nimport \\\"./Samples.sol\\\";\\nimport \\\"./QueryProcessor.sol\\\";\\n\\n/**\\n * @dev This module allows Pools to access historical pricing information.\\n *\\n * It uses a 1024 long circular buffer to store past data, where the data within each sample is the result of\\n * accumulating live data for no more than two minutes. Therefore, assuming the worst case scenario where new data is\\n * updated in every single block, the oldest samples in the buffer (and therefore largest queryable period) will\\n * be slightly over 34 hours old.\\n *\\n * Usage of this module requires the caller to keep track of two variables: the latest circular buffer index, and the\\n * timestamp when the index last changed. Aditionally, access to the latest circular buffer index must be exposed by\\n * implementing `_getOracleIndex`.\\n *\\n * This contract relies on the `QueryProcessor` linked library to reduce bytecode size.\\n */\\nabstract contract PoolPriceOracle is IPoolPriceOracle, IPriceOracle {\\n    using Buffer for uint256;\\n    using Samples for bytes32;\\n\\n    // Each sample in the buffer accumulates information for up to 2 minutes. This is simply to reduce the size of the\\n    // buffer: small time deviations will not have any significant effect.\\n    // solhint-disable not-rely-on-time\\n    uint256 private constant _MAX_SAMPLE_DURATION = 2 minutes;\\n\\n    // We use a mapping to simulate an array: the buffer won't grow or shrink, and since we will always use valid\\n    // indexes using a mapping saves gas by skipping the bounds checks.\\n    mapping(uint256 => bytes32) internal _samples;\\n\\n    // IPoolPriceOracle\\n\\n    function getSample(uint256 index)\\n        external\\n        view\\n        override\\n        returns (\\n            int256 logPairPrice,\\n            int256 accLogPairPrice,\\n            int256 logBptPrice,\\n            int256 accLogBptPrice,\\n            int256 logInvariant,\\n            int256 accLogInvariant,\\n            uint256 timestamp\\n        )\\n    {\\n        _require(index < Buffer.SIZE, Errors.ORACLE_INVALID_INDEX);\\n\\n        bytes32 sample = _getSample(index);\\n        return sample.unpack();\\n    }\\n\\n    function getTotalSamples() external pure override returns (uint256) {\\n        return Buffer.SIZE;\\n    }\\n\\n    /**\\n     * @dev Manually dirty oracle sample storage slots with dummy data, to reduce the gas cost of the future swaps\\n     * that will initialize them. This function is only useful before the oracle has been fully initialized.\\n     *\\n     * `endIndex` is non-inclusive.\\n     */\\n    function dirtyUninitializedOracleSamples(uint256 startIndex, uint256 endIndex) external {\\n        _require(startIndex < endIndex && endIndex <= Buffer.SIZE, Errors.OUT_OF_BOUNDS);\\n\\n        // Uninitialized samples are identified by a zero timestamp -- all other fields are ignored,\\n        // so any non-zero value with a zero timestamp suffices.\\n        bytes32 initSample = Samples.pack(1, 0, 0, 0, 0, 0, 0);\\n        for (uint256 i = startIndex; i < endIndex; i++) {\\n            if (_samples[i].timestamp() == 0) {\\n                _samples[i] = initSample;\\n            }\\n        }\\n    }\\n\\n    // IPriceOracle\\n\\n    function getLargestSafeQueryWindow() external pure override returns (uint256) {\\n        return 34 hours;\\n    }\\n\\n    function getLatest(Variable variable) external view override returns (uint256) {\\n        return QueryProcessor.getInstantValue(_samples, variable, _getOracleIndex());\\n    }\\n\\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory results)\\n    {\\n        results = new uint256[](queries.length);\\n        uint256 latestIndex = _getOracleIndex();\\n\\n        for (uint256 i = 0; i < queries.length; ++i) {\\n            results[i] = QueryProcessor.getTimeWeightedAverage(_samples, queries[i], latestIndex);\\n        }\\n    }\\n\\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\\n        external\\n        view\\n        override\\n        returns (int256[] memory results)\\n    {\\n        results = new int256[](queries.length);\\n        uint256 latestIndex = _getOracleIndex();\\n\\n        OracleAccumulatorQuery memory query;\\n        for (uint256 i = 0; i < queries.length; ++i) {\\n            query = queries[i];\\n            results[i] = _getPastAccumulator(query.variable, latestIndex, query.ago);\\n        }\\n    }\\n\\n    // Internal functions\\n\\n    /**\\n     * @dev Processes new price and invariant data, updating the latest sample or creating a new one.\\n     *\\n     * Receives the new logarithms of values to store: `logPairPrice`, `logBptPrice` and `logInvariant`, as well the\\n     * index of the latest sample and the timestamp of its creation.\\n     *\\n     * Returns the index of the latest sample. If different from `latestIndex`, the caller should also store the\\n     * timestamp, and pass it on future calls to this function.\\n     */\\n    function _processPriceData(\\n        uint256 latestSampleCreationTimestamp,\\n        uint256 latestIndex,\\n        int256 logPairPrice,\\n        int256 logBptPrice,\\n        int256 logInvariant\\n    ) internal returns (uint256) {\\n        // Read latest sample, and compute the next one by updating it with the newly received data.\\n        bytes32 sample = _getSample(latestIndex).update(logPairPrice, logBptPrice, logInvariant, block.timestamp);\\n\\n        // We create a new sample if more than _MAX_SAMPLE_DURATION seconds have elapsed since the creation of the\\n        // latest one. In other words, no sample accumulates data over a period larger than _MAX_SAMPLE_DURATION.\\n        bool newSample = block.timestamp - latestSampleCreationTimestamp >= _MAX_SAMPLE_DURATION;\\n        latestIndex = newSample ? latestIndex.next() : latestIndex;\\n\\n        // Store the updated or new sample.\\n        _samples[latestIndex] = sample;\\n\\n        return latestIndex;\\n    }\\n\\n    function _getPastAccumulator(\\n        IPriceOracle.Variable variable,\\n        uint256 latestIndex,\\n        uint256 ago\\n    ) internal view returns (int256) {\\n        return QueryProcessor.getPastAccumulator(_samples, variable, latestIndex, ago);\\n    }\\n\\n    function _findNearestSample(\\n        uint256 lookUpDate,\\n        uint256 offset,\\n        uint256 length\\n    ) internal view returns (bytes32 prev, bytes32 next) {\\n        return QueryProcessor.findNearestSample(_samples, lookUpDate, offset, length);\\n    }\\n\\n    /**\\n     * @dev Returns the sample that corresponds to a given `index`.\\n     *\\n     * Using this function instead of accessing storage directly results in denser bytecode (since the storage slot is\\n     * only computed here).\\n     */\\n    function _getSample(uint256 index) internal view returns (bytes32) {\\n        return _samples[index];\\n    }\\n\\n    /**\\n     * @dev Virtual function to be implemented by derived contracts. Must return the current index of the oracle\\n     * circular buffer.\\n     */\\n    function _getOracleIndex() internal view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0xfff0c7d7688a27cf9c07a25056349b7fcc2120626160694cf49503b57d29e923\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/QueryProcessor.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../LogCompression.sol\\\";\\n\\nimport \\\"./IPriceOracle.sol\\\";\\n\\nimport \\\"./Buffer.sol\\\";\\nimport \\\"./Samples.sol\\\";\\n\\n/**\\n * @dev Auxiliary library for PoolPriceOracle, offloading most of the query code to reduce bytecode size by using this\\n * as a linked library. The downside is an extra DELEGATECALL is added (2600 gas as of the Berlin hardfork), but the\\n * bytecode size gains are so big (specially of the oracle contract does not use `LogCompression.fromLowResLog`) that\\n * it is worth it.\\n */\\nlibrary QueryProcessor {\\n    using Buffer for uint256;\\n    using Samples for bytes32;\\n    using LogCompression for int256;\\n\\n    /**\\n     * @dev Returns the value for `variable` at the indexed sample.\\n     */\\n    function getInstantValue(\\n        mapping(uint256 => bytes32) storage samples,\\n        IPriceOracle.Variable variable,\\n        uint256 index\\n    ) external view returns (uint256) {\\n        bytes32 sample = samples[index];\\n        _require(sample.timestamp() > 0, Errors.ORACLE_NOT_INITIALIZED);\\n\\n        int256 rawInstantValue = sample.instant(variable);\\n        return LogCompression.fromLowResLog(rawInstantValue);\\n    }\\n\\n    /**\\n     * @dev Returns the time average weighted price corresponding to `query`.\\n     */\\n    function getTimeWeightedAverage(\\n        mapping(uint256 => bytes32) storage samples,\\n        IPriceOracle.OracleAverageQuery memory query,\\n        uint256 latestIndex\\n    ) external view returns (uint256) {\\n        _require(query.secs != 0, Errors.ORACLE_BAD_SECS);\\n\\n        int256 beginAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago + query.secs);\\n        int256 endAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago);\\n        return LogCompression.fromLowResLog((endAccumulator - beginAccumulator) / int256(query.secs));\\n    }\\n\\n    /**\\n     * @dev Returns the value of the accumulator for `variable` `ago` seconds ago. `latestIndex` must be the index of\\n     * the latest sample in the buffer.\\n     *\\n     * Reverts under the following conditions:\\n     *  - if the buffer is empty.\\n     *  - if querying past information and the buffer has not been fully initialized.\\n     *  - if querying older information than available in the buffer. Note that a full buffer guarantees queries for the\\n     *    past 34 hours will not revert.\\n     *\\n     * If requesting information for a timestamp later than the latest one, it is extrapolated using the latest\\n     * available data.\\n     *\\n     * When no exact information is available for the requested past timestamp (as usually happens, since at most one\\n     * timestamp is stored every two minutes), it is estimated by performing linear interpolation using the closest\\n     * values. This process is guaranteed to complete performing at most 10 storage reads.\\n     */\\n    function getPastAccumulator(\\n        mapping(uint256 => bytes32) storage samples,\\n        IPriceOracle.Variable variable,\\n        uint256 latestIndex,\\n        uint256 ago\\n    ) public view returns (int256) {\\n        // solhint-disable not-rely-on-time\\n        // `ago` must not be before the epoch.\\n        _require(block.timestamp >= ago, Errors.ORACLE_INVALID_SECONDS_QUERY);\\n        uint256 lookUpTime = block.timestamp - ago;\\n\\n        bytes32 latestSample = samples[latestIndex];\\n        uint256 latestTimestamp = latestSample.timestamp();\\n\\n        // The latest sample only has a non-zero timestamp if no data was ever processed and stored in the buffer.\\n        _require(latestTimestamp > 0, Errors.ORACLE_NOT_INITIALIZED);\\n\\n        if (latestTimestamp <= lookUpTime) {\\n            // The accumulator at times ahead of the latest one are computed by extrapolating the latest data. This is\\n            // equivalent to the instant value not changing between the last timestamp and the look up time.\\n\\n            // We can use unchecked arithmetic since the accumulator can be represented in 53 bits, timestamps in 31\\n            // bits, and the instant value in 22 bits.\\n            uint256 elapsed = lookUpTime - latestTimestamp;\\n            return latestSample.accumulator(variable) + (latestSample.instant(variable) * int256(elapsed));\\n        } else {\\n            // The look up time is before the latest sample, but we need to make sure that it is not before the oldest\\n            // sample as well.\\n\\n            // Since we use a circular buffer, the oldest sample is simply the next one.\\n            uint256 bufferLength;\\n            uint256 oldestIndex = latestIndex.next();\\n            {\\n                // Local scope used to prevent stack-too-deep errors.\\n                bytes32 oldestSample = samples[oldestIndex];\\n                uint256 oldestTimestamp = oldestSample.timestamp();\\n\\n                if (oldestTimestamp > 0) {\\n                    // If the oldest timestamp is not zero, it means the buffer was fully initialized.\\n                    bufferLength = Buffer.SIZE;\\n                } else {\\n                    // If the buffer was not fully initialized, we haven't wrapped around it yet,\\n                    // and can treat it as a regular array where the oldest index is the first one,\\n                    // and the length the number of samples.\\n                    bufferLength = oldestIndex; // Equal to latestIndex.next()\\n                    oldestIndex = 0;\\n                    oldestTimestamp = samples[0].timestamp();\\n                }\\n\\n                // Finally check that the look up time is not previous to the oldest timestamp.\\n                _require(oldestTimestamp <= lookUpTime, Errors.ORACLE_QUERY_TOO_OLD);\\n            }\\n\\n            // Perform binary search to find nearest samples to the desired timestamp.\\n            (bytes32 prev, bytes32 next) = findNearestSample(samples, lookUpTime, oldestIndex, bufferLength);\\n\\n            // `next`'s timestamp is guaranteed to be larger than `prev`'s, so we can skip checked arithmetic.\\n            uint256 samplesTimeDiff = next.timestamp() - prev.timestamp();\\n\\n            if (samplesTimeDiff > 0) {\\n                // We estimate the accumulator at the requested look up time by interpolating linearly between the\\n                // previous and next accumulators.\\n\\n                // We can use unchecked arithmetic since the accumulators can be represented in 53 bits, and timestamps\\n                // in 31 bits.\\n                int256 samplesAccDiff = next.accumulator(variable) - prev.accumulator(variable);\\n                uint256 elapsed = lookUpTime - prev.timestamp();\\n                return prev.accumulator(variable) + ((samplesAccDiff * int256(elapsed)) / int256(samplesTimeDiff));\\n            } else {\\n                // Rarely, one of the samples will have the exact requested look up time, which is indicated by `prev`\\n                // and `next` being the same. In this case, we simply return the accumulator at that point in time.\\n                return prev.accumulator(variable);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Finds the two samples with timestamps before and after `lookUpDate`. If one of the samples matches exactly,\\n     * both `prev` and `next` will be it. `offset` is the index of the oldest sample in the buffer. `length` is the size\\n     * of the samples list.\\n     *\\n     * Assumes `lookUpDate` is greater or equal than the timestamp of the oldest sample, and less or equal than the\\n     * timestamp of the latest sample.\\n     */\\n    function findNearestSample(\\n        mapping(uint256 => bytes32) storage samples,\\n        uint256 lookUpDate,\\n        uint256 offset,\\n        uint256 length\\n    ) public view returns (bytes32 prev, bytes32 next) {\\n        // We're going to perform a binary search in the circular buffer, which requires it to be sorted. To achieve\\n        // this, we offset all buffer accesses by `offset`, making the first element the oldest one.\\n\\n        // Auxiliary variables in a typical binary search: we will look at some value `mid` between `low` and `high`,\\n        // periodically increasing `low` or decreasing `high` until we either find a match or determine the element is\\n        // not in the array.\\n        uint256 low = 0;\\n        uint256 high = length - 1;\\n        uint256 mid;\\n\\n        // If the search fails and no sample has a timestamp of `lookUpDate` (as is the most common scenario), `sample`\\n        // will be either the sample with the largest timestamp smaller than `lookUpDate`, or the one with the smallest\\n        // timestamp larger than `lookUpDate`.\\n        bytes32 sample;\\n        uint256 sampleTimestamp;\\n\\n        while (low <= high) {\\n            // Mid is the floor of the average.\\n            uint256 midWithoutOffset = (high + low) / 2;\\n\\n            // Recall that the buffer is not actually sorted: we need to apply the offset to access it in a sorted way.\\n            mid = midWithoutOffset.add(offset);\\n            sample = samples[mid];\\n            sampleTimestamp = sample.timestamp();\\n\\n            if (sampleTimestamp < lookUpDate) {\\n                // If the mid sample is bellow the look up date, then increase the low index to start from there.\\n                low = midWithoutOffset + 1;\\n            } else if (sampleTimestamp > lookUpDate) {\\n                // If the mid sample is above the look up date, then decrease the high index to start from there.\\n\\n                // We can skip checked arithmetic: it is impossible for `high` to ever be 0, as a scenario where `low`\\n                // equals 0 and `high` equals 1 would result in `low` increasing to 1 in the previous `if` clause.\\n                high = midWithoutOffset - 1;\\n            } else {\\n                // sampleTimestamp == lookUpDate\\n                // If we have an exact match, return the sample as both `prev` and `next`.\\n                return (sample, sample);\\n            }\\n        }\\n\\n        // In case we reach here, it means we didn't find exactly the sample we where looking for.\\n        return sampleTimestamp < lookUpDate ? (sample, samples[mid.next()]) : (samples[mid.prev()], sample);\\n    }\\n}\\n\",\"keccak256\":\"0x735f38d7f8b92c9cfa1cd17beb68f3cc0dd0286b7a2e2cf6cd1e96f7252f7a88\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/Samples.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./WordCodec.sol\\\";\\n\\nimport \\\"./IPriceOracle.sol\\\";\\n\\n/**\\n * @dev This library provides functions to help manipulating samples for Pool Price Oracles. It handles updates,\\n * encoding, and decoding of samples.\\n *\\n * Each sample holds the timestamp of its last update, plus information about three pieces of data: the price pair, the\\n * price of BPT (the associated Pool token), and the invariant.\\n *\\n * Prices and invariant are not stored directly: instead, we store their logarithm. These are known as the 'instant'\\n * values: the exact value at that timestamp.\\n *\\n * Additionally, for each value we keep an accumulator with the sum of all past values, each weighted by the time\\n * elapsed since the previous update. This lets us later subtract accumulators at different points in time and divide by\\n * the time elapsed between them, arriving at the geometric mean of the values (also known as log-average).\\n *\\n * All samples are stored in a single 256 bit word with the following structure:\\n *\\n * [    log pair price     |        bpt price      |       invariant       |  timestamp ]\\n * [ instant | accumulator | instant | accumulator | instant | accumulator |            ]\\n * [  int22  |    int53    |  int22  |    int53    |  int22  |    int53    |    uint31  ]\\n * MSB                                                                                LSB\\n *\\n * Assuming the timestamp doesn't overflow (which holds until the year 2038), the largest elapsed time is 2^31, which\\n * means the largest possible accumulator value is 2^21 * 2^31, which can be represented using a signed 53 bit integer.\\n */\\nlibrary Samples {\\n    using WordCodec for int256;\\n    using WordCodec for uint256;\\n    using WordCodec for bytes32;\\n\\n    uint256 internal constant _TIMESTAMP_OFFSET = 0;\\n    uint256 internal constant _ACC_LOG_INVARIANT_OFFSET = 31;\\n    uint256 internal constant _INST_LOG_INVARIANT_OFFSET = 84;\\n    uint256 internal constant _ACC_LOG_BPT_PRICE_OFFSET = 106;\\n    uint256 internal constant _INST_LOG_BPT_PRICE_OFFSET = 159;\\n    uint256 internal constant _ACC_LOG_PAIR_PRICE_OFFSET = 181;\\n    uint256 internal constant _INST_LOG_PAIR_PRICE_OFFSET = 234;\\n\\n    /**\\n     * @dev Updates a sample, accumulating the new data based on the elapsed time since the previous update. Returns the\\n     * updated sample.\\n     *\\n     * IMPORTANT: This function does not perform any arithmetic checks. In particular, it assumes the caller will never\\n     * pass values that cannot be represented as 22 bit signed integers. Additionally, it also assumes\\n     * `currentTimestamp` is greater than `sample`'s timestamp.\\n     */\\n    function update(\\n        bytes32 sample,\\n        int256 instLogPairPrice,\\n        int256 instLogBptPrice,\\n        int256 instLogInvariant,\\n        uint256 currentTimestamp\\n    ) internal pure returns (bytes32) {\\n        // Because elapsed can be represented as a 31 bit unsigned integer, and the received values can be represented\\n        // as 22 bit signed integers, we don't need to perform checked arithmetic.\\n\\n        int256 elapsed = int256(currentTimestamp - timestamp(sample));\\n        int256 accLogPairPrice = _accLogPairPrice(sample) + instLogPairPrice * elapsed;\\n        int256 accLogBptPrice = _accLogBptPrice(sample) + instLogBptPrice * elapsed;\\n        int256 accLogInvariant = _accLogInvariant(sample) + instLogInvariant * elapsed;\\n\\n        return\\n            pack(\\n                instLogPairPrice,\\n                accLogPairPrice,\\n                instLogBptPrice,\\n                accLogBptPrice,\\n                instLogInvariant,\\n                accLogInvariant,\\n                currentTimestamp\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns the instant value stored in `sample` for `variable`.\\n     */\\n    function instant(bytes32 sample, IPriceOracle.Variable variable) internal pure returns (int256) {\\n        if (variable == IPriceOracle.Variable.PAIR_PRICE) {\\n            return _instLogPairPrice(sample);\\n        } else if (variable == IPriceOracle.Variable.BPT_PRICE) {\\n            return _instLogBptPrice(sample);\\n        } else {\\n            // variable == IPriceOracle.Variable.INVARIANT\\n            return _instLogInvariant(sample);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the accumulator value stored in `sample` for `variable`.\\n     */\\n    function accumulator(bytes32 sample, IPriceOracle.Variable variable) internal pure returns (int256) {\\n        if (variable == IPriceOracle.Variable.PAIR_PRICE) {\\n            return _accLogPairPrice(sample);\\n        } else if (variable == IPriceOracle.Variable.BPT_PRICE) {\\n            return _accLogBptPrice(sample);\\n        } else {\\n            // variable == IPriceOracle.Variable.INVARIANT\\n            return _accLogInvariant(sample);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns `sample`'s timestamp.\\n     */\\n    function timestamp(bytes32 sample) internal pure returns (uint256) {\\n        return sample.decodeUint31(_TIMESTAMP_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns `sample`'s instant value for the logarithm of the pair price.\\n     */\\n    function _instLogPairPrice(bytes32 sample) private pure returns (int256) {\\n        return sample.decodeInt22(_INST_LOG_PAIR_PRICE_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns `sample`'s accumulator of the logarithm of the pair price.\\n     */\\n    function _accLogPairPrice(bytes32 sample) private pure returns (int256) {\\n        return sample.decodeInt53(_ACC_LOG_PAIR_PRICE_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns `sample`'s instant value for the logarithm of the BPT price.\\n     */\\n    function _instLogBptPrice(bytes32 sample) private pure returns (int256) {\\n        return sample.decodeInt22(_INST_LOG_BPT_PRICE_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns `sample`'s accumulator of the logarithm of the BPT price.\\n     */\\n    function _accLogBptPrice(bytes32 sample) private pure returns (int256) {\\n        return sample.decodeInt53(_ACC_LOG_BPT_PRICE_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns `sample`'s instant value for the logarithm of the invariant.\\n     */\\n    function _instLogInvariant(bytes32 sample) private pure returns (int256) {\\n        return sample.decodeInt22(_INST_LOG_INVARIANT_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns `sample`'s accumulator of the logarithm of the invariant.\\n     */\\n    function _accLogInvariant(bytes32 sample) private pure returns (int256) {\\n        return sample.decodeInt53(_ACC_LOG_INVARIANT_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns a sample created by packing together its components.\\n     */\\n    function pack(\\n        int256 instLogPairPrice,\\n        int256 accLogPairPrice,\\n        int256 instLogBptPrice,\\n        int256 accLogBptPrice,\\n        int256 instLogInvariant,\\n        int256 accLogInvariant,\\n        uint256 _timestamp\\n    ) internal pure returns (bytes32) {\\n        return\\n            instLogPairPrice.encodeInt22(_INST_LOG_PAIR_PRICE_OFFSET) |\\n            accLogPairPrice.encodeInt53(_ACC_LOG_PAIR_PRICE_OFFSET) |\\n            instLogBptPrice.encodeInt22(_INST_LOG_BPT_PRICE_OFFSET) |\\n            accLogBptPrice.encodeInt53(_ACC_LOG_BPT_PRICE_OFFSET) |\\n            instLogInvariant.encodeInt22(_INST_LOG_INVARIANT_OFFSET) |\\n            accLogInvariant.encodeInt53(_ACC_LOG_INVARIANT_OFFSET) |\\n            _timestamp.encodeUint(_TIMESTAMP_OFFSET); // Using 31 bits\\n    }\\n\\n    /**\\n     * @dev Unpacks a sample into its components.\\n     */\\n    function unpack(bytes32 sample)\\n        internal\\n        pure\\n        returns (\\n            int256 logPairPrice,\\n            int256 accLogPairPrice,\\n            int256 logBptPrice,\\n            int256 accLogBptPrice,\\n            int256 logInvariant,\\n            int256 accLogInvariant,\\n            uint256 _timestamp\\n        )\\n    {\\n        logPairPrice = _instLogPairPrice(sample);\\n        accLogPairPrice = _accLogPairPrice(sample);\\n        logBptPrice = _instLogBptPrice(sample);\\n        accLogBptPrice = _accLogBptPrice(sample);\\n        logInvariant = _instLogInvariant(sample);\\n        accLogInvariant = _accLogInvariant(sample);\\n        _timestamp = timestamp(sample);\\n    }\\n}\\n\",\"keccak256\":\"0x468db616a546758e5fa73ce2322068383eafb06e5bb84619de864c5e38681cfc\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/StableMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../Math.sol\\\";\\nimport \\\"../FixedPoint.sol\\\";\\n\\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\\n// should be fixed. Additionally, some variables have non mixed case names (e.g. P_D) that relate to the mathematical\\n// derivations.\\n// solhint-disable private-vars-leading-underscore, var-name-mixedcase\\n\\nlibrary StableMath {\\n    using FixedPoint for uint256;\\n\\n    uint256 internal constant _MIN_AMP = 1;\\n    uint256 internal constant _MAX_AMP = 5000;\\n    uint256 internal constant _AMP_PRECISION = 1e3;\\n\\n    uint256 internal constant _MAX_STABLE_TOKENS = 5;\\n\\n    // Note on unchecked arithmetic:\\n    // This contract performs a large number of additions, subtractions, multiplications and divisions, often inside\\n    // loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to\\n    // not make any unnecessary checks. We rely on a set of invariants to avoid having to use checked arithmetic (the\\n    // Math library), including:\\n    //  - the number of tokens is bounded by _MAX_STABLE_TOKENS\\n    //  - the amplification parameter is bounded by _MAX_AMP * _AMP_PRECISION, which fits in 23 bits\\n    //  - the token balances are bounded by 2^112 (guaranteed by the Vault) times 1e18 (the maximum scaling factor),\\n    //    which fits in 172 bits\\n    //\\n    // This means e.g. we can safely multiply a balance by the amplification parameter without worrying about overflow.\\n\\n    // About swap fees on joins and exits:\\n    // Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\\n    // equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\\n    // swap fees, it follows that (some) joins and exits should as well.\\n    // On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\\n    // is the one to which swap fees are applied.\\n\\n    // Computes the invariant given the current balances, using the Newton-Raphson approximation.\\n    // The amplification parameter equals: A n^(n-1)\\n    function _calculateInvariant(\\n        uint256 amplificationParameter,\\n        uint256[] memory balances,\\n        bool roundUp\\n    ) internal pure returns (uint256) {\\n        /**********************************************************************************************\\n        // invariant                                                                                 //\\n        // D = invariant                                                  D^(n+1)                    //\\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\\n        // S = sum of balances                                             n^n P                     //\\n        // P = product of balances                                                                   //\\n        // n = number of tokens                                                                      //\\n        **********************************************************************************************/\\n\\n        // We support rounding up or down.\\n        uint256 sum = 0;\\n        uint256 numTokens = balances.length;\\n        for (uint256 i = 0; i < numTokens; i++) {\\n            sum = sum.add(balances[i]);\\n        }\\n        if (sum == 0) {\\n            return 0;\\n        }\\n\\n        uint256 prevInvariant = 0;\\n        uint256 invariant = sum;\\n        uint256 ampTimesTotal = amplificationParameter * numTokens;\\n\\n//        for (uint256 i = 0; i < 255; i++) {\\n//            uint256 P_D = balances[0] * numTokens;\\n//            for (uint256 j = 1; j < numTokens; j++) {\\n//                P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\\n//            }\\n//            prevInvariant = invariant;\\n//            invariant = Math.div(\\n//                Math.mul(Math.mul(numTokens, invariant), invariant).add(\\n//                    Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\\n//                ),\\n//                Math.mul(numTokens + 1, invariant).add(\\n//                    // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\\n//                    Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\\n//                ),\\n//                roundUp\\n//            );\\n//\\n//            if (invariant > prevInvariant) {\\n//                if (invariant - prevInvariant <= 1) {\\n//                    return invariant;\\n//                }\\n//            } else if (prevInvariant - invariant <= 1) {\\n//                return invariant;\\n//            }\\n//        }\\n\\n        return invariant;\\n        _revert(Errors.STABLE_INVARIANT_DIDNT_CONVERGE);\\n    }\\n\\n    // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.\\n    // The amplification parameter equals: A n^(n-1)\\n    // The invariant should be rounded up.\\n    function _calcOutGivenIn(\\n        uint256 amplificationParameter,\\n        uint256[] memory balances,\\n        uint256 tokenIndexIn,\\n        uint256 tokenIndexOut,\\n        uint256 tokenAmountIn,\\n        uint256 invariant\\n    ) internal pure returns (uint256) {\\n        /**************************************************************************************************************\\n        // outGivenIn token x for y - polynomial equation to solve                                                   //\\n        // ay = amount out to calculate                                                                              //\\n        // by = balance token out                                                                                    //\\n        // y = by - ay (finalBalanceOut)                                                                             //\\n        // D = invariant                                               D                     D^(n+1)                 //\\n        // A = amplification coefficient               y^2 + ( S - ----------  - D) * y -  ------------- = 0         //\\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\\n        // S = sum of final balances but y                                                                           //\\n        // P = product of final balances but y                                                                       //\\n        **************************************************************************************************************/\\n\\n        // Amount out, so we round down overall.\\n        balances[tokenIndexIn] = balances[tokenIndexIn].add(tokenAmountIn);\\n\\n        uint256 finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\\n            amplificationParameter,\\n            balances,\\n            invariant,\\n            tokenIndexOut\\n        );\\n\\n        // No need to use checked arithmetic since `tokenAmountIn` was actually added to the same balance right before\\n        // calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\\n        balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;\\n\\n        return balances[tokenIndexOut].sub(finalBalanceOut).sub(1);\\n    }\\n\\n    // Computes how many tokens must be sent to a pool if `tokenAmountOut` are sent given the\\n    // current balances, using the Newton-Raphson approximation.\\n    // The amplification parameter equals: A n^(n-1)\\n    // The invariant should be rounded up.\\n    function _calcInGivenOut(\\n        uint256 amplificationParameter,\\n        uint256[] memory balances,\\n        uint256 tokenIndexIn,\\n        uint256 tokenIndexOut,\\n        uint256 tokenAmountOut,\\n        uint256 invariant\\n    ) internal pure returns (uint256) {\\n        /**************************************************************************************************************\\n        // inGivenOut token x for y - polynomial equation to solve                                                   //\\n        // ax = amount in to calculate                                                                               //\\n        // bx = balance token in                                                                                     //\\n        // x = bx + ax (finalBalanceIn)                                                                              //\\n        // D = invariant                                                D                     D^(n+1)                //\\n        // A = amplification coefficient               x^2 + ( S - ----------  - D) * x -  ------------- = 0         //\\n        // n = number of tokens                                     (A * n^n)               A * n^2n * P             //\\n        // S = sum of final balances but x                                                                           //\\n        // P = product of final balances but x                                                                       //\\n        **************************************************************************************************************/\\n\\n        // Amount in, so we round up overall.\\n        balances[tokenIndexOut] = balances[tokenIndexOut].sub(tokenAmountOut);\\n\\n        uint256 finalBalanceIn = _getTokenBalanceGivenInvariantAndAllOtherBalances(\\n            amplificationParameter,\\n            balances,\\n            invariant,\\n            tokenIndexIn\\n        );\\n\\n        // No need to use checked arithmetic since `tokenAmountOut` was actually subtracted from the same balance right\\n        // before calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\\n        balances[tokenIndexOut] = balances[tokenIndexOut] + tokenAmountOut;\\n\\n        return finalBalanceIn.sub(balances[tokenIndexIn]).add(1);\\n    }\\n\\n    function _calcBptOutGivenExactTokensIn(\\n        uint256 amp,\\n        uint256[] memory balances,\\n        uint256[] memory amountsIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256) {\\n        // BPT out, so we round down overall.\\n\\n        // First loop calculates the sum of all token balances, which will be used to calculate\\n        // the current weights of each token, relative to this sum\\n        uint256 sumBalances = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            sumBalances = sumBalances.add(balances[i]);\\n        }\\n\\n        // Calculate the weighted balance ratio without considering fees\\n        uint256[] memory balanceRatiosWithFee = new uint256[](amountsIn.length);\\n        // The weighted sum of token balance ratios with fee\\n        uint256 invariantRatioWithFees = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            uint256 currentWeight = balances[i].divDown(sumBalances);\\n            balanceRatiosWithFee[i] = balances[i].add(amountsIn[i]).divDown(balances[i]);\\n            invariantRatioWithFees = invariantRatioWithFees.add(balanceRatiosWithFee[i].mulDown(currentWeight));\\n        }\\n\\n        // Second loop calculates new amounts in, taking into account the fee on the percentage excess\\n        uint256[] memory newBalances = new uint256[](balances.length);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            uint256 amountInWithoutFee;\\n\\n            // Check if the balance ratio is greater than the ideal ratio to charge fees or not\\n            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees.sub(FixedPoint.ONE));\\n                uint256 taxableAmount = amountsIn[i].sub(nonTaxableAmount);\\n                // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\\n                amountInWithoutFee = nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\\n            } else {\\n                amountInWithoutFee = amountsIn[i];\\n            }\\n\\n            newBalances[i] = balances[i].add(amountInWithoutFee);\\n        }\\n\\n        // Get current and new invariants, taking swap fees into account\\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\\n        uint256 newInvariant = _calculateInvariant(amp, newBalances, false);\\n        uint256 invariantRatio = newInvariant.divDown(currentInvariant);\\n\\n        // If the invariant didn't increase for any reason, we simply don't mint BPT\\n        if (invariantRatio > FixedPoint.ONE) {\\n            return bptTotalSupply.mulDown(invariantRatio - FixedPoint.ONE);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _calcTokenInGivenExactBptOut(\\n        uint256 amp,\\n        uint256[] memory balances,\\n        uint256 tokenIndex,\\n        uint256 bptAmountOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256) {\\n        // Token in, so we round up overall.\\n\\n        // Get the current invariant\\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\\n\\n        // Calculate new invariant\\n        uint256 newInvariant = bptTotalSupply.add(bptAmountOut).divUp(bptTotalSupply).mulUp(currentInvariant);\\n\\n        // Calculate amount in without fee.\\n        uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\\n            amp,\\n            balances,\\n            newInvariant,\\n            tokenIndex\\n        );\\n        uint256 amountInWithoutFee = newBalanceTokenIndex.sub(balances[tokenIndex]);\\n\\n        // First calculate the sum of all token balances, which will be used to calculate\\n        // the current weight of each token\\n        uint256 sumBalances = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            sumBalances = sumBalances.add(balances[i]);\\n        }\\n\\n        // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\\n        // accordingly.\\n        uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\\n        uint256 taxablePercentage = currentWeight.complement();\\n        uint256 taxableAmount = amountInWithoutFee.mulUp(taxablePercentage);\\n        uint256 nonTaxableAmount = amountInWithoutFee.sub(taxableAmount);\\n\\n        // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\\n        return nonTaxableAmount.add(taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage));\\n    }\\n\\n    /*\\n    Flow of calculations:\\n    amountsTokenOut -> amountsOutProportional ->\\n    amountOutPercentageExcess -> amountOutBeforeFee -> newInvariant -> amountBPTIn\\n    */\\n    function _calcBptInGivenExactTokensOut(\\n        uint256 amp,\\n        uint256[] memory balances,\\n        uint256[] memory amountsOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256) {\\n        // BPT in, so we round up overall.\\n\\n        // First loop calculates the sum of all token balances, which will be used to calculate\\n        // the current weights of each token relative to this sum\\n        uint256 sumBalances = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            sumBalances = sumBalances.add(balances[i]);\\n        }\\n\\n        // Calculate the weighted balance ratio without considering fees\\n        uint256[] memory balanceRatiosWithoutFee = new uint256[](amountsOut.length);\\n        uint256 invariantRatioWithoutFees = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            uint256 currentWeight = balances[i].divUp(sumBalances);\\n            balanceRatiosWithoutFee[i] = balances[i].sub(amountsOut[i]).divUp(balances[i]);\\n            invariantRatioWithoutFees = invariantRatioWithoutFees.add(balanceRatiosWithoutFee[i].mulUp(currentWeight));\\n        }\\n\\n        // Second loop calculates new amounts in, taking into account the fee on the percentage excess\\n        uint256[] memory newBalances = new uint256[](balances.length);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\\n            // 'token out'. This results in slightly larger price impact.\\n\\n            uint256 amountOutWithFee;\\n            if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithoutFees.complement());\\n                uint256 taxableAmount = amountsOut[i].sub(nonTaxableAmount);\\n                // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\\n                amountOutWithFee = nonTaxableAmount.add(taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage));\\n            } else {\\n                amountOutWithFee = amountsOut[i];\\n            }\\n\\n            newBalances[i] = balances[i].sub(amountOutWithFee);\\n        }\\n\\n        // Get current and new invariants, taking into account swap fees\\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\\n        uint256 newInvariant = _calculateInvariant(amp, newBalances, false);\\n        uint256 invariantRatio = newInvariant.divDown(currentInvariant);\\n\\n        // return amountBPTIn\\n        return bptTotalSupply.mulUp(invariantRatio.complement());\\n    }\\n\\n    function _calcTokenOutGivenExactBptIn(\\n        uint256 amp,\\n        uint256[] memory balances,\\n        uint256 tokenIndex,\\n        uint256 bptAmountIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256) {\\n        // Token out, so we round down overall.\\n\\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\\n        uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(currentInvariant);\\n\\n        // Calculate amount out without fee\\n        uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\\n            amp,\\n            balances,\\n            newInvariant,\\n            tokenIndex\\n        );\\n        uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\\n\\n        // First calculate the sum of all token balances, which will be used to calculate\\n        // the current weight of each token\\n        uint256 sumBalances = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            sumBalances = sumBalances.add(balances[i]);\\n        }\\n\\n        // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\\n        // in swap fees.\\n        uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\\n        uint256 taxablePercentage = currentWeight.complement();\\n\\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\\n        // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\\n        uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\\n        uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\\n\\n        // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\\n        return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\\n    }\\n\\n    function _calcTokensOutGivenExactBptIn(\\n        uint256[] memory balances,\\n        uint256 bptAmountIn,\\n        uint256 bptTotalSupply\\n    ) internal pure returns (uint256[] memory) {\\n        /**********************************************************************************************\\n        // exactBPTInForTokensOut                                                                    //\\n        // (per token)                                                                               //\\n        // aO = tokenAmountOut             /        bptIn         \\\\                                  //\\n        // b = tokenBalance      a0 = b * | ---------------------  |                                 //\\n        // bptIn = bptAmountIn             \\\\     bptTotalSupply    /                                 //\\n        // bpt = bptTotalSupply                                                                      //\\n        **********************************************************************************************/\\n\\n        // Since we're computing an amount out, we round down overall. This means rounding down on both the\\n        // multiplication and division.\\n\\n        uint256 bptRatio = bptAmountIn.divDown(bptTotalSupply);\\n\\n        uint256[] memory amountsOut = new uint256[](balances.length);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            amountsOut[i] = balances[i].mulDown(bptRatio);\\n        }\\n\\n        return amountsOut;\\n    }\\n\\n    // The amplification parameter equals: A n^(n-1)\\n    function _calcDueTokenProtocolSwapFeeAmount(\\n        uint256 amplificationParameter,\\n        uint256[] memory balances,\\n        uint256 lastInvariant,\\n        uint256 tokenIndex,\\n        uint256 protocolSwapFeePercentage\\n    ) internal pure returns (uint256) {\\n        /**************************************************************************************************************\\n        // oneTokenSwapFee - polynomial equation to solve                                                            //\\n        // af = fee amount to calculate in one token                                                                 //\\n        // bf = balance of fee token                                                                                 //\\n        // f = bf - af (finalBalanceFeeToken)                                                                        //\\n        // D = old invariant                                            D                     D^(n+1)                //\\n        // A = amplification coefficient               f^2 + ( S - ----------  - D) * f -  ------------- = 0         //\\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\\n        // S = sum of final balances but f                                                                           //\\n        // P = product of final balances but f                                                                       //\\n        **************************************************************************************************************/\\n\\n        // Protocol swap fee amount, so we round down overall.\\n\\n        uint256 finalBalanceFeeToken = _getTokenBalanceGivenInvariantAndAllOtherBalances(\\n            amplificationParameter,\\n            balances,\\n            lastInvariant,\\n            tokenIndex\\n        );\\n\\n        if (balances[tokenIndex] <= finalBalanceFeeToken) {\\n            // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\\n            // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\\n            return 0;\\n        }\\n\\n        // Result is rounded down\\n        uint256 accumulatedTokenSwapFees = balances[tokenIndex] - finalBalanceFeeToken;\\n        return accumulatedTokenSwapFees.mulDown(protocolSwapFeePercentage);\\n    }\\n\\n    // Private functions\\n\\n    // This function calculates the balance of a given token (tokenIndex)\\n    // given all the other balances and the invariant\\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\\n        uint256 amplificationParameter,\\n        uint256[] memory balances,\\n        uint256 invariant,\\n        uint256 tokenIndex\\n    ) internal pure returns (uint256) {\\n        // Rounds result up overall\\n\\n        uint256 ampTimesTotal = amplificationParameter * balances.length;\\n        uint256 sum = balances[0];\\n        uint256 P_D = balances[0] * balances.length;\\n        for (uint256 j = 1; j < balances.length; j++) {\\n            P_D = Math.divDown(Math.mul(Math.mul(P_D, balances[j]), balances.length), invariant);\\n            sum = sum.add(balances[j]);\\n        }\\n        // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\\n        sum = sum - balances[tokenIndex];\\n\\n        uint256 inv2 = Math.mul(invariant, invariant);\\n        // We remove the balance from c by multiplying it\\n        uint256 c = Math.mul(\\n            Math.mul(Math.divUp(inv2, Math.mul(ampTimesTotal, P_D)), _AMP_PRECISION),\\n            balances[tokenIndex]\\n        );\\n        uint256 b = sum.add(Math.mul(Math.divDown(invariant, ampTimesTotal), _AMP_PRECISION));\\n\\n        // We iterate to find the balance\\n        uint256 prevTokenBalance = 0;\\n        // We multiply the first iteration outside the loop with the invariant to set the value of the\\n        // initial approximation.\\n        uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));\\n\\n        for (uint256 i = 0; i < 255; i++) {\\n            prevTokenBalance = tokenBalance;\\n\\n            tokenBalance = Math.divUp(\\n                Math.mul(tokenBalance, tokenBalance).add(c),\\n                Math.mul(tokenBalance, 2).add(b).sub(invariant)\\n            );\\n\\n            if (tokenBalance > prevTokenBalance) {\\n                if (tokenBalance - prevTokenBalance <= 1) {\\n                    return tokenBalance;\\n                }\\n            } else if (prevTokenBalance - tokenBalance <= 1) {\\n                return tokenBalance;\\n            }\\n        }\\n\\n        _revert(Errors.STABLE_GET_BALANCE_DIDNT_CONVERGE);\\n    }\\n}\\n\",\"keccak256\":\"0xb1b7149466981ff2323a286ab2514e715af9a9061580b56113e257c8559e3bd8\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/StableOracleMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../FixedPoint.sol\\\";\\nimport \\\"../LogCompression.sol\\\";\\n\\nimport \\\"./StableMath.sol\\\";\\n\\ncontract StableOracleMath {\\n    using FixedPoint for uint256;\\n\\n    /**\\n     * @dev Calculates the spot price of token Y and BPT in token X.\\n     */\\n    function _calcLogPrices(\\n        uint256 amplificationParameter,\\n        uint256 balanceX,\\n        uint256 balanceY,\\n        int256 logBptTotalSupply\\n    ) internal view returns (int256 logSpotPrice, int256 logBptPrice) {\\n\\n        uint256 spotPrice = _calcSpotPrice(amplificationParameter, balanceX, balanceY);\\n        logBptPrice = _calcLogBptPrice(spotPrice, balanceX, balanceY, logBptTotalSupply);\\n        logSpotPrice = LogCompression.toLowResLog(spotPrice);\\n    }\\n\\n    /**\\n     * @dev Calculates the spot price of token Y in token X.\\n     */\\n    function _calcSpotPrice(\\n        uint256 amplificationParameter,\\n        uint256 balanceX,\\n        uint256 balanceY\\n    ) internal view returns (uint256) {\\n        /**************************************************************************************************************\\n        //                                                                                                           //\\n        //                             2.a.x.y + a.y^2 + b.y                                                         //\\n        // spot price Y/X = - dx/dy = -----------------------                                                        //\\n        //                             2.a.x.y + a.x^2 + b.x                                                         //\\n        //                                                                                                           //\\n        // n = 2                                                                                                     //\\n        // a = amp param * n                                                                                         //\\n        // b = D + a.(S - D)                                                                                         //\\n        // D = invariant                                                                                             //\\n        // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\\n        **************************************************************************************************************/\\n\\n        uint256 invariant = StableMath._calculateInvariant(amplificationParameter, _balances(balanceX, balanceY), true);\\n\\n        uint256 a = (amplificationParameter * 2) / StableMath._AMP_PRECISION;\\n        uint256 b = Math.mul(invariant, a).sub(invariant);\\n\\n        uint256 axy2 = Math.mul(a * 2, balanceX).mulDown(balanceY); // n = 2\\n\\n        // dx = a.x.y.2 + a.y^2 - b.y\\n        uint256 derivativeX = axy2.add(Math.mul(a, balanceY).mulDown(balanceY)).sub(b.mulDown(balanceY));\\n\\n        // dy = a.x.y.2 + a.x^2 - b.x\\n        uint256 derivativeY = axy2.add(Math.mul(a, balanceX).mulDown(balanceX)).sub(b.mulDown(balanceX));\\n\\n        // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\\n        // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\\n        // result of zero is therefore only possible with zero balances, which are prevented via other means.\\n        return derivativeX.divUp(derivativeY);\\n    }\\n\\n    /**\\n     * @dev Calculates the price of BPT in token X. `logBptTotalSupply` should be the result of calling\\n     * `LogCompression.toLowResLog` with the current BPT supply, and `spotPrice` the price of token\\n     * Y in token X (obtainable via `_calcSpotPrice()`.\\n     *\\n     * The return value is a 4 decimal fixed-point number: use `LogCompression.fromLowResLog`\\n     * to recover the original value.\\n     */\\n    function _calcLogBptPrice(\\n        uint256 spotPrice,\\n        uint256 balanceX,\\n        uint256 balanceY,\\n        int256 logBptTotalSupply\\n    ) internal pure returns (int256) {\\n        /**************************************************************************************************************\\n        //                                                                                                           //\\n        //              balance X + (spot price Y/X * balance Y)                                                     //\\n        // BPT price = ------------------------------------------                                                    //\\n        //                          total supply                                                                     //\\n        //                                                                                                           //\\n        // ln(BPT price) = ln(balance X + (spot price Y/X * balance Y)) - ln(totalSupply)                            //\\n        **************************************************************************************************************/\\n\\n        // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\\n        // space. We use `mulUp` as it prevents the result from being zero, which would make the logarithm revert. A\\n        // result of zero is therefore only possible with zero balances, which are prevented via other means.\\n        uint256 totalBalanceX = balanceX.add(spotPrice.mulUp(balanceY));\\n        int256 logTotalBalanceX = LogCompression.toLowResLog(totalBalanceX);\\n\\n        // Because we're subtracting two values in log space, this value has a larger error (+-0.0001 instead of\\n        // +-0.00005), which results in a final larger relative error of around 0.1%.\\n        return logTotalBalanceX - logBptTotalSupply;\\n    }\\n\\n    function _balances(uint256 balanceX, uint256 balanceY) private pure returns (uint256[] memory balances) {\\n        balances = new uint256[](2);\\n        balances[0] = balanceX;\\n        balances[1] = balanceY;\\n    }\\n}\\n\",\"keccak256\":\"0xbd25e2d0c49c21b56acb2c2a716c0813f8143b81f97a1ce77d51700e49d86dda\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/StablePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../FixedPoint.sol\\\";\\nimport \\\"../InputHelpers.sol\\\";\\nimport \\\"./WordCodec.sol\\\";\\n\\nimport \\\"./IRateProvider.sol\\\";\\n\\nimport \\\"../BasePool/BasePool.sol\\\";\\n\\nimport \\\"./StableMath.sol\\\";\\nimport \\\"./StablePoolUserDataHelpers.sol\\\";\\nimport \\\"../BasePool/BaseMinimalSwapInfoPool.sol\\\";\\nimport \\\"../BasePool/BaseGeneralPool.sol\\\";\\n\\ncontract StablePool is BaseGeneralPool, BaseMinimalSwapInfoPool, IRateProvider {\\n    using WordCodec for bytes32;\\n    using FixedPoint for uint256;\\n    using StablePoolUserDataHelpers for bytes;\\n\\n    // This contract uses timestamps to slowly update its Amplification parameter over time. These changes must occur\\n    // over a minimum time period much larger than the blocktime, making timestamp manipulation a non-issue.\\n    // solhint-disable not-rely-on-time\\n\\n    // Amplification factor changes must happen over a minimum period of one day, and can at most divide or multiply the\\n    // current value by 2 every day.\\n    // WARNING: this only limits *a single* amplification change to have a maximum rate of change of twice the original\\n    // value daily. It is possible to perform multiple amplification changes in sequence to increase this value more\\n    // rapidly: for example, by doubling the value every day it can increase by a factor of 8 over three days (2^3).\\n    uint256 private constant _MIN_UPDATE_TIME = 1 days;\\n    uint256 private constant _MAX_AMP_UPDATE_DAILY_RATE = 2;\\n\\n    bytes32 private _packedAmplificationData;\\n\\n    event AmpUpdateStarted(uint256 startValue, uint256 endValue, uint256 startTime, uint256 endTime);\\n    event AmpUpdateStopped(uint256 currentValue);\\n\\n    uint256 private immutable _totalTokens;\\n\\n    IERC20 internal immutable _token0;\\n    IERC20 internal immutable _token1;\\n    IERC20 internal immutable _token2;\\n    IERC20 internal immutable _token3;\\n    IERC20 internal immutable _token4;\\n\\n    // All token balances are normalized to behave as if the token had 18 decimals. We assume a token's decimals will\\n    // not change throughout its lifetime, and store the corresponding scaling factor for each at construction time.\\n    // These factors are always greater than or equal to one: tokens with more than 18 decimals are not supported.\\n\\n    uint256 internal immutable _scalingFactor0;\\n    uint256 internal immutable _scalingFactor1;\\n    uint256 internal immutable _scalingFactor2;\\n    uint256 internal immutable _scalingFactor3;\\n    uint256 internal immutable _scalingFactor4;\\n\\n    // To track how many tokens are owed to the Vault as protocol fees, we measure and store the value of the invariant\\n    // after every join and exit. All invariant growth that happens between join and exit events is due to swap fees.\\n    uint256 internal _lastInvariant;\\n\\n    // Because the invariant depends on the amplification parameter, and this value may change over time, we should only\\n    // compare invariants that were computed using the same value. We therefore store it whenever we store\\n    // _lastInvariant.\\n    uint256 internal _lastInvariantAmp;\\n\\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT }\\n    enum ExitKind { EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT }\\n\\n    constructor(\\n        IVault vault,\\n        string memory name,\\n        string memory symbol,\\n        IERC20[] memory tokens,\\n        uint256 amplificationParameter,\\n        uint256 swapFeePercentage,\\n        uint256 pauseWindowDuration,\\n        uint256 bufferPeriodDuration,\\n        address owner\\n    )\\n    BasePool(\\n        vault,\\n    // Because we're inheriting from both BaseGeneralPool and BaseMinimalSwapInfoPool we can choose any\\n    // specialization setting. Since this Pool never registers or deregisters any tokens after construction,\\n    // picking Two Token when the Pool only has two tokens is free gas savings.\\n        tokens.length == 2 ? IVault.PoolSpecialization.TWO_TOKEN : IVault.PoolSpecialization.GENERAL,\\n        name,\\n        symbol,\\n        tokens,\\n        new address[](tokens.length),\\n        swapFeePercentage,\\n        pauseWindowDuration,\\n        bufferPeriodDuration,\\n        owner\\n    )\\n    {\\n        _require(amplificationParameter >= StableMath._MIN_AMP, Errors.MIN_AMP);\\n        _require(amplificationParameter <= StableMath._MAX_AMP, Errors.MAX_AMP);\\n\\n        uint256 totalTokens = tokens.length;\\n        _totalTokens = totalTokens;\\n\\n        // Immutable variables cannot be initialized inside an if statement, so we must do conditional assignments\\n        _token0 = tokens[0];\\n        _token1 = tokens[1];\\n        _token2 = totalTokens > 2 ? tokens[2] : IERC20(0);\\n        _token3 = totalTokens > 3 ? tokens[3] : IERC20(0);\\n        _token4 = totalTokens > 4 ? tokens[4] : IERC20(0);\\n\\n        _scalingFactor0 = _computeScalingFactor(tokens[0]);\\n        _scalingFactor1 = _computeScalingFactor(tokens[1]);\\n        _scalingFactor2 = totalTokens > 2 ? _computeScalingFactor(tokens[2]) : 0;\\n        _scalingFactor3 = totalTokens > 3 ? _computeScalingFactor(tokens[3]) : 0;\\n        _scalingFactor4 = totalTokens > 4 ? _computeScalingFactor(tokens[4]) : 0;\\n\\n        uint256 initialAmp = Math.mul(amplificationParameter, StableMath._AMP_PRECISION);\\n        _setAmplificationData(initialAmp);\\n    }\\n\\n    function getLastInvariant() external view returns (uint256 lastInvariant, uint256 lastInvariantAmp) {\\n        lastInvariant = _lastInvariant;\\n        lastInvariantAmp = _lastInvariantAmp;\\n    }\\n\\n    // Base Pool handlers\\n\\n    // Swap - General Pool specialization (from BaseGeneralPool)\\n\\n    function _onSwapGivenIn(\\n        SwapRequest memory swapRequest,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) internal virtual override whenNotPaused returns (uint256) {\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n\\n        uint256 invariant = StableMath._calculateInvariant(currentAmp, balances, true);\\n        uint256 amountOut = StableMath._calcOutGivenIn(\\n            currentAmp,\\n            balances,\\n            indexIn,\\n            indexOut,\\n            swapRequest.amount,\\n            invariant\\n        );\\n\\n        return amountOut;\\n    }\\n\\n    function _onSwapGivenOut(\\n        SwapRequest memory swapRequest,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) internal virtual override whenNotPaused returns (uint256) {\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n\\n        uint256 invariant = StableMath._calculateInvariant(currentAmp, balances, true);\\n        uint256 amountIn = StableMath._calcInGivenOut(\\n            currentAmp,\\n            balances,\\n            indexIn,\\n            indexOut,\\n            swapRequest.amount,\\n            invariant\\n        );\\n\\n        return amountIn;\\n    }\\n\\n    // Swap - Two Token Pool specialization (from BaseMinimalSwapInfoPool)\\n\\n    function _onSwapGivenIn(\\n        SwapRequest memory swapRequest,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    ) internal virtual override returns (uint256) {\\n        _require(_getTotalTokens() == 2, Errors.NOT_TWO_TOKENS);\\n\\n        (uint256[] memory balances, uint256 indexIn, uint256 indexOut) = _getSwapBalanceArrays(\\n            swapRequest,\\n            balanceTokenIn,\\n            balanceTokenOut\\n        );\\n\\n        return _onSwapGivenIn(swapRequest, balances, indexIn, indexOut);\\n    }\\n\\n    function _onSwapGivenOut(\\n        SwapRequest memory swapRequest,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    ) internal virtual override returns (uint256) {\\n        _require(_getTotalTokens() == 2, Errors.NOT_TWO_TOKENS);\\n\\n        (uint256[] memory balances, uint256 indexIn, uint256 indexOut) = _getSwapBalanceArrays(\\n            swapRequest,\\n            balanceTokenIn,\\n            balanceTokenOut\\n        );\\n        return _onSwapGivenOut(swapRequest, balances, indexIn, indexOut);\\n    }\\n\\n    function _getSwapBalanceArrays(\\n        SwapRequest memory swapRequest,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    )\\n    private\\n    view\\n    returns (\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    )\\n    {\\n        balances = new uint256[](2);\\n\\n        if (_isToken0(swapRequest.tokenIn)) {\\n            indexIn = 0;\\n            indexOut = 1;\\n\\n            balances[0] = balanceTokenIn;\\n            balances[1] = balanceTokenOut;\\n        } else {\\n            // _token0 == swapRequest.tokenOut\\n            indexOut = 0;\\n            indexIn = 1;\\n\\n            balances[0] = balanceTokenOut;\\n            balances[1] = balanceTokenIn;\\n        }\\n    }\\n\\n    // Initialize\\n\\n    function _onInitializePool(\\n        bytes32,\\n        address,\\n        address,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) internal virtual override whenNotPaused returns (uint256, uint256[] memory) {\\n        // It would be strange for the Pool to be paused before it is initialized, but for consistency we prevent\\n        // initialization in this case.\\n\\n        StablePool.JoinKind kind = userData.joinKind();\\n        _require(kind == StablePool.JoinKind.INIT, Errors.UNINITIALIZED);\\n\\n        uint256[] memory amountsIn = userData.initialAmountsIn();\\n        InputHelpers.ensureInputLengthMatch(amountsIn.length, _getTotalTokens());\\n        _upscaleArray(amountsIn, scalingFactors);\\n\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n        uint256 invariantAfterJoin = StableMath._calculateInvariant(currentAmp, amountsIn, true);\\n\\n        // Set the initial BPT to the value of the invariant.\\n        uint256 bptAmountOut = invariantAfterJoin;\\n\\n        _updateLastInvariant(invariantAfterJoin, currentAmp);\\n\\n        return (bptAmountOut, amountsIn);\\n    }\\n\\n    // Join\\n\\n    function _onJoinPool(\\n        bytes32,\\n        address,\\n        address,\\n        uint256[] memory balances,\\n        uint256,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n    internal\\n    virtual\\n    override\\n    whenNotPaused\\n    returns (\\n        uint256,\\n        uint256[] memory,\\n        uint256[] memory\\n    )\\n    {\\n        // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous join\\n        // or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids spending gas to\\n        // calculate the fee amounts during each individual swap.\\n        uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);\\n\\n        // Update current balances by subtracting the protocol fee amounts\\n        _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\\n        (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(balances, scalingFactors, userData);\\n\\n        // Update the invariant with the balances the Pool will have after the join, in order to compute the\\n        // protocol swap fee amounts due in future joins and exits.\\n        _updateInvariantAfterJoin(balances, amountsIn);\\n\\n        return (bptAmountOut, amountsIn, dueProtocolFeeAmounts);\\n    }\\n\\n    function _doJoin(\\n        uint256[] memory balances,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) private view returns (uint256, uint256[] memory) {\\n        JoinKind kind = userData.joinKind();\\n\\n        if (kind == JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {\\n            return _joinExactTokensInForBPTOut(balances, scalingFactors, userData);\\n        } else if (kind == JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT) {\\n            return _joinTokenInForExactBPTOut(balances, userData);\\n        } else {\\n            _revert(Errors.UNHANDLED_JOIN_KIND);\\n        }\\n    }\\n\\n    function _joinExactTokensInForBPTOut(\\n        uint256[] memory balances,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) private view returns (uint256, uint256[] memory) {\\n        (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();\\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), amountsIn.length);\\n\\n        _upscaleArray(amountsIn, scalingFactors);\\n\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n        uint256 bptAmountOut = StableMath._calcBptOutGivenExactTokensIn(\\n            currentAmp,\\n            balances,\\n            amountsIn,\\n            totalSupply(),\\n            getSwapFeePercentage()\\n        );\\n\\n        _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);\\n\\n        return (bptAmountOut, amountsIn);\\n    }\\n\\n    function _joinTokenInForExactBPTOut(uint256[] memory balances, bytes memory userData)\\n    private\\n    view\\n    returns (uint256, uint256[] memory)\\n    {\\n        (uint256 bptAmountOut, uint256 tokenIndex) = userData.tokenInForExactBptOut();\\n        // Note that there is no maximum amountIn parameter: this is handled by `IVault.joinPool`.\\n\\n        _require(tokenIndex < _getTotalTokens(), Errors.OUT_OF_BOUNDS);\\n\\n        uint256[] memory amountsIn = new uint256[](_getTotalTokens());\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n        amountsIn[tokenIndex] = StableMath._calcTokenInGivenExactBptOut(\\n            currentAmp,\\n            balances,\\n            tokenIndex,\\n            bptAmountOut,\\n            totalSupply(),\\n            getSwapFeePercentage()\\n        );\\n\\n        return (bptAmountOut, amountsIn);\\n    }\\n\\n    // Exit\\n\\n    function _onExitPool(\\n        bytes32,\\n        address,\\n        address,\\n        uint256[] memory balances,\\n        uint256,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n    internal\\n    virtual\\n    override\\n    returns (\\n        uint256 bptAmountIn,\\n        uint256[] memory amountsOut,\\n        uint256[] memory dueProtocolFeeAmounts\\n    )\\n    {\\n        // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens\\n        // out) remain functional.\\n\\n        if (_isNotPaused()) {\\n            // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous\\n            // join or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids\\n            // spending gas calculating fee amounts during each individual swap\\n            dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);\\n\\n            // Update current balances by subtracting the protocol fee amounts\\n            _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\\n        } else {\\n            // If the contract is paused, swap protocol fee amounts are not charged to avoid extra calculations and\\n            // reduce the potential for errors.\\n            dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\\n        }\\n\\n        (bptAmountIn, amountsOut) = _doExit(balances, scalingFactors, userData);\\n\\n        // Update the invariant with the balances the Pool will have after the exit, in order to compute the\\n        // protocol swap fee amounts due in future joins and exits.\\n        _updateInvariantAfterExit(balances, amountsOut);\\n\\n        return (bptAmountIn, amountsOut, dueProtocolFeeAmounts);\\n    }\\n\\n    function _doExit(\\n        uint256[] memory balances,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) private view returns (uint256, uint256[] memory) {\\n        ExitKind kind = userData.exitKind();\\n\\n        if (kind == ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT) {\\n            return _exitExactBPTInForTokenOut(balances, userData);\\n        } else if (kind == ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {\\n            return _exitExactBPTInForTokensOut(balances, userData);\\n        } else if (kind == ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {\\n            return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);\\n        } else {\\n            _revert(Errors.UNHANDLED_EXIT_KIND);\\n        }\\n    }\\n\\n    function _exitExactBPTInForTokenOut(uint256[] memory balances, bytes memory userData)\\n    private\\n    view\\n    whenNotPaused\\n    returns (uint256, uint256[] memory)\\n    {\\n        // This exit function is disabled if the contract is paused.\\n\\n        (uint256 bptAmountIn, uint256 tokenIndex) = userData.exactBptInForTokenOut();\\n        // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.\\n\\n        _require(tokenIndex < _getTotalTokens(), Errors.OUT_OF_BOUNDS);\\n\\n        // We exit in a single token, so initialize amountsOut with zeros\\n        uint256[] memory amountsOut = new uint256[](_getTotalTokens());\\n\\n        // And then assign the result to the selected token\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n        amountsOut[tokenIndex] = StableMath._calcTokenOutGivenExactBptIn(\\n            currentAmp,\\n            balances,\\n            tokenIndex,\\n            bptAmountIn,\\n            totalSupply(),\\n            getSwapFeePercentage()\\n        );\\n\\n        return (bptAmountIn, amountsOut);\\n    }\\n\\n    function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)\\n    private\\n    view\\n    returns (uint256, uint256[] memory)\\n    {\\n        // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted\\n        // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.\\n        // This particular exit function is the only one that remains available because it is the simplest one, and\\n        // therefore the one with the lowest likelihood of errors.\\n\\n        uint256 bptAmountIn = userData.exactBptInForTokensOut();\\n        // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.\\n\\n        uint256[] memory amountsOut = StableMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());\\n        return (bptAmountIn, amountsOut);\\n    }\\n\\n    function _exitBPTInForExactTokensOut(\\n        uint256[] memory balances,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) private view whenNotPaused returns (uint256, uint256[] memory) {\\n        // This exit function is disabled if the contract is paused.\\n\\n        (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();\\n        InputHelpers.ensureInputLengthMatch(amountsOut.length, _getTotalTokens());\\n        _upscaleArray(amountsOut, scalingFactors);\\n\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n        uint256 bptAmountIn = StableMath._calcBptInGivenExactTokensOut(\\n            currentAmp,\\n            balances,\\n            amountsOut,\\n            totalSupply(),\\n            getSwapFeePercentage()\\n        );\\n        _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);\\n\\n        return (bptAmountIn, amountsOut);\\n    }\\n\\n    // Helpers\\n\\n    /**\\n     * @dev Stores the last measured invariant, and the amplification parameter used to compute it.\\n     */\\n    function _updateLastInvariant(uint256 invariant, uint256 amplificationParameter) internal {\\n        _lastInvariant = invariant;\\n        _lastInvariantAmp = amplificationParameter;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of protocol fees to pay, given the value of the last stored invariant and the current\\n     * balances.\\n     */\\n    function _getDueProtocolFeeAmounts(uint256[] memory balances, uint256 protocolSwapFeePercentage)\\n    private\\n    view\\n    returns (uint256[] memory)\\n    {\\n        // Initialize with zeros\\n        uint256[] memory dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\\n\\n        // Early return if the protocol swap fee percentage is zero, saving gas.\\n        if (protocolSwapFeePercentage == 0) {\\n            return dueProtocolFeeAmounts;\\n        }\\n\\n        // Instead of paying the protocol swap fee in all tokens proportionally, we will pay it in a single one. This\\n        // will reduce gas costs for single asset joins and exits, as at most only two Pool balances will change (the\\n        // token joined/exited, and the token in which fees will be paid).\\n\\n        // The protocol fee is charged using the token with the highest balance in the pool.\\n        uint256 chosenTokenIndex = 0;\\n        uint256 maxBalance = balances[0];\\n        for (uint256 i = 1; i < _getTotalTokens(); ++i) {\\n            uint256 currentBalance = balances[i];\\n            if (currentBalance > maxBalance) {\\n                chosenTokenIndex = i;\\n                maxBalance = currentBalance;\\n            }\\n        }\\n\\n        // Set the fee amount to pay in the selected token\\n        dueProtocolFeeAmounts[chosenTokenIndex] = StableMath._calcDueTokenProtocolSwapFeeAmount(\\n            _lastInvariantAmp,\\n            balances,\\n            _lastInvariant,\\n            chosenTokenIndex,\\n            protocolSwapFeePercentage\\n        );\\n\\n        return dueProtocolFeeAmounts;\\n    }\\n\\n    /**\\n     * @dev Computes and stores the value of the invariant after a join, which is required to compute due protocol fees\\n     * in the future.\\n     */\\n    function _updateInvariantAfterJoin(uint256[] memory balances, uint256[] memory amountsIn) private {\\n        _mutateAmounts(balances, amountsIn, FixedPoint.add);\\n\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n        // This invariant is used only to compute the final balance when calculating the protocol fees. These are\\n        // rounded down, so we round the invariant up.\\n        _updateLastInvariant(StableMath._calculateInvariant(currentAmp, balances, true), currentAmp);\\n    }\\n\\n    /**\\n     * @dev Computes and stores the value of the invariant after an exit, which is required to compute due protocol fees\\n     * in the future.\\n     */\\n    function _updateInvariantAfterExit(uint256[] memory balances, uint256[] memory amountsOut) private {\\n        _mutateAmounts(balances, amountsOut, FixedPoint.sub);\\n\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n        // This invariant is used only to compute the final balance when calculating the protocol fees. These are\\n        // rounded down, so we round the invariant up.\\n        _updateLastInvariant(StableMath._calculateInvariant(currentAmp, balances, true), currentAmp);\\n    }\\n\\n    /**\\n     * @dev Mutates `amounts` by applying `mutation` with each entry in `arguments`.\\n     *\\n     * Equivalent to `amounts = amounts.map(mutation)`.\\n     */\\n    function _mutateAmounts(\\n        uint256[] memory toMutate,\\n        uint256[] memory arguments,\\n        function(uint256, uint256) pure returns (uint256) mutation\\n    ) private view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            toMutate[i] = mutation(toMutate[i], arguments[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev This function returns the appreciation of one BPT relative to the\\n     * underlying tokens. This starts at 1 when the pool is created and grows over time\\n     */\\n    function getRate() public view override returns (uint256) {\\n        (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());\\n\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n\\n        _upscaleArray(balances, _scalingFactors());\\n\\n        // When calculating the current BPT rate, we may not have paid the protocol fees, therefore\\n        // the invariant should be smaller than its current value. Then, we round down overall.\\n        uint256 invariant = StableMath._calculateInvariant(currentAmp, balances, false);\\n        return invariant.divDown(totalSupply());\\n    }\\n\\n    // Amplification\\n\\n    /**\\n     * @dev Begins changing the amplification parameter to `rawEndValue` over time. The value will change linearly until\\n     * `endTime` is reached, when it will be `rawEndValue`.\\n     *\\n     * NOTE: Internally, the amplification parameter is represented using higher precision. The values returned by\\n     * `getAmplificationParameter` have to be corrected to account for this when comparing to `rawEndValue`.\\n     */\\n    function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {\\n        _require(rawEndValue >= StableMath._MIN_AMP, Errors.MIN_AMP);\\n        _require(rawEndValue <= StableMath._MAX_AMP, Errors.MAX_AMP);\\n\\n        uint256 duration = Math.sub(endTime, block.timestamp);\\n        _require(duration >= _MIN_UPDATE_TIME, Errors.AMP_END_TIME_TOO_CLOSE);\\n\\n        (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();\\n        _require(!isUpdating, Errors.AMP_ONGOING_UPDATE);\\n\\n        uint256 endValue = Math.mul(rawEndValue, StableMath._AMP_PRECISION);\\n\\n        // daily rate = (endValue / currentValue) / duration * 1 day\\n        // We perform all multiplications first to not reduce precision, and round the division up as we want to avoid\\n        // large rates. Note that these are regular integer multiplications and divisions, not fixed point.\\n        uint256 dailyRate = endValue > currentValue\\n        ? Math.divUp(Math.mul(1 days, endValue), Math.mul(currentValue, duration))\\n        : Math.divUp(Math.mul(1 days, currentValue), Math.mul(endValue, duration));\\n        _require(dailyRate <= _MAX_AMP_UPDATE_DAILY_RATE, Errors.AMP_RATE_TOO_HIGH);\\n\\n        _setAmplificationData(currentValue, endValue, block.timestamp, endTime);\\n    }\\n\\n    /**\\n     * @dev Stops the amplification parameter change process, keeping the current value.\\n     */\\n    function stopAmplificationParameterUpdate() external authenticate {\\n        (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();\\n        _require(isUpdating, Errors.AMP_NO_ONGOING_UPDATE);\\n\\n        _setAmplificationData(currentValue);\\n    }\\n\\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {\\n        return\\n        (actionId == getActionId(StablePool.startAmplificationParameterUpdate.selector)) ||\\n        (actionId == getActionId(StablePool.stopAmplificationParameterUpdate.selector)) ||\\n        super._isOwnerOnlyAction(actionId);\\n    }\\n\\n    function getAmplificationParameter()\\n    external\\n    view\\n    returns (\\n        uint256 value,\\n        bool isUpdating,\\n        uint256 precision\\n    )\\n    {\\n        (value, isUpdating) = _getAmplificationParameter();\\n        precision = StableMath._AMP_PRECISION;\\n    }\\n\\n    function _getAmplificationParameter() internal view returns (uint256 value, bool isUpdating) {\\n        (uint256 startValue, uint256 endValue, uint256 startTime, uint256 endTime) = _getAmplificationData();\\n\\n        // Note that block.timestamp >= startTime, since startTime is set to the current time when an update starts\\n\\n        if (block.timestamp < endTime) {\\n            isUpdating = true;\\n\\n            // We can skip checked arithmetic as:\\n            //  - block.timestamp is always larger or equal to startTime\\n            //  - endTime is always larger than startTime\\n            //  - the value delta is bounded by the largest amplification parameter, which never causes the\\n            //    multiplication to overflow.\\n            // This also means that the following computation will never revert nor yield invalid results.\\n            if (endValue > startValue) {\\n                value = startValue + ((endValue - startValue) * (block.timestamp - startTime)) / (endTime - startTime);\\n            } else {\\n                value = startValue - ((startValue - endValue) * (block.timestamp - startTime)) / (endTime - startTime);\\n            }\\n        } else {\\n            isUpdating = false;\\n            value = endValue;\\n        }\\n    }\\n\\n    function _getMaxTokens() internal pure override returns (uint256) {\\n        return StableMath._MAX_STABLE_TOKENS;\\n    }\\n\\n    function _getTotalTokens() internal view virtual override returns (uint256) {\\n        return _totalTokens;\\n    }\\n\\n    function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {\\n        // prettier-ignore\\n        if (_isToken0(token)) { return _getScalingFactor0(); }\\n        else if (_isToken1(token)) { return _getScalingFactor1(); }\\n        else if (token == _token2) { return _getScalingFactor2(); }\\n        else if (token == _token3) { return _getScalingFactor3(); }\\n        else if (token == _token4) { return _getScalingFactor4(); }\\n        else {\\n            _revert(Errors.INVALID_TOKEN);\\n        }\\n    }\\n\\n    function _scalingFactors() internal view virtual override returns (uint256[] memory) {\\n        uint256 totalTokens = _getTotalTokens();\\n        uint256[] memory scalingFactors = new uint256[](totalTokens);\\n\\n        // prettier-ignore\\n        {\\n            scalingFactors[0] = _getScalingFactor0();\\n            scalingFactors[1] = _getScalingFactor1();\\n            if (totalTokens > 2) { scalingFactors[2] = _getScalingFactor2(); } else { return scalingFactors; }\\n            if (totalTokens > 3) { scalingFactors[3] = _getScalingFactor3(); } else { return scalingFactors; }\\n            if (totalTokens > 4) { scalingFactors[4] = _getScalingFactor4(); } else { return scalingFactors; }\\n        }\\n\\n        return scalingFactors;\\n    }\\n\\n    function _setAmplificationData(uint256 value) private {\\n        _storeAmplificationData(value, value, block.timestamp, block.timestamp);\\n        emit AmpUpdateStopped(value);\\n    }\\n\\n    function _setAmplificationData(\\n        uint256 startValue,\\n        uint256 endValue,\\n        uint256 startTime,\\n        uint256 endTime\\n    ) private {\\n        _storeAmplificationData(startValue, endValue, startTime, endTime);\\n        emit AmpUpdateStarted(startValue, endValue, startTime, endTime);\\n    }\\n\\n    function _storeAmplificationData(\\n        uint256 startValue,\\n        uint256 endValue,\\n        uint256 startTime,\\n        uint256 endTime\\n    ) private {\\n        _packedAmplificationData =\\n        WordCodec.encodeUint(uint64(startValue), 0) |\\n        WordCodec.encodeUint(uint64(endValue), 64) |\\n        WordCodec.encodeUint(uint64(startTime), 64 * 2) |\\n        WordCodec.encodeUint(uint64(endTime), 64 * 3);\\n    }\\n\\n    function _getAmplificationData()\\n    private\\n    view\\n    returns (\\n        uint256 startValue,\\n        uint256 endValue,\\n        uint256 startTime,\\n        uint256 endTime\\n    )\\n    {\\n        startValue = _packedAmplificationData.decodeUint64(0);\\n        endValue = _packedAmplificationData.decodeUint64(64);\\n        startTime = _packedAmplificationData.decodeUint64(64 * 2);\\n        endTime = _packedAmplificationData.decodeUint64(64 * 3);\\n    }\\n\\n    function _isToken0(IERC20 token) internal view returns (bool) {\\n        return token == _token0;\\n    }\\n\\n    function _isToken1(IERC20 token) internal view returns (bool) {\\n        return token == _token1;\\n    }\\n\\n    function _getScalingFactor0() internal view returns (uint256) {\\n        return _scalingFactor0;\\n    }\\n\\n    function _getScalingFactor1() internal view returns (uint256) {\\n        return _scalingFactor1;\\n    }\\n\\n    function _getScalingFactor2() internal view returns (uint256) {\\n        return _scalingFactor2;\\n    }\\n\\n    function _getScalingFactor3() internal view returns (uint256) {\\n        return _scalingFactor3;\\n    }\\n\\n    function _getScalingFactor4() internal view returns (uint256) {\\n        return _scalingFactor4;\\n    }\\n}\\n\",\"keccak256\":\"0x3890d892a3b5de660064bfd1287b834102f1373015efa0b414992679244328d0\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/StablePoolUserDataHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\nimport \\\"./StablePool.sol\\\";\\n\\nlibrary StablePoolUserDataHelpers {\\n    function joinKind(bytes memory self) internal pure returns (StablePool.JoinKind) {\\n        return abi.decode(self, (StablePool.JoinKind));\\n    }\\n\\n    function exitKind(bytes memory self) internal pure returns (StablePool.ExitKind) {\\n        return abi.decode(self, (StablePool.ExitKind));\\n    }\\n\\n    // Joins\\n\\n    function initialAmountsIn(bytes memory self) internal pure returns (uint256[] memory amountsIn) {\\n        (, amountsIn) = abi.decode(self, (StablePool.JoinKind, uint256[]));\\n    }\\n\\n    function exactTokensInForBptOut(bytes memory self)\\n        internal\\n        pure\\n        returns (uint256[] memory amountsIn, uint256 minBPTAmountOut)\\n    {\\n        (, amountsIn, minBPTAmountOut) = abi.decode(self, (StablePool.JoinKind, uint256[], uint256));\\n    }\\n\\n    function tokenInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut, uint256 tokenIndex) {\\n        (, bptAmountOut, tokenIndex) = abi.decode(self, (StablePool.JoinKind, uint256, uint256));\\n    }\\n\\n    // Exits\\n\\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (StablePool.ExitKind, uint256, uint256));\\n    }\\n\\n    function exactBptInForTokensOut(bytes memory self) internal pure returns (uint256 bptAmountIn) {\\n        (, bptAmountIn) = abi.decode(self, (StablePool.ExitKind, uint256));\\n    }\\n\\n    function bptInForExactTokensOut(bytes memory self)\\n        internal\\n        pure\\n        returns (uint256[] memory amountsOut, uint256 maxBPTAmountIn)\\n    {\\n        (, amountsOut, maxBPTAmountIn) = abi.decode(self, (StablePool.ExitKind, uint256[], uint256));\\n    }\\n}\\n\",\"keccak256\":\"0x9fde7d75dd5b6f0b43cc7350301ae117f83eca7a7b11a838a8ceffb113f7d29b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/WordCodec.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Library for encoding and decoding values stored inside a 256 bit word. Typically used to pack multiple values in\\n * a single storage slot, saving gas by performing less storage accesses.\\n *\\n * Each value is defined by its size and the least significant bit in the word, also known as offset. For example, two\\n * 128 bit values may be encoded in a word by assigning one an offset of 0, and the other an offset of 128.\\n *\\n * We could use Solidity structs to pack values together in a single storage slot instead of relying on a custom and\\n * error-prone library, but unfortunately Solidity only allows for structs to live in either storage, calldata or\\n * memory. Because a memory struct uses not just memory but also a slot in the stack (to store its memory location),\\n * using memory for word-sized values (i.e. of 256 bits or less) is strictly less gas performant, and doesn't even\\n * prevent stack-too-deep issues. This is compounded by the fact that Balancer contracts typically are memory-intensive,\\n * and the cost of accesing memory increases quadratically with the number of allocated words. Manual packing and\\n * unpacking is therefore the preferred approach.\\n */\\nlibrary WordCodec {\\n    // Masks are values with the least significant N bits set. They can be used to extract an encoded value from a word,\\n    // or to insert a new one replacing the old.\\n    uint256 private constant _MASK_1 = 2**(1) - 1;\\n    uint256 private constant _MASK_5 = 2**(5) - 1;\\n    uint256 private constant _MASK_7 = 2**(7) - 1;\\n    uint256 private constant _MASK_10 = 2**(10) - 1;\\n    uint256 private constant _MASK_16 = 2**(16) - 1;\\n    uint256 private constant _MASK_22 = 2**(22) - 1;\\n    uint256 private constant _MASK_31 = 2**(31) - 1;\\n    uint256 private constant _MASK_32 = 2**(32) - 1;\\n    uint256 private constant _MASK_53 = 2**(53) - 1;\\n    uint256 private constant _MASK_64 = 2**(64) - 1;\\n    uint256 private constant _MASK_128 = 2**(128) - 1;\\n    uint256 private constant _MASK_192 = 2**(192) - 1;\\n\\n    // Largest positive values that can be represented as N bits signed integers.\\n    int256 private constant _MAX_INT_22 = 2**(21) - 1;\\n    int256 private constant _MAX_INT_53 = 2**(52) - 1;\\n\\n    // In-place insertion\\n\\n    /**\\n     * @dev Inserts a boolean value shifted by an offset into a 256 bit word, replacing the old value. Returns the new\\n     * word.\\n     */\\n    function insertBool(\\n        bytes32 word,\\n        bool value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_1 << offset));\\n        return clearedWord | bytes32(uint256(value ? 1 : 0) << offset);\\n    }\\n\\n    // Unsigned\\n\\n    /**\\n     * @dev Inserts a 5 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 5 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint5(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_5 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 7 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 7 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint7(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_7 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 10 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 10 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint10(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_10 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 16 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value.\\n     * Returns the new word.\\n     *\\n     * Assumes `value` only uses its least significant 16 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint16(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_16 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 31 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` can be represented using 31 bits.\\n     */\\n    function insertUint31(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_31 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 32 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 32 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint32(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_32 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 64 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 64 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint64(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_64 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    // Signed\\n\\n    /**\\n     * @dev Inserts a 22 bits signed integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` can be represented using 22 bits.\\n     */\\n    function insertInt22(\\n        bytes32 word,\\n        int256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_22 << offset));\\n        // Integer values need masking to remove the upper bits of negative values.\\n        return clearedWord | bytes32((uint256(value) & _MASK_22) << offset);\\n    }\\n\\n    // Bytes\\n\\n    /**\\n     * @dev Inserts 192 bit shifted by an offset into a 256 bit word, replacing the old value. Returns the new word.\\n     *\\n     * Assumes `value` can be represented using 192 bits.\\n     */\\n    function insertBits192(\\n        bytes32 word,\\n        bytes32 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_192 << offset));\\n        return clearedWord | bytes32((uint256(value) & _MASK_192) << offset);\\n    }\\n\\n    // Encoding\\n\\n    // Unsigned\\n\\n    /**\\n     * @dev Encodes an unsigned integer shifted by an offset. This performs no size checks: it is up to the caller to\\n     * ensure that the values are bounded.\\n     *\\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\\n     */\\n    function encodeUint(uint256 value, uint256 offset) internal pure returns (bytes32) {\\n        return bytes32(value << offset);\\n    }\\n\\n    // Signed\\n\\n    /**\\n     * @dev Encodes a 22 bits signed integer shifted by an offset.\\n     *\\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\\n     */\\n    function encodeInt22(int256 value, uint256 offset) internal pure returns (bytes32) {\\n        // Integer values need masking to remove the upper bits of negative values.\\n        return bytes32((uint256(value) & _MASK_22) << offset);\\n    }\\n\\n    /**\\n     * @dev Encodes a 53 bits signed integer shifted by an offset.\\n     *\\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\\n     */\\n    function encodeInt53(int256 value, uint256 offset) internal pure returns (bytes32) {\\n        // Integer values need masking to remove the upper bits of negative values.\\n        return bytes32((uint256(value) & _MASK_53) << offset);\\n    }\\n\\n    // Decoding\\n\\n    /**\\n     * @dev Decodes and returns a boolean shifted by an offset from a 256 bit word.\\n     */\\n    function decodeBool(bytes32 word, uint256 offset) internal pure returns (bool) {\\n        return (uint256(word >> offset) & _MASK_1) == 1;\\n    }\\n\\n    // Unsigned\\n\\n    /**\\n     * @dev Decodes and returns a 5 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint5(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_5;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 7 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint7(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_7;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 10 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint10(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_10;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 16 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint16(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_16;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 31 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint31(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_31;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 32 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint32(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_32;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 64 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint64(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_64;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 128 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint128(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_128;\\n    }\\n\\n    // Signed\\n\\n    /**\\n     * @dev Decodes and returns a 22 bits signed integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeInt22(bytes32 word, uint256 offset) internal pure returns (int256) {\\n        int256 value = int256(uint256(word >> offset) & _MASK_22);\\n        // In case the decoded value is greater than the max positive integer that can be represented with 22 bits,\\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\\n        // representation.\\n        return value > _MAX_INT_22 ? (value | int256(~_MASK_22)) : value;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 53 bits signed integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeInt53(bytes32 word, uint256 offset) internal pure returns (int256) {\\n        int256 value = int256(uint256(word >> offset) & _MASK_53);\\n        // In case the decoded value is greater than the max positive integer that can be represented with 53 bits,\\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\\n        // representation.\\n\\n        return value > _MAX_INT_53 ? (value | int256(~_MASK_53)) : value;\\n    }\\n}\\n\",\"keccak256\":\"0x353ed031e949a476fa786fdffbcbb30b289ef432f19d95883b80bd7adaf6f5fa\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/meta/MetaStablePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../StablePool/WordCodec.sol\\\";\\nimport \\\"../OracleMiscData.sol\\\";\\nimport \\\"../StableOracleMath.sol\\\";\\nimport \\\"../../LogCompression.sol\\\";\\nimport \\\"../PoolPriceOracle.sol\\\";\\nimport \\\"../../BasePool/BalancerPoolToken.sol\\\";\\n\\nimport \\\"../StablePool.sol\\\";\\nimport \\\"../IRateProvider.sol\\\";\\n\\n/**\\n * @dev StablePool suitable for assets with proportional prices (i.e. with slow-changing exchange rates between them).\\n * Requires an external feed of these exchange rates.\\n *\\n * It additionally features a price oracle.\\n */\\ncontract MetaStablePool is StablePool, StableOracleMath, PoolPriceOracle {\\n    using WordCodec for bytes32;\\n    using FixedPoint for uint256;\\n    using OracleMiscData for bytes32;\\n\\n    IRateProvider private immutable _rateProvider0;\\n    IRateProvider private immutable _rateProvider1;\\n\\n    // Price rate caches are used to avoid querying the price rate for a token every time we need to work with it.\\n    // Data is stored with the following structure:\\n    //\\n    // [   expires   | duration | price rate value ]\\n    // [   uint64    |  uint64  |      uint128     ]\\n\\n    bytes32 private _priceRateCache0;\\n    bytes32 private _priceRateCache1;\\n\\n    uint256 private constant _PRICE_RATE_CACHE_VALUE_OFFSET = 0;\\n    uint256 private constant _PRICE_RATE_CACHE_DURATION_OFFSET = 128;\\n    uint256 private constant _PRICE_RATE_CACHE_EXPIRES_OFFSET = 128 + 64;\\n\\n    event OracleEnabledChanged(bool enabled);\\n    event PriceRateProviderSet(IERC20 indexed token, IRateProvider indexed provider, uint256 cacheDuration);\\n    event PriceRateCacheUpdated(IERC20 indexed token, uint256 rate);\\n\\n    // The constructor arguments are received in a struct to work around stack-too-deep issues\\n    struct NewPoolParams {\\n        IVault vault;\\n        string name;\\n        string symbol;\\n        IERC20[] tokens;\\n        IRateProvider[] rateProviders;\\n        uint256[] priceRateCacheDuration;\\n        uint256 amplificationParameter;\\n        uint256 swapFeePercentage;\\n        uint256 pauseWindowDuration;\\n        uint256 bufferPeriodDuration;\\n        bool oracleEnabled;\\n        address owner;\\n    }\\n\\n    constructor(NewPoolParams memory params)\\n    StablePool(\\n        params.vault,\\n        params.name,\\n        params.symbol,\\n        params.tokens,\\n        params.amplificationParameter,\\n        params.swapFeePercentage,\\n        params.pauseWindowDuration,\\n        params.bufferPeriodDuration,\\n        params.owner\\n    )\\n    {\\n        _require(params.tokens.length == 2, Errors.NOT_TWO_TOKENS);\\n\\n        InputHelpers.ensureInputLengthMatch(\\n            params.tokens.length,\\n            params.rateProviders.length,\\n            params.priceRateCacheDuration.length\\n        );\\n\\n        // Set providers and initialise cache. We can't use `_setToken0PriceRateCache` as it relies on immutable\\n        // variables, which cannot be read from during construction.\\n\\n        IRateProvider rateProvider0 = params.rateProviders[0];\\n        _rateProvider0 = rateProvider0;\\n        if (rateProvider0 != IRateProvider(address(0))) {\\n            (bytes32 cache, uint256 rate) = _getNewPriceRateCache(rateProvider0, params.priceRateCacheDuration[0]);\\n            _priceRateCache0 = cache;\\n            emit PriceRateCacheUpdated(params.tokens[0], rate);\\n        }\\n        emit PriceRateProviderSet(params.tokens[0], rateProvider0, params.priceRateCacheDuration[0]);\\n\\n        IRateProvider rateProvider1 = params.rateProviders[1];\\n        _rateProvider1 = rateProvider1;\\n        if (rateProvider1 != IRateProvider(address(0))) {\\n            (bytes32 cache, uint256 rate) = _getNewPriceRateCache(rateProvider1, params.priceRateCacheDuration[1]);\\n            _priceRateCache1 = cache;\\n            emit PriceRateCacheUpdated(params.tokens[1], rate);\\n        }\\n        emit PriceRateProviderSet(params.tokens[1], rateProvider1, params.priceRateCacheDuration[1]);\\n\\n        _setOracleEnabled(params.oracleEnabled);\\n    }\\n\\n    // Swap\\n\\n    function onSwap(\\n        SwapRequest memory request,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) public virtual override returns (uint256) {\\n        _cachePriceRatesIfNecessary();\\n        return super.onSwap(request, balances, indexIn, indexOut);\\n    }\\n\\n    function onSwap(\\n        SwapRequest memory request,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    ) public virtual override returns (uint256) {\\n        _cachePriceRatesIfNecessary();\\n        return super.onSwap(request, balanceTokenIn, balanceTokenOut);\\n    }\\n\\n    /**\\n     * Update price oracle with the pre-swap balances\\n     */\\n    function _onSwapGivenIn(\\n        SwapRequest memory request,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) internal virtual override returns (uint256) {\\n        _updateOracle(request.lastChangeBlock, balances[0], balances[1]);\\n        return super._onSwapGivenIn(request, balances, indexIn, indexOut);\\n    }\\n\\n    /**\\n     * Update price oracle with the pre-swap balances\\n     */\\n    function _onSwapGivenOut(\\n        SwapRequest memory request,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) internal virtual override returns (uint256) {\\n        _updateOracle(request.lastChangeBlock, balances[0], balances[1]);\\n        return super._onSwapGivenOut(request, balances, indexIn, indexOut);\\n    }\\n\\n    // Join\\n\\n    /**\\n     * @dev Update cached total supply and invariant using the results after the join that will be used for\\n     * future oracle updates.\\n     * Note this function does not perform any safety checks about joins, it relies on upper implementations for that.\\n     */\\n    function onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) public virtual override returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) {\\n        _cachePriceRatesIfNecessary();\\n\\n        (amountsIn, dueProtocolFeeAmounts) = super.onJoinPool(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            userData\\n        );\\n\\n        _cacheInvariantAndSupply();\\n    }\\n\\n    /**\\n     * @dev Update price oracle with the pre-join balances\\n     */\\n    function _onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n    internal\\n    virtual\\n    override\\n    returns (\\n        uint256,\\n        uint256[] memory,\\n        uint256[] memory\\n    )\\n    {\\n        _updateOracle(lastChangeBlock, balances[0], balances[1]);\\n\\n        return\\n        super._onJoinPool(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            scalingFactors,\\n            userData\\n        );\\n    }\\n\\n    // Exit\\n\\n    /**\\n     * @dev Update cached total supply and invariant using the results after the exit that will be used for\\n     * future oracle updates.\\n     * Note this function does not perform any safety checks about exits, it relies on upper implementations for that.\\n     */\\n    function onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) public virtual override returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) {\\n        _cachePriceRatesIfNecessary();\\n\\n        (amountsOut, dueProtocolFeeAmounts) = super.onExitPool(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            userData\\n        );\\n\\n        // If the contract is paused, the oracle is not updated to avoid extra calculations and reduce potential errors.\\n        if (_isNotPaused()) {\\n            _cacheInvariantAndSupply();\\n        }\\n    }\\n\\n    /**\\n     * @dev Update price oracle with the pre-exit balances\\n     */\\n    function _onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n    internal\\n    virtual\\n    override\\n    returns (\\n        uint256 bptAmountIn,\\n        uint256[] memory amountsOut,\\n        uint256[] memory dueProtocolFeeAmounts\\n    )\\n    {\\n//         If the contract is paused, the oracle is not updated to avoid extra calculations and reduce potential errors.\\n        if (_isNotPaused()) {\\n            _updateOracle(lastChangeBlock, balances[0], balances[1]);\\n        }\\n\\n        return\\n        super._onExitPool(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            scalingFactors,\\n            userData\\n        );\\n    }\\n\\n    // Oracle\\n\\n    function getOracleMiscData()\\n    external\\n    view\\n    returns (\\n        int256 logInvariant,\\n        int256 logTotalSupply,\\n        uint256 oracleSampleCreationTimestamp,\\n        uint256 oracleIndex,\\n        bool oracleEnabled\\n    )\\n    {\\n        bytes32 miscData = _getMiscData();\\n        logInvariant = miscData.logInvariant();\\n        logTotalSupply = miscData.logTotalSupply();\\n        oracleSampleCreationTimestamp = miscData.oracleSampleCreationTimestamp();\\n        oracleIndex = miscData.oracleIndex();\\n        oracleEnabled = miscData.oracleEnabled();\\n    }\\n\\n    /**\\n     * @dev Balancer Governance can always enable the Oracle, even if it was originally not enabled. This allows for\\n     * Pools that unexpectedly drive much more volume and liquidity than expected to serve as Price Oracles.\\n     *\\n     * Note that the Oracle can only be enabled - it can never be disabled.\\n     */\\n    function enableOracle() external whenNotPaused authenticate {\\n        _setOracleEnabled(true);\\n\\n        // Cache log invariant and supply only if the pool was initialized\\n        if (totalSupply() > 0) {\\n            _cacheInvariantAndSupply();\\n        }\\n    }\\n\\n    function _setOracleEnabled(bool enabled) internal {\\n        _setMiscData(_getMiscData().setOracleEnabled(enabled));\\n        emit OracleEnabledChanged(enabled);\\n    }\\n\\n    /**\\n     * @dev Updates the Price Oracle based on the Pool's current state (balances, BPT supply and invariant). Must be\\n     * called on *all* state-changing functions with the balances *before* the state change happens, and with\\n     * `lastChangeBlock` as the number of the block in which any of the balances last changed.\\n     */\\n    function _updateOracle(\\n        uint256 lastChangeBlock,\\n        uint256 balance0,\\n        uint256 balance1\\n    ) internal {\\n        bytes32 miscData = _getMiscData();\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n\\n        if (miscData.oracleEnabled() && block.number > lastChangeBlock) {\\n            (int256 logSpotPrice, int256 logBptPrice) = StableOracleMath._calcLogPrices(\\n                currentAmp,\\n                balance0,\\n                balance1,\\n                miscData.logTotalSupply()\\n            );\\n\\n            uint256 oracleCurrentIndex = miscData.oracleIndex();\\n            uint256 oracleCurrentSampleInitialTimestamp = miscData.oracleSampleCreationTimestamp();\\n            uint256 oracleUpdatedIndex = 1;\\n\\n            if (oracleCurrentIndex != oracleUpdatedIndex) {\\n                // solhint-disable not-rely-on-time\\n                miscData = miscData.setOracleIndex(oracleUpdatedIndex);\\n                miscData = miscData.setOracleSampleCreationTimestamp(block.timestamp);\\n                _setMiscData(miscData);\\n            }\\n        }\\n    }\\n\\n    function updateOracle(\\n        uint256 lastChangeBlock,\\n        uint256 balance0,\\n        uint256 balance1\\n    ) external view returns(int256 logSpotPrice, int256 logBptPrice){\\n        bytes32 miscData = _getMiscData();\\n        (uint256 currentAmp, ) = _getAmplificationParameter();\\n\\n        (int256 logSpotPrice, int256 logBptPrice) = StableOracleMath._calcLogPrices(\\n            currentAmp,\\n            balance0,\\n            balance1,\\n            miscData.logTotalSupply()\\n        );\\n    }\\n\\n    /**\\n     * @dev Stores the logarithm of the invariant and BPT total supply, to be later used in each oracle update. Because\\n     * it is stored in miscData, which is read in all operations (including swaps), this saves gas by not requiring to\\n     * compute or read these values when updating the oracle.\\n     *\\n     * This function must be called by all actions that update the invariant and BPT supply (joins and exits). Swaps\\n     * also alter the invariant due to collected swap fees, but this growth is considered negligible and not accounted\\n     * for.\\n     */\\n    function _cacheInvariantAndSupply() internal {\\n        bytes32 miscData = _getMiscData();\\n        if (miscData.oracleEnabled()) {\\n            miscData = miscData.setLogInvariant(LogCompression.toLowResLog(_lastInvariant));\\n            miscData = miscData.setLogTotalSupply(LogCompression.toLowResLog(totalSupply()));\\n            _setMiscData(miscData);\\n        }\\n    }\\n\\n    function _getOracleIndex() internal view override returns (uint256) {\\n        return _getMiscData().oracleIndex();\\n    }\\n\\n    // Scaling factors\\n\\n    /**\\n     * @dev Overrides scaling factor getter to introduce the token's price rate\\n     * Note that it may update the price rate cache if necessary.\\n     */\\n    function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {\\n        uint256 baseScalingFactor = super._scalingFactor(token);\\n        uint256 priceRate = _priceRate(token);\\n        // Given there is no generic direction for this rounding, it simply follows the same strategy as the BasePool.\\n        return baseScalingFactor.mulDown(priceRate);\\n    }\\n\\n    /**\\n     * @dev Overrides scaling factor getter to introduce the tokens' price rate.\\n     * Note that it may update the price rate cache if necessary.\\n     */\\n    function _scalingFactors() internal view virtual override returns (uint256[] memory scalingFactors) {\\n        // There is no need to check the arrays length since both are based on `_getTotalTokens`\\n        // Given there is no generic direction for this rounding, it simply follows the same strategy as the BasePool.\\n        scalingFactors = super._scalingFactors();\\n        scalingFactors[0] = scalingFactors[0].mulDown(_priceRate(_token0));\\n        scalingFactors[1] = scalingFactors[1].mulDown(_priceRate(_token1));\\n    }\\n\\n    // Price rates\\n\\n    /**\\n     * @dev Returns the rate providers configured for each token (in the same order as registered).\\n     */\\n    function getRateProviders() external view returns (IRateProvider[] memory providers) {\\n        providers = new IRateProvider[](2);\\n        providers[0] = _getRateProvider0();\\n        providers[1] = _getRateProvider1();\\n    }\\n\\n    /**\\n     * @dev Returns the cached value for token's rate\\n     */\\n    function getPriceRateCache(IERC20 token)\\n    external\\n    view\\n    returns (\\n        uint256 rate,\\n        uint256 duration,\\n        uint256 expires\\n    )\\n    {\\n        if (_isToken0(token)) return _getPriceRateCache(_getPriceRateCache0());\\n        if (_isToken1(token)) return _getPriceRateCache(_getPriceRateCache1());\\n        _revert(Errors.INVALID_TOKEN);\\n    }\\n\\n    /**\\n     * @dev Sets a new duration for a token price rate cache. It reverts if there was no rate provider set initially.\\n     * Note this function also updates the current cached value.\\n     * @param duration Number of seconds until the current rate of token price is fetched again.\\n     */\\n    function setPriceRateCacheDuration(IERC20 token, uint256 duration) external authenticate {\\n        if (_isToken0WithRateProvider(token)) {\\n            _updateToken0PriceRateCache(duration);\\n            emit PriceRateProviderSet(token, _getRateProvider0(), duration);\\n        } else if (_isToken1WithRateProvider(token)) {\\n            _updateToken1PriceRateCache(duration);\\n            emit PriceRateProviderSet(token, _getRateProvider1(), duration);\\n        } else {\\n            _revert(Errors.INVALID_TOKEN);\\n        }\\n    }\\n\\n    function updatePriceRateCache(IERC20 token) external {\\n        if (_isToken0WithRateProvider(token)) {\\n            _updateToken0PriceRateCache();\\n        } else if (_isToken1WithRateProvider(token)) {\\n            _updateToken1PriceRateCache();\\n        } else {\\n            _revert(Errors.INVALID_TOKEN);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the price rate for token. All price rates are fixed-point values with 18 decimals.\\n     * In case there is no rate provider for the provided token it returns 1e18.\\n     */\\n    function _priceRate(IERC20 token) internal view virtual returns (uint256) {\\n        // Given that this function is only used by `onSwap` which can only be called by the vault in the case of a\\n        // Meta Stable Pool, we can be sure the vault will not forward a call with an invalid `token` param.\\n        if (_isToken0WithRateProvider(token)) {\\n            return _getPriceRateCacheValue(_getPriceRateCache0());\\n        } else if (_isToken1WithRateProvider(token)) {\\n            return _getPriceRateCacheValue(_getPriceRateCache1());\\n        } else {\\n            return FixedPoint.ONE;\\n        }\\n    }\\n\\n    function _cachePriceRatesIfNecessary() internal {\\n        _cachePriceRate0IfNecessary();\\n        _cachePriceRate1IfNecessary();\\n    }\\n\\n    function _cachePriceRate0IfNecessary() private {\\n        if (_getRateProvider0() != IRateProvider(address(0))) {\\n            (uint256 duration, uint256 expires) = _getPriceRateCacheTimestamps(_getPriceRateCache0());\\n            if (block.timestamp > expires) {\\n                _updateToken0PriceRateCache(duration);\\n            }\\n        }\\n    }\\n\\n    function _cachePriceRate1IfNecessary() private {\\n        if (_getRateProvider1() != IRateProvider(address(0))) {\\n            (uint256 duration, uint256 expires) = _getPriceRateCacheTimestamps(_getPriceRateCache1());\\n            if (block.timestamp > expires) {\\n                _updateToken1PriceRateCache(duration);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Decodes a price rate cache into rate value, duration and expiration time\\n     */\\n    function _getPriceRateCache(bytes32 cache)\\n    private\\n    pure\\n    returns (\\n        uint256 rate,\\n        uint256 duration,\\n        uint256 expires\\n    )\\n    {\\n        rate = _getPriceRateCacheValue(cache);\\n        (duration, expires) = _getPriceRateCacheTimestamps(cache);\\n    }\\n\\n    /**\\n     * @dev Decodes the rate value for a price rate cache\\n     */\\n    function _getPriceRateCacheValue(bytes32 cache) private pure returns (uint256) {\\n        return cache.decodeUint128(_PRICE_RATE_CACHE_VALUE_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Decodes the duration for a price rate cache\\n     */\\n    function _getPriceRateCacheDuration(bytes32 cache) private pure returns (uint256) {\\n        return cache.decodeUint64(_PRICE_RATE_CACHE_DURATION_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Decodes the duration and expiration timestamp for a price rate cache\\n     */\\n    function _getPriceRateCacheTimestamps(bytes32 cache) private pure returns (uint256 duration, uint256 expires) {\\n        duration = _getPriceRateCacheDuration(cache);\\n        expires = cache.decodeUint64(_PRICE_RATE_CACHE_EXPIRES_OFFSET);\\n    }\\n\\n    function _updateToken0PriceRateCache() private {\\n        _updateToken0PriceRateCache(_getPriceRateCacheDuration(_getPriceRateCache0()));\\n    }\\n\\n    function _updateToken0PriceRateCache(uint256 duration) private {\\n        (bytes32 cache, uint256 rate) = _getNewPriceRateCache(_getRateProvider0(), duration);\\n        _setToken0PriceRateCache(cache, rate);\\n    }\\n\\n    function _updateToken1PriceRateCache() private {\\n        _updateToken1PriceRateCache(_getPriceRateCacheDuration(_getPriceRateCache1()));\\n    }\\n\\n    function _updateToken1PriceRateCache(uint256 duration) private {\\n        (bytes32 cache, uint256 rate) = _getNewPriceRateCache(_getRateProvider1(), duration);\\n        _setToken1PriceRateCache(cache, rate);\\n    }\\n\\n    function _setToken0PriceRateCache(bytes32 cache, uint256 rate) private {\\n        _priceRateCache0 = cache;\\n        emit PriceRateCacheUpdated(_token0, rate);\\n    }\\n\\n    function _setToken1PriceRateCache(bytes32 cache, uint256 rate) private {\\n        _priceRateCache1 = cache;\\n        emit PriceRateCacheUpdated(_token1, rate);\\n    }\\n\\n    /**\\n     * @dev Fetches the current price rate from a provider and builds a new price rate cache\\n     */\\n    function _getNewPriceRateCache(IRateProvider provider, uint256 duration)\\n    private\\n    view\\n    returns (bytes32 cache, uint256 rate)\\n    {\\n        rate = provider.getRate();\\n        _require(rate < 2**128, Errors.PRICE_RATE_OVERFLOW);\\n\\n        cache =\\n        WordCodec.encodeUint(uint128(rate), _PRICE_RATE_CACHE_VALUE_OFFSET) |\\n        WordCodec.encodeUint(uint64(duration), _PRICE_RATE_CACHE_DURATION_OFFSET) |\\n        WordCodec.encodeUint(uint64(block.timestamp + duration), _PRICE_RATE_CACHE_EXPIRES_OFFSET);\\n    }\\n\\n    function _isToken0WithRateProvider(IERC20 token) internal view returns (bool) {\\n        return _isToken0(token) && _getRateProvider0() != IRateProvider(address(0));\\n    }\\n\\n    function _isToken1WithRateProvider(IERC20 token) internal view returns (bool) {\\n        return _isToken1(token) && _getRateProvider1() != IRateProvider(address(0));\\n    }\\n\\n    function _getRateProvider0() internal view returns (IRateProvider) {\\n        return _rateProvider0;\\n    }\\n\\n    function _getRateProvider1() internal view returns (IRateProvider) {\\n        return _rateProvider1;\\n    }\\n\\n    function _getPriceRateCache0() internal view returns (bytes32) {\\n        return _priceRateCache0;\\n    }\\n\\n    function _getPriceRateCache1() internal view returns (bytes32) {\\n        return _priceRateCache1;\\n    }\\n}\\n\",\"keccak256\":\"0x9f2b61c0235e43954e0b32b84cb395c6cfb3f3616314a22ccd6abace30a34376\",\"license\":\"GPL-3.0-or-later\"},\"contracts/StablePool/meta/MetaStablePoolFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../vault/IVault.sol\\\";\\n\\nimport \\\"../../BasePool/BasePoolSplitCodeFactory.sol\\\";\\nimport \\\"../../BasePool/FactoryWidePauseWindow.sol\\\";\\n\\nimport \\\"./MetaStablePool.sol\\\";\\n\\ncontract MetaStablePoolFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {\\n    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(MetaStablePool).creationCode) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Deploys a new `MetaStablePool`.\\n     */\\n    function create(\\n        string memory name,\\n        string memory symbol,\\n        IERC20[] memory tokens,\\n        uint256 amplificationParameter,\\n        IRateProvider[] memory rateProviders,\\n        uint256[] memory priceRateCacheDuration,\\n        uint256 swapFeePercentage,\\n        address owner\\n    ) external returns (address) {\\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\\n\\n        return\\n        _create(\\n            abi.encode(\\n                MetaStablePool.NewPoolParams({\\n                    vault: getVault(),\\n                    name: name,\\n                    symbol: symbol,\\n                    tokens: tokens,\\n                    rateProviders: rateProviders,\\n                    priceRateCacheDuration: priceRateCacheDuration,\\n                    amplificationParameter: amplificationParameter,\\n                    swapFeePercentage: swapFeePercentage,\\n                    pauseWindowDuration: pauseWindowDuration,\\n                    bufferPeriodDuration: bufferPeriodDuration,\\n                    oracleEnabled: false,\\n                    owner: owner\\n                })\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x6e3fb0fe654484cfdec83983721d9d2a0f6f012c691231a4275733d52ed0cd28\",\"license\":\"GPL-3.0-or-later\"},\"contracts/misc/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for WETH9.\\n * See https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\\n */\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x927146eb7e703ccd975f90c0880b5c301b8203e06c1455a14c35109c74f2a12d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/ISignaturesValidator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\\n */\\ninterface ISignaturesValidator {\\n    /**\\n     * @dev Returns the EIP712 domain separator.\\n     */\\n    function getDomainSeparator() external view returns (bytes32);\\n\\n    /**\\n     * @dev Returns the next nonce used by an address to sign messages.\\n     */\\n    function getNextNonce(address user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x2fe46b13b7c8bfc6f5c539c0b73d6325813f383f551b71fb6bca8dafd06964e1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/ITemporarilyPausable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface for the TemporarilyPausable helper.\\n */\\ninterface ITemporarilyPausable {\\n    /**\\n     * @dev Emitted every time the pause state changes by `_setPaused`.\\n     */\\n    event PausedStateChanged(bool paused);\\n\\n    /**\\n     * @dev Returns the current paused state.\\n     */\\n    function getPausedState()\\n        external\\n        view\\n        returns (\\n            bool paused,\\n            uint256 pauseWindowEndTime,\\n            uint256 bufferPeriodEndTime\\n        );\\n}\\n\",\"keccak256\":\"0xb3e5b7c63f80b80ef3f0138eac56c397a439bf6b667fc06d5061aa869828b562\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/TemporarilyPausable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"./ITemporarilyPausable.sol\\\";\\n\\n/**\\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\\n * used as an emergency switch in case a security vulnerability or threat is identified.\\n *\\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\\n * analysis later determines there was a false alarm.\\n *\\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\\n *\\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\\n * irreversible.\\n */\\nabstract contract TemporarilyPausable is ITemporarilyPausable {\\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\\n    // solhint-disable not-rely-on-time\\n\\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\\n\\n    uint256 private immutable _pauseWindowEndTime;\\n    uint256 private immutable _bufferPeriodEndTime;\\n\\n    bool private _paused;\\n\\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\\n        _require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, Errors.MAX_PAUSE_WINDOW_DURATION);\\n        _require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, Errors.MAX_BUFFER_PERIOD_DURATION);\\n\\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\\n\\n        _pauseWindowEndTime = pauseWindowEndTime;\\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is paused.\\n     */\\n    modifier whenNotPaused() {\\n        _ensureNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\\n     * Period.\\n     */\\n    function getPausedState()\\n        external\\n        view\\n        override\\n        returns (\\n            bool paused,\\n            uint256 pauseWindowEndTime,\\n            uint256 bufferPeriodEndTime\\n        )\\n    {\\n        paused = !_isNotPaused();\\n        pauseWindowEndTime = _getPauseWindowEndTime();\\n        bufferPeriodEndTime = _getBufferPeriodEndTime();\\n    }\\n\\n    /**\\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\\n     * unpaused until the end of the Buffer Period.\\n     *\\n     * Once the Buffer Period expires, this function reverts unconditionally.\\n     */\\n    function _setPaused(bool paused) internal {\\n        if (paused) {\\n            _require(block.timestamp < _getPauseWindowEndTime(), Errors.PAUSE_WINDOW_EXPIRED);\\n        } else {\\n            _require(block.timestamp < _getBufferPeriodEndTime(), Errors.BUFFER_PERIOD_EXPIRED);\\n        }\\n\\n        _paused = paused;\\n        emit PausedStateChanged(paused);\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is paused.\\n     */\\n    function _ensureNotPaused() internal view {\\n        _require(_isNotPaused(), Errors.PAUSED);\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is unpaused.\\n     *\\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\\n     * longer accessed.\\n     */\\n    function _isNotPaused() internal view returns (bool) {\\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\\n        return block.timestamp > _getBufferPeriodEndTime() || !_paused;\\n    }\\n\\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\\n\\n    function _getPauseWindowEndTime() private view returns (uint256) {\\n        return _pauseWindowEndTime;\\n    }\\n\\n    function _getBufferPeriodEndTime() private view returns (uint256) {\\n        return _bufferPeriodEndTime;\\n    }\\n}\\n\",\"keccak256\":\"0xc35937fdd276677ad42b538f6a12640b7997131bb3f9a7c918e52e6c05aea42b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IAsset.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\\n * types.\\n *\\n * This concept is unrelated to a Pool's Asset Managers.\\n */\\ninterface IAsset {\\n    // solhint-disable-previous-line no-empty-blocks\\n}\\n\",\"keccak256\":\"0x70ecf1d48c285d78718bd2e159345677038ed8a81c74444bedd6a5c61af9aff6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IAuthorizer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IAuthorizer {\\n    /**\\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\\n     */\\n    function canPerform(\\n        bytes32 actionId,\\n        address account,\\n        address where\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x792871e208bba1dad291f8d1cffad86f4afa5e2360816bd9c43481f7297155f5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IBasePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IPoolSwapStructs.sol\\\";\\n\\n/**\\n * @dev Interface for adding and removing liquidity that all Pool contracts should implement. Note that this is not\\n * the complete Pool contract interface, as it is missing the swap hooks. Pool contracts should also inherit from\\n * either IGeneralPool or IMinimalSwapInfoPool\\n */\\ninterface IBasePool is IPoolSwapStructs {\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.joinPool` to add liquidity to this Pool. Returns how many of\\n     * each registered token the user should provide, as well as the amount of protocol fees the Pool owes to the Vault.\\n     * The Vault will then take tokens from `sender` and add them to the Pool's balances, as well as collect\\n     * the reported amount in protocol fees, which the pool should calculate based on `protocolSwapFeePercentage`.\\n     *\\n     * Protocol fees are reported and charged on join events so that the Pool is free of debt whenever new users join.\\n     *\\n     * `sender` is the account performing the join (from which tokens will be withdrawn), and `recipient` is the account\\n     * designated to receive any benefits (typically pool shares). `balances` contains the total balances\\n     * for each token the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\\n     *\\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\\n     * balance.\\n     *\\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\\n     * join (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\\n     *\\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\\n     * state-changing operations, such as minting pool shares.\\n     */\\n    function onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);\\n\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.exitPool` to remove liquidity from this Pool. Returns how many\\n     * tokens the Vault should deduct from the Pool's balances, as well as the amount of protocol fees the Pool owes\\n     * to the Vault. The Vault will then take tokens from the Pool's balances and send them to `recipient`,\\n     * as well as collect the reported amount in protocol fees, which the Pool should calculate based on\\n     * `protocolSwapFeePercentage`.\\n     *\\n     * Protocol fees are charged on exit events to guarantee that users exiting the Pool have paid their share.\\n     *\\n     * `sender` is the account performing the exit (typically the pool shareholder), and `recipient` is the account\\n     * to which the Vault will send the proceeds. `balances` contains the total token balances for each token\\n     * the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\\n     *\\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\\n     * balance.\\n     *\\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\\n     * exit (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\\n     *\\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\\n     * state-changing operations, such as burning pool shares.\\n     */\\n    function onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);\\n\\n    function getPoolId() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xceae7edca5dc3084127b998c4a5b4c8a01e00777484fb19fcc4d5199adc7f826\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IFlashLoanRecipient.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver.\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\ninterface IFlashLoanRecipient {\\n    /**\\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n     *\\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n     * Vault, or else the entire flash loan will revert.\\n     *\\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\\n     */\\n    function receiveFlashLoan(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\",\"keccak256\":\"0xbaa2bc80a63f8ae2d02c8a9c9ba98badc06de673161ec4ca775c14832d511a82\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IPoolSwapStructs.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\n\\ninterface IPoolSwapStructs {\\n    // This is not really an interface - it just defines common structs used by other interfaces: IGeneralPool and\\n    // IMinimalSwapInfoPool.\\n    //\\n    // This data structure represents a request for a token swap, where `kind` indicates the swap type ('given in' or\\n    // 'given out') which indicates whether or not the amount sent by the pool is known.\\n    //\\n    // The pool receives `tokenIn` and sends `tokenOut`. `amount` is the number of `tokenIn` tokens the pool will take\\n    // in, or the number of `tokenOut` tokens the Pool will send out, depending on the given swap `kind`.\\n    //\\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\\n    // some Pools.\\n    //\\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\\n    // one Pool.\\n    //\\n    // The meaning of `lastChangeBlock` depends on the Pool specialization:\\n    //  - Two Token or Minimal Swap Info: the last block in which either `tokenIn` or `tokenOut` changed its total\\n    //    balance.\\n    //  - General: the last block in which *any* of the Pool's registered tokens changed its total balance.\\n    //\\n    // `from` is the origin address for the funds the Pool receives, and `to` is the destination address\\n    // where the Pool sends the outgoing tokens.\\n    //\\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\\n    struct SwapRequest {\\n        IVault.SwapKind kind;\\n        IERC20 tokenIn;\\n        IERC20 tokenOut;\\n        uint256 amount;\\n        // Misc data\\n        bytes32 poolId;\\n        uint256 lastChangeBlock;\\n        address from;\\n        address to;\\n        bytes userData;\\n    }\\n}\\n\",\"keccak256\":\"0x0851d9640a0866ee1722d637a9e4287d1b9f9d65aebd30f86a81ba66ab06c44d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IProtocolFeesCollector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\n\\ninterface IProtocolFeesCollector {\\n    event SwapFeePercentageChanged(uint256 newSwapFeePercentage);\\n    event FlashLoanFeePercentageChanged(uint256 newFlashLoanFeePercentage);\\n\\n    function withdrawCollectedFees(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address recipient\\n    ) external;\\n\\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external;\\n\\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external;\\n\\n    function getSwapFeePercentage() external view returns (uint256);\\n\\n    function getFlashLoanFeePercentage() external view returns (uint256);\\n\\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts);\\n\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    function vault() external view returns (IVault);\\n}\\n\",\"keccak256\":\"0x8a41dc4114e92f979545efb32d3030dce5f4a9c29065b77697be6001de22ff8f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../utils/ISignaturesValidator.sol\\\";\\nimport \\\"../utils/ITemporarilyPausable.sol\\\";\\nimport \\\"../misc/IWETH.sol\\\";\\n\\nimport \\\"./IAsset.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\nimport \\\"./IFlashLoanRecipient.sol\\\";\\nimport \\\"./IProtocolFeesCollector.sol\\\";\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\\n * don't override one of these declarations.\\n */\\ninterface IVault is ISignaturesValidator, ITemporarilyPausable {\\n    // Generalities about the Vault:\\n    //\\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\\n    //\\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\\n    //\\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\\n\\n    // Authorizer\\n    //\\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\\n    // can perform a given action.\\n\\n    /**\\n     * @dev Returns the Vault's Authorizer.\\n     */\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    /**\\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\\n     *\\n     * Emits an `AuthorizerChanged` event.\\n     */\\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\\n\\n    /**\\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\\n     */\\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\\n\\n    // Relayers\\n    //\\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\\n    // this power, two things must occur:\\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\\n    //    functions.\\n    //  - Each user must approve the relayer to act on their behalf.\\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\\n\\n    /**\\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\\n     */\\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\\n\\n    /**\\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\\n     *\\n     * Emits a `RelayerApprovalChanged` event.\\n     */\\n    function setRelayerApproval(\\n        address sender,\\n        address relayer,\\n        bool approved\\n    ) external;\\n\\n    /**\\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\\n     */\\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\\n\\n    // Internal Balance\\n    //\\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n    //\\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n    // operations of different kinds, with different senders and recipients, at once.\\n\\n    /**\\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\\n     */\\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\\n     * it lets integrators reuse a user's Vault allowance.\\n     *\\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n     */\\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\\n\\n    /**\\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\\n     without manual WETH wrapping or unwrapping.\\n     */\\n    struct UserBalanceOp {\\n        UserBalanceOpKind kind;\\n        IAsset asset;\\n        uint256 amount;\\n        address sender;\\n        address payable recipient;\\n    }\\n\\n    // There are four possible operations in `manageUserBalance`:\\n    //\\n    // - DEPOSIT_INTERNAL\\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\\n    // relevant for relayers).\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - WITHDRAW_INTERNAL\\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n    // it to the recipient as ETH.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_INTERNAL\\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_EXTERNAL\\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\\n    // relayers, as it lets them reuse a user's Vault allowance.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `ExternalBalanceTransfer` event.\\n\\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\\n\\n    /**\\n     * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\\n     * interacting with Pools using Internal Balance.\\n     *\\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\\n     * address.\\n     */\\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\\n\\n    /**\\n     * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\\n     */\\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\\n\\n    // Pools\\n    //\\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\\n    // functionality:\\n    //\\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n    // which increase with the number of registered tokens.\\n    //\\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n    // independent of the number of registered tokens.\\n    //\\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\\n\\n    /**\\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\\n     * changed.\\n     *\\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\\n     *\\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\\n     * multiple Pools may share the same contract.\\n     *\\n     * Emits a `PoolRegistered` event.\\n     */\\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n    /**\\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\\n     */\\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\\n\\n    /**\\n     * @dev Returns a Pool's contract address and specialization setting.\\n     */\\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n    /**\\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\\n     * exit by receiving registered tokens, and can only swap registered tokens.\\n     *\\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\\n     * ascending order.\\n     *\\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\\n     * Asset Manager should not be made lightly.\\n     *\\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\\n     * different Asset Manager.\\n     *\\n     * Emits a `TokensRegistered` event.\\n     */\\n    function registerTokens(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        address[] memory assetManagers\\n    ) external;\\n\\n    /**\\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\\n     */\\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\\n\\n    /**\\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\\n     * must be deregistered in the same `deregisterTokens` call.\\n     *\\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\\n     *\\n     * Emits a `TokensDeregistered` event.\\n     */\\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\\n\\n    /**\\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\\n     */\\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\\n\\n    /**\\n     * @dev Returns detailed information for a Pool's registered token.\\n     *\\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\\n     * equals the sum of `cash` and `managed`.\\n     *\\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\\n     * `managed` or `total` balance to be greater than 2^112 - 1.\\n     *\\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\\n     * change for this purpose, and will update `lastChangeBlock`.\\n     *\\n     * `assetManager` is the Pool's token Asset Manager.\\n     */\\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        returns (\\n            uint256 cash,\\n            uint256 managed,\\n            uint256 lastChangeBlock,\\n            address assetManager\\n        );\\n\\n    /**\\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\\n     * the tokens' `balances` changed.\\n     *\\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\\n     *\\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\\n     * order as passed to `registerTokens`.\\n     *\\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\\n     * instead.\\n     */\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (\\n            IERC20[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 lastChangeBlock\\n        );\\n\\n    /**\\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\\n     * Pool shares.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\\n     * these maximums.\\n     *\\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\\n     * back to the caller (not the sender, which is important for relayers).\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\\n     *\\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\\n     * directly to the Pool's contract, as is `recipient`.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external payable;\\n\\n    struct JoinPoolRequest {\\n        IAsset[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n     * `getPoolTokenInfo`).\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n     * it just enforces these minimums.\\n     *\\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\\n     *\\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n     * do so will trigger a revert.\\n     *\\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n     * passed directly to the Pool's contract.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external;\\n\\n    struct ExitPoolRequest {\\n        IAsset[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\\n     */\\n    event PoolBalanceChanged(\\n        bytes32 indexed poolId,\\n        address indexed liquidityProvider,\\n        IERC20[] tokens,\\n        int256[] deltas,\\n        uint256[] protocolFeeAmounts\\n    );\\n\\n    enum PoolBalanceChangeKind { JOIN, EXIT }\\n\\n    // Swaps\\n    //\\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n    //\\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n    // individual swaps.\\n    //\\n    // There are two swap kinds:\\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n    //\\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n    // the final intended token.\\n    //\\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n    // much less gas than they would otherwise.\\n    //\\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n    // updating the Pool's internal accounting).\\n    //\\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\\n    //\\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n    //\\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n    //\\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\\n\\n    /**\\n     * @dev Performs a swap with a single Pool.\\n     *\\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n     * taken from the Pool, which must be greater than or equal to `limit`.\\n     *\\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n     * sent to the Pool, which must be less than or equal to `limit`.\\n     *\\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\\n     *\\n     * Emits a `Swap` event.\\n     */\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n     * the `kind` value.\\n     *\\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        IAsset assetIn;\\n        IAsset assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\\n     *\\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\\n     * the same index in the `assets` array.\\n     *\\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n     * `amountOut` depending on the swap kind.\\n     *\\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\\n     *\\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\\n     * or unwrapped from WETH by the Vault.\\n     *\\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\\n     *\\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n     * equivalent `swap` call.\\n     *\\n     * Emits `Swap` events.\\n     */\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    ) external payable returns (int256[] memory);\\n\\n    /**\\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\\n     *\\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n     * from the previous swap, depending on the swap kind.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\\n     */\\n    event Swap(\\n        bytes32 indexed poolId,\\n        IERC20 indexed tokenIn,\\n        IERC20 indexed tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n\\n    /**\\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n     * `recipient` account.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *\\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     *\\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n     * revert.\\n     */\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\\n     *\\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\\n     * receives are the same that an equivalent `batchSwap` call would receive.\\n     *\\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\\n     * approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n    function queryBatchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds\\n    ) external returns (int256[] memory assetDeltas);\\n\\n    // Flash Loans\\n\\n    /**\\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\\n     *\\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\\n     * for each token contract. `tokens` must be sorted in ascending order.\\n     *\\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\\n     * `receiveFlashLoan` call.\\n     *\\n     * Emits `FlashLoan` events.\\n     */\\n    function flashLoan(\\n        IFlashLoanRecipient recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external;\\n\\n    /**\\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\\n     */\\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\\n\\n    // Asset Management\\n    //\\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\\n    //\\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\\n    //\\n    // This concept is unrelated to the IAsset interface.\\n\\n    /**\\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\\n     *\\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\\n     * operations of different kinds, with different Pools and tokens, at once.\\n     *\\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\\n     */\\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\\n\\n    struct PoolBalanceOp {\\n        PoolBalanceOpKind kind;\\n        bytes32 poolId;\\n        IERC20 token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\\n     *\\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\\n     *\\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\\n     */\\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\\n\\n    /**\\n     * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\\n     */\\n    event PoolBalanceManaged(\\n        bytes32 indexed poolId,\\n        address indexed assetManager,\\n        IERC20 indexed token,\\n        int256 cashDelta,\\n        int256 managedDelta\\n    );\\n\\n    // Protocol Fees\\n    //\\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\\n    // permissioned accounts.\\n    //\\n    // There are two kinds of protocol fees:\\n    //\\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\\n    //\\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\\n    // exiting a Pool in debt without first paying their share.\\n\\n    /**\\n     * @dev Returns the current protocol fee module.\\n     */\\n    function getProtocolFeesCollector() external view returns (IProtocolFeesCollector);\\n\\n    /**\\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\\n     * error in some part of the system.\\n     *\\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\\n     *\\n     * While the contract is paused, the following features are disabled:\\n     * - depositing and transferring internal balance\\n     * - transferring external balance (using the Vault's allowance)\\n     * - swaps\\n     * - joining Pools\\n     * - Asset Manager interactions\\n     *\\n     * Internal Balance can still be withdrawn, and Pools exited.\\n     */\\n    function setPaused(bool paused) external;\\n\\n    /**\\n     * @dev Returns the Vault's WETH instance.\\n     */\\n    function WETH() external view returns (IWETH);\\n    // solhint-disable-previous-line func-name-mixedcase\\n}\\n\",\"keccak256\":\"0xc54f6b798844fbe0e7ab737dcac04ff86f0522d1e7c89871c58f401ca88c3f55\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x6101406040523480156200001257600080fd5b5060405162008137380380620081378339810160408190526200003591620001c3565b80604051806020016200004890620001b5565b601f1982820381018352601f909101166040528051819060006002820460a081905280830360e0819052818552909150836200009081620000f9602090811b620003b517901c565b60601b6001600160601b0319166080528285018051838252620000bf82620000f9602090811b620003b517901c565b6001600160601b0319606091821b811660c0529690935290529590951b90911661010052505050426276a700016101205250620001f39050565b80517f602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe808352600091602081018484f09084529150620001476001600160a01b03831615156101ac6200014d565b50919050565b816200015e576200015e8162000162565b5050565b62461bcd60e51b6000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b6173d88062000d5f83390190565b600060208284031215620001d5578081fd5b81516001600160a01b0381168114620001ec578182fd5b9392505050565b60805160601c60a05160c05160601c60e0516101005160601c61012051610b0a620002556000398061018152806101aa5250806103935250806102c0525080610158528061033c5250806102e152508061013752806103185250610b0a6000f3fe608060405234801561001057600080fd5b506004361061006c5760003560e01c8062c194db14610071578063174481fa1461008f5780632da47c40146100a55780634555fb8d146100bb5780636634b753146100db57806374cc23da146100fb5780638d928af81461010e575b600080fd5b610079610116565b6040516100869190610949565b60405180910390f35b610097610135565b604051610086929190610924565b6100ad61017b565b604051610086929190610a69565b6100ce6100c9366004610750565b6101e5565b6040516100869190610910565b6100ee6100e93660046106fa565b61029a565b604051610086919061093e565b610079610109366004610716565b6102b8565b6100ce610391565b6060610130604051806020016040528060008152506102b8565b905090565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000009091565b600080427f00000000000000000000000000000000000000000000000000000000000000008110156101d757807f000000000000000000000000000000000000000000000000000000000000000003925062278d0091506101e0565b60009250600091505b509091565b60008060006101f261017b565b9150915061028b60405180610180016040528061020d610391565b6001600160a01b031681526020018d81526020018c81526020018b81526020018981526020018881526020018a8152602001878152602001848152602001838152602001600015158152602001866001600160a01b0316815250604051602001610277919061095c565b604051602081830303815290604052610407565b9b9a5050505050505050505050565b6001600160a01b031660009081526020819052604090205460ff1690565b8051604080517f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000818101858101848101602090810190965280855293957f00000000000000000000000000000000000000000000000000000000000000009592947f000000000000000000000000000000000000000000000000000000000000000094938801866000828a3c846000888301883c5060208981019089850101610383818386610467565b505050505050505050919050565b7f000000000000000000000000000000000000000000000000000000000000000090565b80517f602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe808352600091602081018484f090845291506104016001600160a01b03831615156101ac6104a5565b50919050565b600080610413836104b7565b6001600160a01b038116600081815260208190526040808220805460ff191660011790555192935090917f83a48fbcfc991335314e74d0496aab6a1987e992ddc85dddbcc4d6dd6ef2e9fc9190a292915050565b5b60208110610487578151835260209283019290910190601f1901610468565b905182516020929092036101000a6000190180199091169116179052565b816104b3576104b3816104f2565b5050565b600060606104c4836102b8565b905060008151602083016000f090506001600160a01b0381166104eb573d6000803e3d6000fd5b9392505050565b62461bcd60e51b6000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b803561055081610abc565b92915050565b600082601f830112610566578081fd5b813561057961057482610a9d565b610a77565b81815291506020808301908481018184028601820187101561059a57600080fd5b60005b848110156105c25781356105b081610abc565b8452928201929082019060010161059d565b505050505092915050565b600082601f8301126105dd578081fd5b81356105eb61057482610a9d565b81815291506020808301908481018184028601820187101561060c57600080fd5b60005b848110156105c257813561062281610abc565b8452928201929082019060010161060f565b600082601f830112610644578081fd5b813561065261057482610a9d565b81815291506020808301908481018184028601820187101561067357600080fd5b60005b848110156105c257813584529282019290820190600101610676565b600082601f8301126106a2578081fd5b81356001600160401b038111156106b7578182fd5b6106ca601f8201601f1916602001610a77565b91508082528360208285010111156106e157600080fd5b8060208401602084013760009082016020015292915050565b60006020828403121561070b578081fd5b81356104eb81610abc565b600060208284031215610727578081fd5b81356001600160401b0381111561073c578182fd5b61074884828501610692565b949350505050565b600080600080600080600080610100898b03121561076c578384fd5b88356001600160401b0380821115610782578586fd5b61078e8c838d01610692565b995060208b01359150808211156107a3578586fd5b6107af8c838d01610692565b985060408b01359150808211156107c4578586fd5b6107d08c838d01610556565b975060608b0135965060808b01359150808211156107ec578586fd5b6107f88c838d016105cd565b955060a08b013591508082111561080d578485fd5b5061081a8b828c01610634565b93505060c089013591506108318a60e08b01610545565b90509295985092959890939650565b6001600160a01b03169052565b6000815180845260208085019450808401835b838110156108855781516001600160a01b031687529582019590820190600101610860565b509495945050505050565b6000815180845260208085019450808401835b83811015610885578151875295820195908201906001016108a3565b15159052565b60008151808452815b818110156108ea576020818501810151868301820152016108ce565b818111156108fb5782602083870101525b50601f01601f19169290920160200192915050565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b901515815260200190565b6000602082526104eb60208301846108c5565b600060208252610970602083018451610840565b602083015161018080604085015261098c6101a08501836108c5565b91506040850151601f19808685030160608701526109aa84836108c5565b935060608701519150808685030160808701526109c7848361084d565b935060808701519150808685030160a08701526109e4848361084d565b935060a08701519150808685030160c087015250610a028382610890565b60c087015160e0878101919091528701516101008088019190915287015161012080880191909152870151610140808801919091528701519093509050610160610a4e818701836108bf565b8601519050610a5f85830182610840565b5090949350505050565b918252602082015260400190565b6040518181016001600160401b0381118282101715610a9557600080fd5b604052919050565b60006001600160401b03821115610ab2578081fd5b5060209081020190565b6001600160a01b0381168114610ad157600080fd5b5056fea26469706673582212202906fc86ea766e4a02eaf64d82594e2fb43d8aa1e2c995192a5a2a414664147d64736f6c634300070100336103606040527f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9610120523480156200003757600080fd5b50604051620073d8380380620073d88339810160408190526200005a91620010a1565b805160208201516040830151606084015160c085015160e0860151610100870151610120880151610160890151855189906002146200009b5760006200009e565b60025b8989898a516001600160401b0381118015620000b957600080fd5b50604051908082528060200260200182016040528015620000e4578160200160208202803683370190505b5089898989828289898d8280604051806040016040528060018152602001603160f81b81525085858a336001600160a01b031660001b806080818152505050806001600160a01b031660a0816001600160a01b031660601b815250505081600390805190602001906200015992919062000de9565b5080516200016f90600490602084019062000de9565b505060058054601260ff1990911617905550815160209283012060c052805191012060e052507f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6101005260601b6001600160601b0319166101405250620001e290506276a7008311156101946200084b565b620001f662278d008211156101956200084b565b429091016101608190520161018052855162000218906002111560c86200084b565b620002326200022662000860565b8751111560c96200084b565b62000248866200086560201b620014061760201c565b620002538462000871565b6040516309b2760f60e01b81526000906001600160a01b038c16906309b2760f9062000284908d90600401620012e7565b602060405180830381600087803b1580156200029f57600080fd5b505af1158015620002b4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620002da919062001088565b604051633354e3e960e11b81529091506001600160a01b038c16906366a9c7d2906200030f9084908b908b906004016200124b565b600060405180830381600087803b1580156200032a57600080fd5b505af11580156200033f573d6000803e3d6000fd5b5050506101a091909152506200036a9950505060018d1015965061012c9550506200084b9350505050565b6200037d61138886111561012d6200084b565b85516101c0819052865187906000906200039357fe5b60200260200101516001600160a01b03166101e0816001600160a01b031660601b8152505086600181518110620003c657fe5b60200260200101516001600160a01b0316610200816001600160a01b031660601b8152505060028111620003fc57600062000413565b866002815181106200040a57fe5b60200260200101515b60601b6001600160601b0319166102205260038111620004355760006200044c565b866003815181106200044357fe5b60200260200101515b60601b6001600160601b03191661024052600481116200046e57600062000485565b866004815181106200047c57fe5b60200260200101515b6001600160a01b0316610260816001600160a01b031660601b81525050620004c887600081518110620004b457fe5b6020026020010151620008fd60201b60201c565b610280528651620004e19088906001908110620004b457fe5b6102a05260028111620004f657600062000508565b6200050887600281518110620004b457fe5b6102c052600381116200051d5760006200052f565b6200052f87600381518110620004b457fe5b6102e052600481116200054457600062000556565b6200055687600481518110620004b457fe5b6103008181525050600062000579876103e8620009d160201b620014101760201c565b9050620005868162000a02565b5050505050505050505050620005ac81606001515160021460d26200084b60201b60201c565b620005d38160600151518260800151518360a001515162000a4160201b620014341760201c565b60008160800151600081518110620005e757fe5b60209081029190910101516001600160601b0319606082901b166103205290506001600160a01b038116156200069e5760008062000645838560a001516000815181106200063157fe5b602002602001015162000a6160201b60201c565b9150915081600d8190555083606001516000815181106200066257fe5b60200260200101516001600160a01b03166000805160206200739883398151915282604051620006939190620012fc565b60405180910390a250505b806001600160a01b03168260600151600081518110620006ba57fe5b60200260200101516001600160a01b0316600080516020620073b88339815191528460a00151600081518110620006ed57fe5b6020026020010151604051620007049190620012fc565b60405180910390a3600082608001516001815181106200072057fe5b60209081029190910101516001600160601b0319606082901b166103405290506001600160a01b03811615620007c3576000806200076a838660a001516001815181106200063157fe5b9150915081600e8190555084606001516001815181106200078757fe5b60200260200101516001600160a01b03166000805160206200739883398151915282604051620007b89190620012fc565b60405180910390a250505b806001600160a01b03168360600151600181518110620007df57fe5b60200260200101516001600160a01b0316600080516020620073b88339815191528560a001516001815181106200081257fe5b6020026020010151604051620008299190620012fc565b60405180910390a3610140830151620008429062000b5f565b5050506200136e565b816200085c576200085c8162000bbd565b5050565b600590565b806200085c8162000c10565b6200088664e8d4a5100082101560cb6200084b565b6200089e67016345785d8a000082111560ca6200084b565b620008bd8160c060085462000c9a60201b62001451179092919060201c565b6008556040517fa9ba3ffe0b6c366b81232caab38605a0699ad5398d6cce76f91ee809e322dafc90620008f2908390620012fc565b60405180910390a150565b60006001600160a01b038216301415620009215750670de0b6b3a7640000620009cc565b6000826001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b1580156200095d57600080fd5b505afa15801562000972573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200099891906200121d565b60ff1690506000620009b760128362000caf60201b620014661760201c565b905080600a0a670de0b6b3a764000002925050505b919050565b6000828202620009f9841580620009f1575083858381620009ee57fe5b04145b60036200084b565b90505b92915050565b62000a108180428062000cc7565b7fa0d01593e47e69d07e0ccd87bece09411e07dd1ed40ca8f2e7af2976542a023381604051620008f29190620012fc565b62000a5c828414801562000a5457508183145b60676200084b565b505050565b600080836001600160a01b031663679aefce6040518163ffffffff1660e01b815260040160206040518083038186803b15801562000a9e57600080fd5b505afa15801562000ab3573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000ad9919062001088565b905062000aef600160801b82106101496200084b565b62000b128342016001600160401b031660c062000d5760201b6200147c1760201c565b62000b33846001600160401b0316608062000d5760201b6200147c1760201c565b62000b54836001600160801b0316600062000d5760201b6200147c1760201c565b171791509250929050565b62000b8c62000b868262000b7262000d5b565b62000d6160201b620014801790919060201c565b62000d80565b7f3e350b41e86a8e10f804ade6d35340d620be35569cc75ac943e8bb14ab80ead181604051620008f2919062001240565b62461bcd60e51b6000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b60028151101562000c215762000c97565b60008160008151811062000c3157fe5b602002602001015190506000600190505b825181101562000a5c57600083828151811062000c5b57fe5b6020026020010151905062000c8c816001600160a01b0316846001600160a01b03161060656200084b60201b60201c565b915060010162000c42565b50565b6001600160401b03811b1992909216911b1790565b600062000cc18383111560016200084b565b50900390565b62000ce8816001600160401b031660c062000d5760201b6200147c1760201c565b62000d09836001600160401b0316608062000d5760201b6200147c1760201c565b62000d2a856001600160401b0316604062000d5760201b6200147c1760201c565b62000d4b876001600160401b0316600062000d5760201b6200147c1760201c565b17171760095550505050565b1b90565b60085490565b6000620009f98260558562000da560201b6200148a179092919060201c565b62000d9f81600060085462000dce60201b620014b1179092919060201c565b60085550565b60006001821b198416828462000dbd57600062000dc0565b60015b60ff16901b17949350505050565b6001600160c01b03828116821b90821b198416179392505050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1062000e2c57805160ff191683800117855562000e5c565b8280016001018555821562000e5c579182015b8281111562000e5c57825182559160200191906001019062000e3f565b5062000e6a92915062000e6e565b5090565b5b8082111562000e6a576000815560010162000e6f565b8051620009fc8162001358565b600082601f83011262000ea3578081fd5b815162000eba62000eb4826200132c565b62001305565b81815291506020808301908481018184028601820187101562000edc57600080fd5b60005b8481101562000f0857815162000ef58162001358565b8452928201929082019060010162000edf565b505050505092915050565b600082601f83011262000f24578081fd5b815162000f3562000eb4826200132c565b81815291506020808301908481018184028601820187101562000f5757600080fd5b60005b8481101562000f0857815162000f708162001358565b8452928201929082019060010162000f5a565b600082601f83011262000f94578081fd5b815162000fa562000eb4826200132c565b81815291506020808301908481018184028601820187101562000fc757600080fd5b60005b8481101562000f085781518452928201929082019060010162000fca565b80518015158114620009fc57600080fd5b600082601f8301126200100a578081fd5b81516001600160401b0381111562001020578182fd5b602062001036601f8301601f1916820162001305565b925081835284818386010111156200104d57600080fd5b60005b828110156200106d57848101820151848201830152810162001050565b828111156200107f5760008284860101525b50505092915050565b6000602082840312156200109a578081fd5b5051919050565b600060208284031215620010b3578081fd5b81516001600160401b0380821115620010ca578283fd5b8184019150610180808387031215620010e1578384fd5b620010ec8162001305565b9050620010fa868462000e85565b81526020830151828111156200110e578485fd5b6200111c8782860162000ff9565b60208301525060408301518281111562001134578485fd5b620011428782860162000ff9565b6040830152506060830151828111156200115a578485fd5b620011688782860162000e92565b60608301525060808301518281111562001180578485fd5b6200118e8782860162000f13565b60808301525060a083015182811115620011a6578485fd5b620011b48782860162000f83565b60a08301525060c0838101519082015260e08084015190820152610100808401519082015261012080840151908201526101409150620011f78683850162000fe8565b8282015261016091506200120e8683850162000e85565b91810191909152949350505050565b6000602082840312156200122f578081fd5b815160ff81168114620009f9578182fd5b901515815260200190565b60006060820185835260206060818501528186518084526080860191508288019350845b8181101562001297576200128485516200134c565b835293830193918301916001016200126f565b505084810360408601528551808252908201925081860190845b81811015620012d957620012c683516200134c565b85529383019391830191600101620012b1565b509298975050505050505050565b6020810160038310620012f657fe5b91905290565b90815260200190565b6040518181016001600160401b03811182821017156200132457600080fd5b604052919050565b60006001600160401b0382111562001342578081fd5b5060209081020190565b6001600160a01b031690565b6001600160a01b038116811462000c9757600080fd5b60805160a05160601c60c05160e05161010051610120516101405160601c61016051610180516101a0516101c0516101e05160601c6102005160601c6102205160601c6102405160601c6102605160601c610280516102a0516102c0516102e051610300516103205160601c6103405160601c615f07620014916000398061183a52508061181652508061362a5250806136065250806135e25250806135be52508061359a525080613ad2525080613a90525080613a4e525080611781528061266a5280613310525080611719528061260f52806132b6525080611dfc525080610b7c5250806116d15250806116ad525080610f4d525080611249525080611b50525080611b92525080611b71525080610f29525080610eb35250615f076000f3fe608060405234801561001057600080fd5b50600436106102515760003560e01c806301ec954a1461025657806306fdde031461027f578063095ea7b31461029457806316c38b3c146102b457806318160ddd146102c95780631c0de051146102d15780631dccd830146102e85780631dd746ea146103085780631ed4eddc14610310578063238a2d591461032957806323b872dd1461033e578063292c914a146103515780632f1a0bc914610359578063313ce5671461036c5780633331bc36146103815780633644e5151461039457806338e9922e1461039c57806338fff2d0146103af57806339509351146103b757806340c10f19146103ca57806350dd6ed9146103dd57806355c67628146103f05780636028bfd4146103f857806360d1507c14610419578063679aefce1461043f5780636b843239146104475780636daccffa1461046757806370a082311461047e57806374f3b009146104915780637ecebe00146104b2578063851c1bb3146104c557806387ec6817146104d8578063893d20e8146104eb5780638d928af81461050057806395d89b41146105085780639b02cdde146105105780639d2c110c14610526578063a0daaed014610539578063a457c2d71461054c578063a9059cbb1461055f578063aaabadc514610572578063b10be7391461057a578063b48b5b401461058d578063b771025114610595578063b867ee5a146105a8578063d505accf146105ca578063d5c096c4146105dd578063dd62ed3e146105f0578063eb0f24d614610603578063f30d74a31461060b578063ffd088eb1461061e575b600080fd5b6102696102643660046158b5565b610626565b6040516102769190615bd0565b60405180910390f35b610287610647565b6040516102769190615d91565b6102a76102a236600461539f565b6106de565b6040516102769190615bad565b6102c76102c236600461560d565b6106f5565b005b610269610709565b6102d961070f565b60405161027693929190615bb8565b6102fb6102f6366004615553565b610738565b6040516102769190615b75565b6102fb61085b565b61031861086a565b604051610276959493929190615ce4565b6103316108bc565b6040516102769190615af0565b6102a761034c3660046152ea565b610949565b6102c76109bf565b6102c7610367366004615988565b6109f3565b610374610ad6565b6040516102769190615e04565b6102c761038f366004615988565b610adf565b610269610b57565b6102c76103aa366004615970565b610b61565b610269610b7a565b6102a76103c536600461539f565b610b9e565b6102c76103d836600461539f565b610bd9565b6102c76103eb36600461572b565b610be7565b610269610c01565b61040b610406366004615645565b610c12565b604051610276929190615da4565b61042c610427366004615970565b610c49565b6040516102769796959493929190615cb4565b610269610c92565b61045a610455366004615495565b610d70565b6040516102769190615b3d565b61046f610e26565b60405161027693929190615dbd565b61026961048c366004615296565b610e41565b6104a461049f366004615645565b610e60565b604051610276929190615b88565b6102696104c0366004615296565b610e94565b6102696104d33660046156e7565b610eaf565b61040b6104e6366004615645565b610f01565b6104f3610f27565b6040516102769190615adc565b6104f3610f4b565b610287610f6f565b610518610fd0565b604051610276929190615ca6565b610269610534366004615925565b610fda565b6102c7610547366004615296565b610fef565b6102a761055a36600461539f565b61102b565b6102a761056d36600461539f565b611069565b6104f3611076565b610269610588366004615881565b611080565b610269611115565b6102c76105a336600461539f565b61111b565b6105bb6105b6366004615296565b6111bb565b60405161027693929190615dd3565b6102c76105d836600461532a565b611214565b6104a46105eb366004615645565b61135d565b6102696105fe3660046152b2565b611384565b6102c7611390565b6105186106193660046159a9565b6113bc565b6102696113ff565b60006106306114cc565b61063c858585856114dc565b90505b949350505050565b60038054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156106d35780601f106106a8576101008083540402835291602001916106d3565b820191906000526020600020905b8154815290600101906020018083116106b657829003601f168201915b505050505090505b90565b60006106eb33848461157a565b5060015b92915050565b6106fd6115e2565b61070681611610565b50565b60025490565b600080600061071c61168e565b1592506107276116ab565b91506107316116cf565b9050909192565b606081516001600160401b038111801561075157600080fd5b5060405190808252806020026020018201604052801561077b578160200160208202803683370190505b50905060006107886116f3565b905060005b83518110156108545773D268a45eC914B3AC19e3fE34577c074B1D9Fbc1E6379eaef82600c8684815181106107be57fe5b6020026020010151856040518463ffffffff1660e01b81526004016107e593929190615d55565b60206040518083038186803b1580156107fd57600080fd5b505af4158015610811573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610835919061589d565b83828151811061084157fe5b602090810291909101015260010161078d565b5050919050565b6060610865611705565b905090565b60008060008060008061087b6117ce565b9050610886816117d4565b9550610891816117e0565b945061089c816117ed565b93506108a7816117fa565b92506108b281611807565b9150509091929394565b60408051600280825260608083018452926020830190803683370190505090506108e4611814565b816000815181106108f157fe5b60200260200101906001600160a01b031690816001600160a01b031681525050610919611838565b8160018151811061092657fe5b60200260200101906001600160a01b031690816001600160a01b03168152505090565b6000806109568533611384565b905061097a336001600160a01b03871614806109725750838210155b61019e61185c565b61098585858561186a565b336001600160a01b038616148015906109a057506000198114155b156109b2576109b2853385840361157a565b60019150505b9392505050565b6109c7611938565b6109cf6115e2565b6109d9600161194b565b60006109e3610709565b11156109f1576109f1611994565b565b6109fb6115e2565b610a0b600183101561012c61185c565b610a1c61138883111561012d61185c565b6000610a288242611466565b9050610a3c6201518082101561013d61185c565b600080610a476119ea565b91509150610a58811561013e61185c565b6000610a66866103e8611410565b90506000838211610a9557610a90610a816201518086611410565b610a8b8488611410565b611a5e565b610aaf565b610aaf610aa56201518084611410565b610a8b8688611410565b9050610ac1600282111561013f61185c565b610acd84834289611a91565b50505050505050565b60055460ff1690565b610afa8183108015610af357506104008211155b606461185c565b6000610b0f6001600080600080600080611ae0565b9050825b82811015610b51576000818152600c6020526040902054610b3390611b40565b610b49576000818152600c602052604090208290555b600101610b13565b50505050565b6000610865611b4c565b610b696115e2565b610b71611938565b61070681611be9565b7f000000000000000000000000000000000000000000000000000000000000000090565b3360008181526001602090815260408083206001600160a01b038716845290915281205490916106eb918590610bd49086611c54565b61157a565b610be38282611c66565b5050565b610bef6115e2565b610bf7611938565b610be38282611cee565b6008546000906108659060c0611ded565b60006060610c288651610c23611dfa565b611e1e565b610c3d89898989898989611e2b611e95611ef6565b97509795505050505050565b6000806000806000806000610c64610400891061013b61185c565b6000610c6f89612019565b9050610c7a8161202b565b959f949e50929c50909a509850965090945092505050565b60006060610c9e610f4b565b6001600160a01b031663f94d4668610cb4610b7a565b6040518263ffffffff1660e01b8152600401610cd09190615bd0565b60006040518083038186803b158015610ce857600080fd5b505afa158015610cfc573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d2491908101906153ca565b509150506000610d326119ea565b509050610d4682610d41611705565b61208e565b6000610d54828460006120ef565b9050610d68610d61610709565b8290612149565b935050505090565b606081516001600160401b0381118015610d8957600080fd5b50604051908082528060200260200182016040528015610db3578160200160208202803683370190505b5090506000610dc06116f3565b9050610dca615062565b60005b8451811015610e1e57848181518110610de257fe5b60200260200101519150610dff826000015184846020015161219a565b848281518110610e0b57fe5b6020908102919091010152600101610dcd565b505050919050565b6000806000610e336119ea565b90949093506103e892509050565b6001600160a01b0381166000908152602081905260409020545b919050565b606080610e6b6114cc565b610e7a8989898989898961222b565b9092509050610e8761168e565b15610c3d57610c3d611994565b6001600160a01b031660009081526006602052604090205490565b60007f000000000000000000000000000000000000000000000000000000000000000082604051602001610ee4929190615a99565b604051602081830303815290604052805190602001209050919050565b60006060610f128651610c23611dfa565b610c3d898989898989896122a96122cf611ef6565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b60048054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156106d35780601f106106a8576101008083540402835291602001916106d3565b600a54600b549091565b6000610fe46114cc565b61063f848484612330565b610ff88161248e565b1561100a576110056124bb565b610706565b611013816124d3565b15611020576110056124ef565b610706610135612502565b6000806110383385611384565b90508083106110525761104d3385600061157a565b61105f565b61105f338585840361157a565b5060019392505050565b60006106eb33848461186a565b6000610865612555565b600073D268a45eC914B3AC19e3fE34577c074B1D9Fbc1E630397bee0600c846110a76116f3565b6040518463ffffffff1660e01b81526004016110c593929190615d09565b60206040518083038186803b1580156110dd57600080fd5b505af41580156110f1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ef919061589d565b61040090565b6111236115e2565b61112c8261248e565b156111915761113a816125cf565b611142611814565b6001600160a01b0316826001600160a01b03167fca6c2c5b6b44b5f3f0c08f0e28e5b6deda1cb38c3fe1113e8031d926c1e8c6d0836040516111849190615bd0565b60405180910390a3610be3565b61119a826124d3565b156111b0576111a8816125f1565b611142611838565b610be3610135612502565b60008060006111c98461260d565b156111e9576111de6111d961263f565b612645565b92509250925061120d565b6111f284612668565b15611202576111de6111d961269a565b61120d610135612502565b9193909250565b6112228442111560d161185c565b6001600160a01b0387166000908152600660209081526040808320549051909291611279917f0000000000000000000000000000000000000000000000000000000000000000918c918c918c9188918d9101615bf8565b604051602081830303815290604052805190602001209050600061129c826126a0565b90506000600182888888604051600081526020016040526040516112c39493929190615c88565b6020604051602081039080840390855afa1580156112e5573d6000803e3d6000fd5b5050604051601f190151915061132790506001600160a01b0382161580159061131f57508b6001600160a01b0316826001600160a01b0316145b6101f861185c565b6001600160a01b038b1660009081526006602052604090206001850190556113508b8b8b61157a565b5050505050505050505050565b6060806113686114cc565b611377898989898989896126bc565b9092509050610c3d611994565b60006109b883836127e7565b6113986115e2565b6000806113a36119ea565b915091506113b38161014061185c565b610be382612812565b60008060006113c96117ce565b905060006113d56119ea565b5090506000806113ef8389896113ea886117e0565b61284d565b9150915050505050935093915050565b6201de2090565b80610be381612882565b60008282026109b884158061142d57508385838161142a57fe5b04145b600361185c565b61144c828414801561144557508183145b606761185c565b505050565b6001600160401b03811b1992909216911b1790565b600061147683831115600161185c565b50900390565b1b90565b60006109b8838360555b60006001821b19841682846114a05760006114a3565b60015b60ff16901b17949350505050565b6001600160c01b03828116821b90821b198416179392505050565b6114d46128fb565b6109f161293b565b600084608001516115096114ee610f4b565b6001600160a01b0316336001600160a01b03161460cd61185c565b61151e611514610b7a565b82146101f461185c565b611530848461152b611dfa565b612976565b606061153a611705565b905060008751600181111561154b57fe5b146115625761155d878787878561298d565b61156f565b61156f8787878785612a04565b979650505050505050565b6001600160a01b0380841660008181526001602090815260408083209487168084529490915290819020849055517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925906115d5908590615bd0565b60405180910390a3505050565b60006115f96000356001600160e01b031916610eaf565b90506107066116088233612a68565b61019161185c565b80156116305761162b6116216116ab565b421061019361185c565b611645565b61164561163b6116cf565b42106101a961185c565b6007805460ff19168215151790556040517f9e3a5e37224532dea67b89face185703738a228a6e8a23dee546960180d3be6490611683908390615bad565b60405180910390a150565b60006116986116cf565b42118061086557505060075460ff161590565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b60006108656117006117ce565b6117fa565b606061170f612b58565b905061176061173d7f0000000000000000000000000000000000000000000000000000000000000000612c7f565b8260008151811061174a57fe5b6020026020010151612cce90919063ffffffff16565b8160008151811061176d57fe5b6020026020010181815250506117b26117a57f0000000000000000000000000000000000000000000000000000000000000000612c7f565b8260018151811061174a57fe5b816001815181106117bf57fe5b60200260200101818152505090565b60085490565b60006106ef8282612cfa565b60006106ef826016612cfa565b60006106ef82602c612d21565b60006106ef82604b612d2b565b60006106ef826055612d33565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b81610be357610be381612502565b6118816001600160a01b038416151561019861185c565b6118986001600160a01b038316151561019961185c565b6118a383838361144c565b6001600160a01b0383166000908152602081905260409020546118c990826101a0612d3d565b6001600160a01b0380851660009081526020819052604080822093909355908416815220546118f89082611c54565b6001600160a01b038084166000818152602081905260409081902093909355915190851690600080516020615eb2833981519152906115d5908590615bd0565b6109f161194361168e565b61019261185c565b6119656119608261195a6117ce565b90611480565b612d53565b7f3e350b41e86a8e10f804ade6d35340d620be35569cc75ac943e8bb14ab80ead1816040516116839190615bad565b600061199e6117ce565b90506119a981611807565b15610706576119c36119bc600a54612d68565b8290612da8565b90506119df6119d86119d3610709565b612d68565b8290612db5565b905061070681612d53565b6000806000806000806119fb612dc3565b935093509350935080421015611a4e576001945083831115611a32578181038242038585030281611a2857fe5b0484019550611a49565b8181038242038486030281611a4357fe5b04840395505b611a56565b600094508295505b505050509091565b6000611a6d821515600461185c565b82611a7a575060006106ef565b816001840381611a8657fe5b0460010190506106ef565b611a9d84848484612e1a565b7f1835882ee7a34ac194f717a35e09bb1d24c82a3b9d854ab6c9749525b714cdf284848484604051611ad29493929190615de9565b60405180910390a150505050565b6000611aec828261147c565b611af784601f612e76565b611b02866054612e87565b611b0d88606a612e76565b611b188a609f612e87565b611b238c60b5612e76565b611b2e8e60ea612e87565b17171717171798975050505050505050565b60006106ef8282612d21565b60007f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000611bb9612e94565b30604051602001611bce959493929190615c2c565b60405160208183030381529060405280519060200120905090565b611bfc64e8d4a5100082101560cb61185c565b611c1267016345785d8a000082111560ca61185c565b600854611c21908260c0611451565b6008556040517fa9ba3ffe0b6c366b81232caab38605a0699ad5398d6cce76f91ee809e322dafc90611683908390615bd0565b60008282016109b8848210158361185c565b611c726000838361144c565b600254611c7f9082611c54565b6002556001600160a01b038216600090815260208190526040902054611ca59082611c54565b6001600160a01b038316600081815260208190526040808220939093559151909190600080516020615eb283398151915290611ce2908590615bd0565b60405180910390a35050565b6000611cf8610b7a565b90506000611d04610f4b565b6001600160a01b031663b05f8e4883866040518363ffffffff1660e01b8152600401611d31929190615c71565b60806040518083038186803b158015611d4957600080fd5b505afa158015611d5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d8191906159d4565b604051630639cdb560e21b81529094506001600160a01b03851693506318e736d49250611db5915085908790600401615c58565b600060405180830381600087803b158015611dcf57600080fd5b505af1158015611de3573d6000803e3d6000fd5b5050505050505050565b1c6001600160401b031690565b7f000000000000000000000000000000000000000000000000000000000000000090565b610be3818314606761185c565b6000606080611e3861168e565b15611e7057611e708789600081518110611e4e57fe5b60200260200101518a600181518110611e6357fe5b6020026020010151612e98565b611e808b8b8b8b8b8b8b8b612f31565b9250925092505b985098509895505050505050565b60005b611ea0611dfa565b81101561144c57611ed7838281518110611eb657fe5b6020026020010151838381518110611eca57fe5b6020026020010151612149565b838281518110611ee357fe5b6020908102919091010152600101611e98565b333014611fb4576000306001600160a01b0316600036604051611f1a929190615ab1565b6000604051808303816000865af19150503d8060008114611f57576040519150601f19603f3d011682016040523d82523d6000602084013e611f5c565b606091505b505090508060008114611f6b57fe5b60046000803e6000516001600160e01b0319166343adbafb60e01b8114611f96573d6000803e3d6000fd5b506020600460003e604060205260243d03602460403e601c3d016000f35b6060611fbe611705565b9050611fca878261208e565b60006060611fe28c8c8c8c8c8c898d8d63ffffffff16565b5091509150611ff581848663ffffffff16565b8051601f1982018390526343adbafb603f1983015260200260231982016044820181fd5b6000908152600c602052604090205490565b600080600080600080600061203f88612fc6565b965061204a88612fd3565b955061205588612fe0565b945061206088612fed565b935061206b88612ffa565b925061207688613007565b915061208188611b40565b9050919395979092949650565b60005b612099611dfa565b81101561144c576120d08382815181106120af57fe5b60200260200101518383815181106120c357fe5b6020026020010151612cce565b8382815181106120dc57fe5b6020908102919091010152600101612091565b81516000908190815b818110156121305761212686828151811061210f57fe5b602002602001015184611c5490919063ffffffff16565b92506001016120f8565b5081612141576000925050506109b8565b5090506109b8565b6000612158821515600461185c565b82612165575060006106ef565b670de0b6b3a7640000838102906121889085838161217f57fe5b0414600561185c565b82818161219157fe5b049150506106ef565b6040516334171a8560e01b815260009073D268a45eC914B3AC19e3fE34577c074B1D9Fbc1E906334171a85906121db90600c90889088908890600401615d2a565b60206040518083038186803b1580156121f357600080fd5b505af4158015612207573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061063f919061589d565b6060808861223a6114ee610f4b565b612245611514610b7a565b606061224f611705565b905061225b888261208e565b60006060806122708e8e8e8e8e8e8a8f611e2b565b9250925092506122808d84613014565b61228a8285611e95565b6122948185611e95565b909550935050505b5097509795505050505050565b60006060806122bf8789600081518110611e4e57fe5b611e808b8b8b8b8b8b8b8b61301e565b60005b6122da611dfa565b81101561144c576123118382815181106122f057fe5b602002602001015183838151811061230457fe5b6020026020010151613077565b83828151811061231d57fe5b60209081029190910101526001016122d2565b600083608001516123426114ee610f4b565b61234d611514610b7a565b600061235c86602001516130c5565b9050600061236d87604001516130c5565b905060008751600181111561237e57fe5b141561240e57600061239388606001516130ea565b905060008189606001510390506123b789602001516123b2838761310b565b613117565b606089018290526123c8888561310b565b97506123d4878461310b565b96506123e489606001518561310b565b60608a015260006123f68a8a8a613129565b90506124028185613162565b96505050505050612486565b612418868361310b565b9550612424858261310b565b945061243487606001518261310b565b6060880152600061244688888861316e565b9050612452818461319d565b9050600061245f826131a9565b90506000828203905061247a8a602001516123b2838861310b565b50945061248692505050565b509392505050565b60006124998261260d565b80156106ef575060006124aa611814565b6001600160a01b0316141592915050565b6109f16124ce6124c961263f565b6131cf565b6125cf565b60006124de82612668565b80156106ef575060006124aa611838565b6109f16124fd6124c961269a565b6125f1565b62461bcd60e51b6000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b600061255f610f4b565b6001600160a01b031663aaabadc56040518163ffffffff1660e01b815260040160206040518083038186803b15801561259757600080fd5b505afa1580156125ab573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610865919061570f565b6000806125e36125dd611814565b846131dc565b9150915061144c82826132ad565b6000806125ff6125dd611838565b9150915061144c8282613307565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b600d5490565b600080600061265384613355565b925061265e84613361565b9395909450915050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b600e5490565b60006126aa611b4c565b82604051602001610ee4929190615ac1565b606080886126cb6114ee610f4b565b6126d6611514610b7a565b60606126e0611705565b90506126ea610709565b61279757600060606126ff8d8d8d868b613381565b9150915061271861270e613410565b83101560cc61185c565b61272560006103d8613410565b6127388b612731613410565b8403610bd9565b61274281846122cf565b8061274b611dfa565b6001600160401b038111801561276057600080fd5b5060405190808252806020026020018201604052801561278a578160200160208202803683370190505b509550955050505061229c565b6127a1888261208e565b60006060806127b68e8e8e8e8e8e8a8f6122a9565b9250925092506127c68c84610bd9565b6127d082856122cf565b6127da8185611e95565b909550935061229c915050565b6001600160a01b03918216600090815260016020908152604080832093909416825291909152205490565b61281e81824242612e1a565b7fa0d01593e47e69d07e0ccd87bece09411e07dd1ed40ca8f2e7af2976542a0233816040516116839190615bd0565b600080600061285d878787613417565b905061286b818787876134d6565b915061287681612d68565b92505094509492505050565b60028151101561289157610706565b6000816000815181106128a057fe5b602002602001015190506000600190505b825181101561144c5760008382815181106128c857fe5b602002602001015190506128f1816001600160a01b0316846001600160a01b031610606561185c565b91506001016128b1565b6000612905611814565b6001600160a01b0316146109f15760008061292661292161263f565b613361565b9150915080421115610be357610be3826125cf565b6000612945611838565b6001600160a01b0316146109f15760008061296161292161269a565b9150915080421115610be357610be3826125f1565b61144c8184108015610af35750818310606461185c565b6000612999858361208e565b6129ba86606001518385815181106129ad57fe5b602002602001015161310b565b606087015260006129cd87878787613501565b90506129ec818487815181106129df57fe5b602002602001015161319d565b90506129f7816131a9565b9150505b95945050505050565b6000612a1386606001516130ea565b6060870152612a22858361208e565b612a3686606001518386815181106129ad57fe5b60608701526000612a4987878787613539565b90506129f781848681518110612a5b57fe5b6020026020010151613162565b600073ba1ba1ba1ba1ba1ba1ba1ba1ba1ba1ba1ba1ba1b612a87610f27565b6001600160a01b031614158015612aa25750612aa28361355c565b15612aca57612aaf610f27565b6001600160a01b0316336001600160a01b03161490506106ef565b612ad2612555565b6001600160a01b0316639be2a8848484306040518463ffffffff1660e01b8152600401612b0193929190615bd9565b60206040518083038186803b158015612b1957600080fd5b505afa158015612b2d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b519190615629565b90506106ef565b60606000612b64611dfa565b90506060816001600160401b0381118015612b7e57600080fd5b50604051908082528060200260200182016040528015612ba8578160200160208202803683370190505b509050612bb3613598565b81600081518110612bc057fe5b602002602001018181525050612bd46135bc565b81600181518110612be157fe5b6020026020010181815250506002821115612c1c57612bfe6135e0565b81600281518110612c0b57fe5b602002602001018181525050612c25565b91506106db9050565b6003821115612c1c57612c36613604565b81600381518110612c4357fe5b6020026020010181815250506004821115612c1c57612c60613628565b81600481518110612c6d57fe5b60200260200101818152505091505090565b6000612c8a8261248e565b15612ca657612c9f612c9a61263f565b613355565b9050610e5b565b612caf826124d3565b15612cbf57612c9f612c9a61269a565b50670de0b6b3a7640000610e5b565b6000828202612ce884158061142d57508385838161142a57fe5b670de0b6b3a764000090049392505050565b600082821c623fffff16621fffff8113612d14578061063f565b623fffff19179392505050565b1c637fffffff1690565b1c6103ff1690565b1c60019081161490565b6000612d4c848411158361185c565b5050900390565b600854612d62908260006114b1565b60085550565b600080612d748361364c565b90506000808213612d8d57652d79883d20008203612d97565b652d79883d200082015b655af3107a40009005949350505050565b60006109b88383836136a9565b60006109b8838360166136a9565b600080600080612ddf6000600954611ded90919063ffffffff16565b600954909450612df0906040611ded565b600954909350612e01906080611ded565b600954909250612e129060c0611ded565b905090919293565b612e2e816001600160401b031660c061147c565b612e42836001600160401b0316608061147c565b612e56856001600160401b0316604061147c565b612e6a876001600160401b0316600061147c565b17171760095550505050565b661fffffffffffff91909116901b90565b623fffff91909116901b90565b4690565b6000612ea26117ce565b90506000612eae6119ea565b509050612eba82611807565b8015612ec557508443115b15612f2a57600080612edc8387876113ea886117e0565b915091506000612eeb856117fa565b90506000612ef8866117ed565b90506001828114612f2457612f0d87826136c0565b9650612f1987426136ce565b9650612f2487612d53565b50505050505b5050505050565b6000606080612f3e61168e565b15612f6157612f4d88876136dc565b9050612f5c88826114666137c8565b612fac565b612f69611dfa565b6001600160401b0381118015612f7e57600080fd5b50604051908082528060200260200182016040528015612fa8578160200160208202803683370190505b5090505b612fb788868661382d565b9093509150611e8788836138b8565b60006106ef8260ea612cfa565b60006106ef8260b56138e7565b60006106ef82609f612cfa565b60006106ef82606a6138e7565b60006106ef826054612cfa565b60006106ef82601f6138e7565b610be3828261391a565b600060608061302b611938565b606061303789886136dc565b905061304689826114666137c8565b600060606130558b89896139b8565b915091506130638b82613a11565b909d909c50909a5098505050505050505050565b6000613086821515600461185c565b82613093575060006106ef565b670de0b6b3a7640000838102906130ad9085838161217f57fe5b8260018203816130b957fe5b046001019150506106ef565b6000806130d183613a1e565b905060006130de84612c7f565b905061063f8282612cce565b6000806130ff6130f8610c01565b8490613b1d565b90506109b88382611466565b60006109b88383612cce565b610be361312383613b59565b82610be3565b6000613140613136611dfa565b60021460d261185c565b6060600080613150878787613b5f565b92509250925061156f87848484613539565b60006109b88383612149565b600061317b613136611dfa565b606060008061318b878787613b5f565b92509250925061156f87848484613501565b60006109b88383613077565b60006106ef6131c86131b9610c01565b670de0b6b3a764000090611466565b8390613077565b60006106ef826080611ded565b600080836001600160a01b031663679aefce6040518163ffffffff1660e01b815260040160206040518083038186803b15801561321857600080fd5b505afa15801561322c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613250919061589d565b9050613264600160801b821061014961185c565b61327a8342016001600160401b031660c061147c565b61328e846001600160401b0316608061147c565b6132a2836001600160801b0316600061147c565b171791509250929050565b81600d819055507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316600080516020615e92833981519152826040516132fb9190615bd0565b60405180910390a25050565b81600e819055507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316600080516020615e92833981519152826040516132fb9190615bd0565b60006106ef8282613c20565b60008061336d836131cf565b915061337a8360c0611ded565b9050915091565b6000606061338d611938565b600061339884613c2d565b90506133b360008260028111156133ab57fe5b1460ce61185c565b60606133be85613c43565b90506133cd8151610c23611dfa565b6133d7818761208e565b60006133e16119ea565b50905060006133f2828460016120ef565b9050806133ff8184613c59565b9b929a509198505050505050505050565b620f424090565b60008061342f856134288686613c64565b60016120ef565b90506103e86002860204600061344f836134498185611410565b90611466565b9050600061346a86613464856002028a611410565b90612cce565b9050600061349361347b8489612cce565b61344961348c8a613464898d611410565b8590611c54565b905060006134bc6134a4858b612cce565b6134496134b58c6134648a8f611410565b8690611c54565b90506134c88282613077565b9a9950505050505050505050565b6000806134e66134b58786613b1d565b905060006134f382612d68565b939093039695505050505050565b600061352d8560a001518560008151811061351857fe5b602002602001015186600181518110611e6357fe5b61063c85858585613cbe565b60006135508560a001518560008151811061351857fe5b61063c85858585613d05565b600061356e632f1a0bc960e01b610eaf565b8214806135895750613586637587926b60e11b610eaf565b82145b806106ef57506106ef82613d40565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b600061365c60008313606461185c565b670c7d713b49da00008213801561367a5750670f43fc2c04ee000082125b156136a057670de0b6b3a764000061369183613d72565b8161369857fe5b059050610e5b565b612c9f82613e90565b623fffff828116821b90821b198416179392505050565b60006109b88383604b614228565b60006109b88383602c614238565b6060806136e7611dfa565b6001600160401b03811180156136fc57600080fd5b50604051908082528060200260200182016040528015613726578160200160208202803683370190505b509050826137355790506106ef565b6000808560008151811061374557fe5b602002602001015190506000600190505b61375e611dfa565b81101561379557600087828151811061377357fe5b602002602001015190508281111561378c578193508092505b50600101613756565b506137a7600b5487600a54858961424a565b8383815181106137b357fe5b60209081029190910101525090949350505050565b60005b6137d3611dfa565b811015610b515761380e8482815181106137e957fe5b60200260200101518483815181106137fd57fe5b60200260200101518463ffffffff16565b84828151811061381a57fe5b60209081029190910101526001016137cb565b60006060600061383c84613c2d565b9050600081600281111561384c57fe5b14156138665761385c86856142ac565b92509250506138b0565b600181600281111561387457fe5b14156138845761385c8685614376565b600281600281111561389257fe5b14156138a35761385c8686866143a8565b6138ae610150612502565b505b935093915050565b6138c582826114666137c8565b60006138cf6119ea565b50905061144c6138e1828560016120ef565b82613c59565b600082821c661fffffffffffff16660fffffffffffff8113613909578061063f565b661fffffffffffff19179392505050565b6139316001600160a01b038316151561019b61185c565b61393d8260008361144c565b6001600160a01b03821660009081526020819052604090205461396390826101a1612d3d565b6001600160a01b0383166000908152602081905260409020556002546139899082614424565b6002556040516000906001600160a01b03841690600080516020615eb283398151915290611ce2908590615bd0565b6000606060006139c784613c2d565b905060018160028111156139d757fe5b14156139e85761385c868686614432565b60028160028111156139f657fe5b1415613a065761385c868561449c565b6138ae610136612502565b6138c58282611c546137c8565b6000613a298261260d565b15613a3657612c9f613598565b613a3f82612668565b15613a4c57612c9f6135bc565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316826001600160a01b03161415613a8e57612c9f6135e0565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316826001600160a01b03161415613ad057612c9f613604565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316826001600160a01b03161415613b1257612c9f613628565b610e5b610135612502565b6000828202613b3784158061142d57508385838161142a57fe5b80613b465760009150506106ef565b670de0b6b3a764000060001982016130b9565b50600090565b60408051600280825260608281019093526000918291816020016020820280368337019050509250613b94866020015161260d565b15613bda5760009150600190508483600081518110613baf57fe5b6020026020010181815250508383600181518110613bc957fe5b602002602001018181525050613c17565b60009050600191508383600081518110613bf057fe5b6020026020010181815250508483600181518110613c0a57fe5b6020026020010181815250505b93509350939050565b1c6001600160801b031690565b6000818060200190518101906106ef9190615778565b6060818060200190518101906109b8919061583d565b600a91909155600b55565b60408051600280825260608083018452926020830190803683370190505090508281600081518110613c9257fe5b6020026020010181815250508181600181518110613cac57fe5b60200260200101818152505092915050565b6000613cc8611938565b6000613cd26119ea565b5090506000613ce3828760016120ef565b90506000613cf9838888888c6060015187614530565b98975050505050505050565b6000613d0f611938565b6000613d196119ea565b5090506000613d2a828760016120ef565b90506000613cf9838888888c60600151876145df565b6000613d52631c74c91760e11b610eaf565b8214806106ef5750613d6a6350dd6ed960e01b610eaf565b909114919050565b670de0b6b3a7640000026000806a0c097ce7bc90715b34b9f160241b808401906ec097ce7bc90715b34b9f0fffffffff1985010281613dad57fe5b05905060006a0c097ce7bc90715b34b9f160241b82800205905081806a0c097ce7bc90715b34b9f160241b81840205915060038205016a0c097ce7bc90715b34b9f160241b82840205915060058205016a0c097ce7bc90715b34b9f160241b82840205915060078205016a0c097ce7bc90715b34b9f160241b82840205915060098205016a0c097ce7bc90715b34b9f160241b828402059150600b8205016a0c097ce7bc90715b34b9f160241b828402059150600d8205016a0c097ce7bc90715b34b9f160241b828402059150600f826002919005919091010295945050505050565b6000670de0b6b3a7640000821215613ecc57613ec2826a0c097ce7bc90715b34b9f160241b81613ebc57fe5b05613e90565b6000039050610e5b565b6000775803bcc5cb9634ba4cfb2213f784019318ed4dcb6017880f60361b8312613f175772195e54c5dd42177f53a27172fa9ec63026282760241b830592506806f05b59d3b2000000015b6f8bcc0026baae9e45e470190267a230cf60191b8312613f4e576b1425982cf597cd205cef7380830592506803782dace9d9000000015b606492830292026e01855144814a7ff805980ff00840008312613f96576e01855144814a7ff805980ff008400068056bc75e2d63100000840205925068ad78ebc5ac62000000015b6b02df0ab5a80a22c61ab5a7008312613fd1576b02df0ab5a80a22c61ab5a70068056bc75e2d6310000084020592506856bc75e2d631000000015b693f1fce3da636ea5cf850831261400857693f1fce3da636ea5cf85068056bc75e2d631000008402059250682b5e3af16b18800000015b690127fa27722cc06cc5e2831261403f57690127fa27722cc06cc5e268056bc75e2d6310000084020592506815af1d78b58c400000015b68280e60114edb805d0383126140745768280e60114edb805d0368056bc75e2d631000008402059250680ad78ebc5ac6200000015b680ebc5fb41746121110831261409f57680ebc5fb4174612111068056bc75e2d631000009384020592015b6808f00f760a4b2db55d83126140d4576808f00f760a4b2db55d68056bc75e2d6310000084020592506802b5e3af16b1880000015b6806f5f17757889379378312614109576806f5f177578893793768056bc75e2d63100000840205925068015af1d78b58c40000015b6806248f33704b286603831261413d576806248f33704b28660368056bc75e2d63100000840205925067ad78ebc5ac620000015b6805c548670b9510e7ac8312614171576805c548670b9510e7ac68056bc75e2d6310000084020592506756bc75e2d6310000015b600068056bc75e2d63100000840168056bc75e2d63100000808603028161419457fe5b059050600068056bc75e2d63100000828002059050818068056bc75e2d63100000818402059150600382050168056bc75e2d63100000828402059150600582050168056bc75e2d63100000828402059150600782050168056bc75e2d63100000828402059150600982050168056bc75e2d63100000828402059150600b820501600202606485820105979650505050505050565b6103ff811b1992909216911b1790565b637fffffff811b1992909216911b1790565b60008061425987878787614672565b90508086858151811061426857fe5b60200260200101511161427f5760009150506129fb565b60008187868151811061428e57fe5b6020026020010151039050613cf98482612cce90919063ffffffff16565b600060606142b8611938565b6000806142c485614828565b915091506142dc6142d3611dfa565b8210606461185c565b60606142e6611dfa565b6001600160401b03811180156142fb57600080fd5b50604051908082528060200260200182016040528015614325578160200160208202803683370190505b50905060006143326119ea565b50905061435181898587614344610709565b61434c610c01565b61484a565b82848151811061435d57fe5b6020908102919091010152509196919550909350505050565b60006060600061438584614966565b9050606061439b8683614396610709565b61497c565b9196919550909350505050565b600060606143b4611938565b606060006143c185614a17565b915091506143d28251610c23611dfa565b6143dc828761208e565b60006143e66119ea565b5090506000614406828a866143f9610709565b614401610c01565b614a2f565b90506144168382111560cf61185c565b989297509195505050505050565b60006109b883836001612d3d565b6000606080600061444285614a17565b91509150614458614451611dfa565b8351611e1e565b614462828761208e565b600061446c6119ea565b509050600061448c828a8661447f610709565b614487610c01565b614cc3565b90506144168382101560d061185c565b600060606000806144ac85614828565b915091506144bb6142d3611dfa565b60606144c5611dfa565b6001600160401b03811180156144da57600080fd5b50604051908082528060200260200182016040528015614504578160200160208202803683370190505b50905060006145116119ea565b50905061435181898587614523610709565b61452b610c01565b614f3f565b60006145588387868151811061454257fe5b602002602001015161146690919063ffffffff16565b86858151811061456457fe5b602002602001018181525050600061457e88888589614672565b90508387868151811061458d57fe5b6020026020010151018786815181106145a257fe5b602002602001018181525050613cf960016145d98989815181106145c257fe5b60200260200101518461146690919063ffffffff16565b90611c54565b6000614607838787815181106145f157fe5b6020026020010151611c5490919063ffffffff16565b86868151811061461357fe5b602002602001018181525050600061462d88888588614672565b90508387878151811061463c57fe5b60200260200101510387878151811061465157fe5b602002602001018181525050613cf96001613449838a898151811061454257fe5b60008084518602905060008560008151811061468a57fe5b6020026020010151905060008651876000815181106146a557fe5b60200260200101510290506000600190505b875181101561470b576146f06146ea6146e3848b85815181106146d657fe5b6020026020010151611410565b8a51611410565b8861501c565b915061470188828151811061210f57fe5b92506001016146b7565b5086858151811061471857fe5b60200260200101518203915060006147308788611410565b9050600061475c61475061474884610a8b8988611410565b6103e8611410565b8a89815181106146d657fe5b905060006147706134b56147488b8961501c565b905060008061478c6147828686611c54565b610a8b8d86611c54565b905060005b60ff81101561480c578192506147c16147ae866145d98586611410565b610a8b8e613449886145d9886002611410565b9150828211156147ea576001838303116147e55750975061063f9650505050505050565b614804565b6001828403116148045750975061063f9650505050505050565b600101614791565b50614818610142612502565b5050505050505050949350505050565b6000808280602001905181019061483f9190615807565b909590945092505050565b600080614859888860016120ef565b9050600061487b826148758761486f818b611466565b90613077565b90613b1d565b9050600061488b8a8a848b614672565b9050600061489f828b8b8151811061454257fe5b90506000805b8b518110156148de576148d48c82815181106148bd57fe5b602002602001015183611c5490919063ffffffff16565b91506001016148a5565b506000614907828d8d815181106148f157fe5b602002602001015161214990919063ffffffff16565b905060006149148261503c565b905060006149228583613b1d565b905060006149308683611466565b905061495161494a83670de0b6b3a76400008e9003612cce565b8290611c54565b99505050505050505050509695505050505050565b6000818060200190518101906109b891906157da565b6060600061498a8484612149565b9050606085516001600160401b03811180156149a557600080fd5b506040519080825280602002602001820160405280156149cf578160200160208202803683370190505b50905060005b8651811015614a0d576149ee8388838151811061174a57fe5b8282815181106149fa57fe5b60209081029190910101526001016149d5565b5095945050505050565b606060008280602001905181019061483f9190615794565b600080805b8651811015614a5657614a4c8782815181106148bd57fe5b9150600101614a34565b50606085516001600160401b0381118015614a7057600080fd5b50604051908082528060200260200182016040528015614a9a578160200160208202803683370190505b5090506000805b8851811015614b61576000614ad2858b8481518110614abc57fe5b602002602001015161307790919063ffffffff16565b9050614b0e8a8381518110614ae357fe5b602002602001015161486f8b8581518110614afa57fe5b60200260200101518d868151811061454257fe5b848381518110614b1a57fe5b602002602001018181525050614b56614b4f82868581518110614b3957fe5b6020026020010151613b1d90919063ffffffff16565b8490611c54565b925050600101614aa1565b50606088516001600160401b0381118015614b7b57600080fd5b50604051908082528060200260200182016040528015614ba5578160200160208202803683370190505b50905060005b8951811015614c70576000848281518110614bc257fe5b6020026020010151841115614c29576000614beb614bdf8661503c565b8d858151811061174a57fe5b90506000614bff828d868151811061454257fe5b9050614c20614c1982670de0b6b3a76400008d9003613077565b8390611c54565b92505050614c40565b898281518110614c3557fe5b602002602001015190505b614c50818c848151811061454257fe5b838381518110614c5c57fe5b602090810291909101015250600101614bab565b506000614c7f8b8b60016120ef565b90506000614c8f8c8460006120ef565b90506000614c9d8284612149565b9050614cb2614cab8261503c565b8b90613b1d565b9d9c50505050505050505050505050565b600080805b8651811015614cea57614ce08782815181106148bd57fe5b9150600101614cc8565b50606085516001600160401b0381118015614d0457600080fd5b50604051908082528060200260200182016040528015614d2e578160200160208202803683370190505b5090506000805b8851811015614dc8576000614d50858b84815181106148f157fe5b9050614d928a8381518110614d6157fe5b6020026020010151614d8c8b8581518110614d7857fe5b60200260200101518d86815181106145f157fe5b90612149565b848381518110614d9e57fe5b602002602001018181525050614dbd614b4f8286858151811061174a57fe5b925050600101614d35565b50606088516001600160401b0381118015614de257600080fd5b50604051908082528060200260200182016040528015614e0c578160200160208202803683370190505b50905060005b8951811015614ecd57600083858381518110614e2a57fe5b60200260200101511115614e86576000614e4f614bdf86670de0b6b3a7640000611466565b90506000614e63828d868151811061454257fe5b9050614e7d614c1982670de0b6b3a76400008d9003612cce565b92505050614e9d565b898281518110614e9257fe5b602002602001015190505b614ead818c84815181106145f157fe5b838381518110614eb957fe5b602090810291909101015250600101614e12565b506000614edc8b8b60016120ef565b90506000614eec8c8460006120ef565b90506000614efa8284612149565b9050670de0b6b3a7640000811115614f2f57614f218a670de0b6b3a763ffff198301612cce565b9750505050505050506129fb565b60009750505050505050506129fb565b600080614f4e888860016120ef565b90506000614f64826148758761486f818b611c54565b90506000614f748a8a848b614672565b90506000614f9e8a8a81518110614f8757fe5b60200260200101518361146690919063ffffffff16565b90506000805b8b51811015614fc657614fbc8c82815181106148bd57fe5b9150600101614fa4565b506000614fd9828d8d815181106148f157fe5b90506000614fe68261503c565b90506000614ff48583613b1d565b905060006150028683611466565b905061495161494a83670de0b6b3a76400008e9003613077565b600061502b821515600461185c565b81838161503457fe5b049392505050565b6000670de0b6b3a764000082106150545760006106ef565b50670de0b6b3a76400000390565b604080518082019091526000808252602082015290565b80356106ef81615e61565b600082601f830112615094578081fd5b81356150a76150a282615e38565b615e12565b8181529150602080830190848101818402860182018710156150c857600080fd5b60005b848110156150e7578135845292820192908201906001016150cb565b505050505092915050565b600082601f830112615102578081fd5b81516151106150a282615e38565b81815291506020808301908481018184028601820187101561513157600080fd5b60005b848110156150e757815184529282019290820190600101615134565b600082601f830112615160578081fd5b81356001600160401b03811115615175578182fd5b615188601f8201601f1916602001615e12565b915080825283602082850101111561519f57600080fd5b8060208401602084013760009082016020015292915050565b8035600281106106ef57600080fd5b80356106ef81615e84565b60006101208083850312156151e5578182fd5b6151ee81615e12565b9150506151fb83836151b8565b815261520a8360208401615079565b602082015261521c8360408401615079565b6040820152606082013560608201526080820135608082015260a082013560a082015261524c8360c08401615079565b60c082015261525e8360e08401615079565b60e0820152610100828101356001600160401b0381111561527e57600080fd5b61528a85828601615150565b82840152505092915050565b6000602082840312156152a7578081fd5b81356109b881615e61565b600080604083850312156152c4578081fd5b82356152cf81615e61565b915060208301356152df81615e61565b809150509250929050565b6000806000606084860312156152fe578081fd5b833561530981615e61565b9250602084013561531981615e61565b929592945050506040919091013590565b600080600080600080600060e0888a031215615344578485fd5b873561534f81615e61565b9650602088013561535f81615e61565b95506040880135945060608801359350608088013560ff81168114615382578384fd5b9699959850939692959460a0840135945060c09093013592915050565b600080604083850312156153b1578182fd5b82356153bc81615e61565b946020939093013593505050565b6000806000606084860312156153de578081fd5b83516001600160401b03808211156153f4578283fd5b818601915086601f830112615407578283fd5b81516154156150a282615e38565b80828252602080830192508086018b828387028901011115615435578788fd5b8796505b8487101561546057805161544c81615e61565b845260019690960195928101928101615439565b508901519097509350505080821115615477578283fd5b50615484868287016150f2565b925050604084015190509250925092565b600060208083850312156154a7578182fd5b82356001600160401b038111156154bc578283fd5b8301601f810185136154cc578283fd5b80356154da6150a282615e38565b818152838101908385016040808502860187018a10156154f8578788fd5b8795505b848610156155455780828b031215615512578788fd5b61551b81615e12565b6155258b846151c7565b8152828801358882015284526001959095019492860192908101906154fc565b509098975050505050505050565b60006020808385031215615565578182fd5b82356001600160401b0381111561557a578283fd5b8301601f8101851361558a578283fd5b80356155986150a282615e38565b818152838101908385016060808502860187018a10156155b6578788fd5b8795505b848610156155455780828b0312156155d0578788fd5b6155d981615e12565b6155e38b846151c7565b815282880135888201526040808401359082015284526001959095019492860192908101906155ba565b60006020828403121561561e578081fd5b81356109b881615e76565b60006020828403121561563a578081fd5b81516109b881615e76565b600080600080600080600060e0888a03121561565f578081fd5b87359650602088013561567181615e61565b9550604088013561568181615e61565b945060608801356001600160401b038082111561569c578283fd5b6156a88b838c01615084565b955060808a0135945060a08a0135935060c08a01359150808211156156cb578283fd5b506156d88a828b01615150565b91505092959891949750929550565b6000602082840312156156f8578081fd5b81356001600160e01b0319811681146109b8578182fd5b600060208284031215615720578081fd5b81516109b881615e61565b6000806040838503121561573d578182fd5b823561574881615e61565b915060208301356001600160401b03811115615762578182fd5b61576e85828601615150565b9150509250929050565b600060208284031215615789578081fd5b81516109b881615e84565b6000806000606084860312156157a8578081fd5b83516157b381615e84565b60208501519093506001600160401b038111156157ce578182fd5b615484868287016150f2565b600080604083850312156157ec578182fd5b82516157f781615e84565b6020939093015192949293505050565b60008060006060848603121561581b578081fd5b835161582681615e84565b602085015160409095015190969495509392505050565b6000806040838503121561584f578182fd5b825161585a81615e84565b60208401519092506001600160401b03811115615875578182fd5b61576e858286016150f2565b600060208284031215615892578081fd5b81356109b881615e84565b6000602082840312156158ae578081fd5b5051919050565b600080600080608085870312156158ca578182fd5b84356001600160401b03808211156158e0578384fd5b6158ec888389016151d2565b95506020870135915080821115615901578384fd5b5061590e87828801615084565b949794965050505060408301359260600135919050565b600080600060608486031215615939578081fd5b83356001600160401b0381111561594e578182fd5b61595a868287016151d2565b9660208601359650604090950135949350505050565b600060208284031215615981578081fd5b5035919050565b6000806040838503121561599a578182fd5b50508035926020909101359150565b6000806000606084860312156159bd578081fd5b505081359360208301359350604090920135919050565b600080600080608085870312156159e9578182fd5b8451935060208501519250604085015191506060850151615a0981615e61565b939692955090935050565b6000815180845260208085019450808401835b83811015615a4357815187529582019590820190600101615a27565b509495945050505050565b60008151808452815b81811015615a7357602081850181015186830182015201615a57565b81811115615a845782602083870101525b50601f01601f19169290920160200192915050565b9182526001600160e01b031916602082015260240190565b6000828483379101908152919050565b61190160f01b81526002810192909252602282015260420190565b6001600160a01b0391909116815260200190565b6020808252825182820181905260009190848201906040850190845b81811015615b315783516001600160a01b031683529284019291840191600101615b0c565b50909695505050505050565b6020808252825182820181905260009190848201906040850190845b81811015615b3157835183529284019291840191600101615b59565b6000602082526109b86020830184615a14565b600060408252615b9b6040830185615a14565b82810360208401526129fb8185615a14565b901515815260200190565b92151583526020830191909152604082015260600190565b90815260200190565b9283526001600160a01b03918216602084015216604082015260600190565b9586526001600160a01b0394851660208701529290931660408501526060840152608083019190915260a082015260c00190565b9485526020850193909352604084019190915260608301526001600160a01b0316608082015260a00190565b60008382526040602083015261063f6040830184615a4e565b9182526001600160a01b0316602082015260400190565b93845260ff9290921660208401526040830152606082015260800190565b918252602082015260400190565b968752602087019590955260408601939093526060850191909152608084015260a083015260c082015260e00190565b9485526020850193909352604084019190915260608301521515608082015260a00190565b83815260608101615d1984615e57565b602082019390935260400152919050565b84815260808101615d3a85615e57565b84602083015283604083015282606083015295945050505050565b838152825160a0820190615d6881615e57565b806020840152506020840151604083015260408401516060830152826080830152949350505050565b6000602082526109b86020830184615a4e565b60008382526040602083015261063f6040830184615a14565b9283529015156020830152604082015260600190565b9283526020830191909152604082015260600190565b93845260208401929092526040830152606082015260800190565b60ff91909116815260200190565b6040518181016001600160401b0381118282101715615e3057600080fd5b604052919050565b60006001600160401b03821115615e4d578081fd5b5060209081020190565b6003811061070657fe5b6001600160a01b038116811461070657600080fd5b801515811461070657600080fd5b6003811061070657600080fdfec1a224b14823b63c7711127f125fbf592434682f38881ebb61408747a303affcddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa26469706673582212203e66a7a62b7a5e2e7bc8598533ffdd90444125c14ddefc15637b41caf087184064736f6c63430007010033c1a224b14823b63c7711127f125fbf592434682f38881ebb61408747a303affcca6c2c5b6b44b5f3f0c08f0e28e5b6deda1cb38c3fe1113e8031d926c1e8c6d0",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061006c5760003560e01c8062c194db14610071578063174481fa1461008f5780632da47c40146100a55780634555fb8d146100bb5780636634b753146100db57806374cc23da146100fb5780638d928af81461010e575b600080fd5b610079610116565b6040516100869190610949565b60405180910390f35b610097610135565b604051610086929190610924565b6100ad61017b565b604051610086929190610a69565b6100ce6100c9366004610750565b6101e5565b6040516100869190610910565b6100ee6100e93660046106fa565b61029a565b604051610086919061093e565b610079610109366004610716565b6102b8565b6100ce610391565b6060610130604051806020016040528060008152506102b8565b905090565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000009091565b600080427f00000000000000000000000000000000000000000000000000000000000000008110156101d757807f000000000000000000000000000000000000000000000000000000000000000003925062278d0091506101e0565b60009250600091505b509091565b60008060006101f261017b565b9150915061028b60405180610180016040528061020d610391565b6001600160a01b031681526020018d81526020018c81526020018b81526020018981526020018881526020018a8152602001878152602001848152602001838152602001600015158152602001866001600160a01b0316815250604051602001610277919061095c565b604051602081830303815290604052610407565b9b9a5050505050505050505050565b6001600160a01b031660009081526020819052604090205460ff1690565b8051604080517f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000818101858101848101602090810190965280855293957f00000000000000000000000000000000000000000000000000000000000000009592947f000000000000000000000000000000000000000000000000000000000000000094938801866000828a3c846000888301883c5060208981019089850101610383818386610467565b505050505050505050919050565b7f000000000000000000000000000000000000000000000000000000000000000090565b80517f602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe808352600091602081018484f090845291506104016001600160a01b03831615156101ac6104a5565b50919050565b600080610413836104b7565b6001600160a01b038116600081815260208190526040808220805460ff191660011790555192935090917f83a48fbcfc991335314e74d0496aab6a1987e992ddc85dddbcc4d6dd6ef2e9fc9190a292915050565b5b60208110610487578151835260209283019290910190601f1901610468565b905182516020929092036101000a6000190180199091169116179052565b816104b3576104b3816104f2565b5050565b600060606104c4836102b8565b905060008151602083016000f090506001600160a01b0381166104eb573d6000803e3d6000fd5b9392505050565b62461bcd60e51b6000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b803561055081610abc565b92915050565b600082601f830112610566578081fd5b813561057961057482610a9d565b610a77565b81815291506020808301908481018184028601820187101561059a57600080fd5b60005b848110156105c25781356105b081610abc565b8452928201929082019060010161059d565b505050505092915050565b600082601f8301126105dd578081fd5b81356105eb61057482610a9d565b81815291506020808301908481018184028601820187101561060c57600080fd5b60005b848110156105c257813561062281610abc565b8452928201929082019060010161060f565b600082601f830112610644578081fd5b813561065261057482610a9d565b81815291506020808301908481018184028601820187101561067357600080fd5b60005b848110156105c257813584529282019290820190600101610676565b600082601f8301126106a2578081fd5b81356001600160401b038111156106b7578182fd5b6106ca601f8201601f1916602001610a77565b91508082528360208285010111156106e157600080fd5b8060208401602084013760009082016020015292915050565b60006020828403121561070b578081fd5b81356104eb81610abc565b600060208284031215610727578081fd5b81356001600160401b0381111561073c578182fd5b61074884828501610692565b949350505050565b600080600080600080600080610100898b03121561076c578384fd5b88356001600160401b0380821115610782578586fd5b61078e8c838d01610692565b995060208b01359150808211156107a3578586fd5b6107af8c838d01610692565b985060408b01359150808211156107c4578586fd5b6107d08c838d01610556565b975060608b0135965060808b01359150808211156107ec578586fd5b6107f88c838d016105cd565b955060a08b013591508082111561080d578485fd5b5061081a8b828c01610634565b93505060c089013591506108318a60e08b01610545565b90509295985092959890939650565b6001600160a01b03169052565b6000815180845260208085019450808401835b838110156108855781516001600160a01b031687529582019590820190600101610860565b509495945050505050565b6000815180845260208085019450808401835b83811015610885578151875295820195908201906001016108a3565b15159052565b60008151808452815b818110156108ea576020818501810151868301820152016108ce565b818111156108fb5782602083870101525b50601f01601f19169290920160200192915050565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b901515815260200190565b6000602082526104eb60208301846108c5565b600060208252610970602083018451610840565b602083015161018080604085015261098c6101a08501836108c5565b91506040850151601f19808685030160608701526109aa84836108c5565b935060608701519150808685030160808701526109c7848361084d565b935060808701519150808685030160a08701526109e4848361084d565b935060a08701519150808685030160c087015250610a028382610890565b60c087015160e0878101919091528701516101008088019190915287015161012080880191909152870151610140808801919091528701519093509050610160610a4e818701836108bf565b8601519050610a5f85830182610840565b5090949350505050565b918252602082015260400190565b6040518181016001600160401b0381118282101715610a9557600080fd5b604052919050565b60006001600160401b03821115610ab2578081fd5b5060209081020190565b6001600160a01b0381168114610ad157600080fd5b5056fea26469706673582212202906fc86ea766e4a02eaf64d82594e2fb43d8aa1e2c995192a5a2a414664147d64736f6c63430007010033",
  "libraries": {
    "QueryProcessor": "0xD268a45eC914B3AC19e3fE34577c074B1D9Fbc1E"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "_getCreationCodeWithArgs(bytes)": {
        "details": "Returns the creation code that will result in a contract being deployed with `constructorArgs`."
      },
      "create(string,string,address[],uint256,address[],uint256[],uint256,address)": {
        "details": "Deploys a new `MetaStablePool`."
      },
      "getCreationCode()": {
        "details": "Returns the creation code of the contract this factory creates."
      },
      "getCreationCodeContracts()": {
        "details": "Returns the two addresses where the creation code of the contract crated by this factory is stored."
      },
      "getPauseConfiguration()": {
        "details": "Returns the current `TemporarilyPausable` configuration that will be applied to Pools created by this factory. `pauseWindowDuration` will decrease over time until it reaches zero, at which point both it and `bufferPeriodDuration` will be zero forever, meaning deployed Pools will not be pausable."
      },
      "getVault()": {
        "details": "Returns the Vault's address."
      },
      "isPoolFromFactory(address)": {
        "details": "Returns true if `pool` was created by this factory."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2674,
        "contract": "contracts/StablePool/meta/MetaStablePoolFactory.sol:MetaStablePoolFactory",
        "label": "_isPoolFromFactory",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}