{
  "address": "0xb575F46B55703474c039AF0F8D46F41d617E9163",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IAuthorizer",
          "name": "authorizer",
          "type": "address"
        },
        {
          "internalType": "contract IWETH",
          "name": "weth",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "pauseWindowDuration",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bufferPeriodDuration",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract IAuthorizer",
          "name": "newAuthorizer",
          "type": "address"
        }
      ],
      "name": "AuthorizerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "ExternalBalanceTransfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract IFlashLoanRecipient",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "feeAmount",
          "type": "uint256"
        }
      ],
      "name": "FlashLoan",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "delta",
          "type": "int256"
        }
      ],
      "name": "InternalBalanceChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bool",
          "name": "paused",
          "type": "bool"
        }
      ],
      "name": "PausedStateChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "liquidityProvider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "int256[]",
          "name": "deltas",
          "type": "int256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "protocolFeeAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "PoolBalanceChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "assetManager",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "cashDelta",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "managedDelta",
          "type": "int256"
        }
      ],
      "name": "PoolBalanceManaged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum IVault.PoolSpecialization",
          "name": "specialization",
          "type": "uint8"
        }
      ],
      "name": "PoolRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "relayer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "RelayerApprovalChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "tokenOut",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "name": "Swap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "TokensDeregistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "assetManagers",
          "type": "address[]"
        }
      ],
      "name": "TokensRegistered",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "WETH",
      "outputs": [
        {
          "internalType": "contract IWETH",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IVault.SwapKind",
          "name": "kind",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "assetInIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "assetOutIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            }
          ],
          "internalType": "struct IVault.BatchSwapStep[]",
          "name": "swaps",
          "type": "tuple[]"
        },
        {
          "internalType": "contract IAsset[]",
          "name": "assets",
          "type": "address[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            },
            {
              "internalType": "address payable",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.FundManagement",
          "name": "funds",
          "type": "tuple"
        },
        {
          "internalType": "int256[]",
          "name": "limits",
          "type": "int256[]"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "batchSwap",
      "outputs": [
        {
          "internalType": "int256[]",
          "name": "assetDeltas",
          "type": "int256[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "deregisterTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address payable",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IAsset[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "minAmountsOut",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.ExitPoolRequest",
          "name": "request",
          "type": "tuple"
        }
      ],
      "name": "exitPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IFlashLoanRecipient",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "userData",
          "type": "bytes"
        }
      ],
      "name": "flashLoan",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "selector",
          "type": "bytes4"
        }
      ],
      "name": "getActionId",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAuthorizer",
      "outputs": [
        {
          "internalType": "contract IAuthorizer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDomainSeparator",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "getInternalBalance",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getNextNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPausedState",
      "outputs": [
        {
          "internalType": "bool",
          "name": "paused",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "pauseWindowEndTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bufferPeriodEndTime",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        }
      ],
      "name": "getPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "enum IVault.PoolSpecialization",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getPoolTokenInfo",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "cash",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "managed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastChangeBlock",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "assetManager",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        }
      ],
      "name": "getPoolTokens",
      "outputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "lastChangeBlock",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolFeesCollector",
      "outputs": [
        {
          "internalType": "contract IProtocolFeesCollector",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "relayer",
          "type": "address"
        }
      ],
      "name": "hasApprovedRelayer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IAsset[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "maxAmountsIn",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.JoinPoolRequest",
          "name": "request",
          "type": "tuple"
        }
      ],
      "name": "joinPool",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum IVault.PoolBalanceOpKind",
              "name": "kind",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "contract IERC20",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "internalType": "struct IVault.PoolBalanceOp[]",
          "name": "ops",
          "type": "tuple[]"
        }
      ],
      "name": "managePoolBalance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum IVault.UserBalanceOpKind",
              "name": "kind",
              "type": "uint8"
            },
            {
              "internalType": "contract IAsset",
              "name": "asset",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address payable",
              "name": "recipient",
              "type": "address"
            }
          ],
          "internalType": "struct IVault.UserBalanceOp[]",
          "name": "ops",
          "type": "tuple[]"
        }
      ],
      "name": "manageUserBalance",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IVault.SwapKind",
          "name": "kind",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "assetInIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "assetOutIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            }
          ],
          "internalType": "struct IVault.BatchSwapStep[]",
          "name": "swaps",
          "type": "tuple[]"
        },
        {
          "internalType": "contract IAsset[]",
          "name": "assets",
          "type": "address[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            },
            {
              "internalType": "address payable",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.FundManagement",
          "name": "funds",
          "type": "tuple"
        }
      ],
      "name": "queryBatchSwap",
      "outputs": [
        {
          "internalType": "int256[]",
          "name": "",
          "type": "int256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IVault.PoolSpecialization",
          "name": "specialization",
          "type": "uint8"
        }
      ],
      "name": "registerPool",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "assetManagers",
          "type": "address[]"
        }
      ],
      "name": "registerTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IAuthorizer",
          "name": "newAuthorizer",
          "type": "address"
        }
      ],
      "name": "setAuthorizer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "paused",
          "type": "bool"
        }
      ],
      "name": "setPaused",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "relayer",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setRelayerApproval",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "enum IVault.SwapKind",
              "name": "kind",
              "type": "uint8"
            },
            {
              "internalType": "contract IAsset",
              "name": "assetIn",
              "type": "address"
            },
            {
              "internalType": "contract IAsset",
              "name": "assetOut",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            }
          ],
          "internalType": "struct IVault.SingleSwap",
          "name": "singleSwap",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            },
            {
              "internalType": "address payable",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.FundManagement",
          "name": "funds",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "limit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "swap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountCalculated",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x784a99a940b4b8a3889024f0cc9d0a3b439f74e255b65d7cf1adfb39d44db695",
  "receipt": {
    "to": null,
    "from": "0xABfB1a497fAa51B667Aa2bacA2c768255cb1725c",
    "contractAddress": "0xb575F46B55703474c039AF0F8D46F41d617E9163",
    "transactionIndex": 0,
    "gasUsed": "556063",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8f95e6364e736cf39df99997a0fb59b8df0b95abf406ca14efcb55135c9a13e3",
    "transactionHash": "0x784a99a940b4b8a3889024f0cc9d0a3b439f74e255b65d7cf1adfb39d44db695",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 347890,
        "transactionHash": "0x784a99a940b4b8a3889024f0cc9d0a3b439f74e255b65d7cf1adfb39d44db695",
        "address": "0xb575F46B55703474c039AF0F8D46F41d617E9163",
        "topics": [
          "0x94b979b6831a51293e2641426f97747feed46f17779fed9cd18d1ecefcfe92ef",
          "0x0000000000000000000000009edac8819af1ba913820b0a02f990a671251204c"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 0,
        "blockHash": "0x8f95e6364e736cf39df99997a0fb59b8df0b95abf406ca14efcb55135c9a13e3"
      }
    ],
    "blockNumber": 347890,
    "cumulativeGasUsed": "556063",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x9edac8819af1ba913820B0a02f990a671251204c",
    "0x0000000000000000000000000000000000000000",
    0,
    0
  ],
  "numDeployments": 2,
  "solcInputHash": "febae2f5ee38ffa88ea609a85ab03b01",
  "metadata": "{\"compiler\":{\"version\":\"0.7.1+commit.f4a555be\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"authorizer\",\"type\":\"address\"},{\"internalType\":\"contract IWETH\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pauseWindowDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferPeriodDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IAuthorizer\",\"name\":\"newAuthorizer\",\"type\":\"address\"}],\"name\":\"AuthorizerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExternalBalanceTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IFlashLoanRecipient\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"FlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"delta\",\"type\":\"int256\"}],\"name\":\"InternalBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"PausedStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"deltas\",\"type\":\"int256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"protocolFeeAmounts\",\"type\":\"uint256[]\"}],\"name\":\"PoolBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"cashDelta\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"managedDelta\",\"type\":\"int256\"}],\"name\":\"PoolBalanceManaged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IVault.PoolSpecialization\",\"name\":\"specialization\",\"type\":\"uint8\"}],\"name\":\"PoolRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"RelayerApprovalChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"TokensDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"assetManagers\",\"type\":\"address[]\"}],\"name\":\"TokensRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IVault.SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assetInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IVault.BatchSwapStep[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"},{\"internalType\":\"int256[]\",\"name\":\"limits\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"batchSwap\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"assetDeltas\",\"type\":\"int256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"deregisterTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.ExitPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFlashLoanRecipient\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"getActionId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorizer\",\"outputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getInternalBalance\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNextNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPausedState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pauseWindowEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferPeriodEndTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"enum IVault.PoolSpecialization\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPoolTokenInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastChangeBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetManager\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"getPoolTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastChangeBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolFeesCollector\",\"outputs\":[{\"internalType\":\"contract IProtocolFeesCollector\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"hasApprovedRelayer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.JoinPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum IVault.PoolBalanceOpKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.PoolBalanceOp[]\",\"name\":\"ops\",\"type\":\"tuple[]\"}],\"name\":\"managePoolBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum IVault.UserBalanceOpKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"contract IAsset\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct IVault.UserBalanceOp[]\",\"name\":\"ops\",\"type\":\"tuple[]\"}],\"name\":\"manageUserBalance\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IVault.SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assetInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IVault.BatchSwapStep[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"}],\"name\":\"queryBatchSwap\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IVault.PoolSpecialization\",\"name\":\"specialization\",\"type\":\"uint8\"}],\"name\":\"registerPool\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"assetManagers\",\"type\":\"address[]\"}],\"name\":\"registerTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"newAuthorizer\",\"type\":\"address\"}],\"name\":\"setAuthorizer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setRelayerApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"enum IVault.SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"contract IAsset\",\"name\":\"assetIn\",\"type\":\"address\"},{\"internalType\":\"contract IAsset\",\"name\":\"assetOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IVault.SingleSwap\",\"name\":\"singleSwap\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCalculated\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"details\":\"The `Vault` is Balancer V2's core contract. A single instance of it exists for the entire network, and it is the entity used to interact with Pools by Liquidity Providers who join and exit them, Traders who swap, and Asset Managers who withdraw and deposit tokens. The `Vault`'s source code is split among a number of sub-contracts, with the goal of improving readability and making understanding the system easier. Most sub-contracts have been marked as `abstract` to explicitly indicate that only the full `Vault` is meant to be deployed. Roughly speaking, these are the contents of each sub-contract:  - `AssetManagers`: Pool token Asset Manager registry, and Asset Manager interactions.  - `Fees`: set and compute protocol fees.  - `FlashLoans`: flash loan transfers and fees.  - `PoolBalances`: Pool joins and exits.  - `PoolRegistry`: Pool registration, ID management, and basic queries.  - `PoolTokens`: Pool token registration and registration, and balance queries.  - `Swaps`: Pool swaps.  - `UserBalance`: manage user balances (Internal Balance operations and external balance transfers)  - `VaultAuthorization`: access control, relayers and signature validation. Additionally, the different Pool specializations are handled by the `GeneralPoolsBalance`, `MinimalSwapInfoPoolsBalance` and `TwoTokenPoolsBalance` sub-contracts, which in turn make use of the `BalanceAllocation` library. The most important goal of the `Vault` is to make token swaps use as little gas as possible. This is reflected in a multitude of design decisions, from minor things like the format used to store Pool IDs, to major features such as the different Pool specialization settings. Finally, the large number of tasks carried out by the Vault means its bytecode is very large, close to exceeding the contract size limit imposed by EIP 170 (https://eips.ethereum.org/EIPS/eip-170). Manual tuning of the source code was required to improve code generation and bring the bytecode size below this limit. This includes extensive utilization of `internal` functions (particularly inside modifiers), usage of named return arguments, dedicated storage access methods, dynamic revert reason generation, and usage of inline assembly, to name a few.\",\"kind\":\"dev\",\"methods\":{\"WETH()\":{\"details\":\"Returns the Vault's WETH instance.\"},\"batchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool),int256[],uint256)\":{\"details\":\"Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either the amount of tokens sent to or received from the Pool, depending on the `kind` value. Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at the same index in the `assets` array. Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or `amountOut` depending on the swap kind. Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`. The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses, or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault. Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies the minimum or maximum amount of each token the vault is allowed to transfer. `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the equivalent `swap` call. Emits `Swap` events.\"},\"deregisterTokens(bytes32,address[])\":{\"details\":\"Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract. Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens must be deregistered in the same `deregisterTokens` call. A deregistered token can be re-registered later on, possibly with a different Asset Manager. Emits a `TokensDeregistered` event.\"},\"exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))\":{\"details\":\"Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see `getPoolTokenInfo`). If the caller is not `sender`, it must be an authorized relayer for them. The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault: it just enforces these minimums. If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit. `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final `assets` array might not be sorted. Pools with no registered tokens cannot be exited. If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise, an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to do so will trigger a revert. `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the `tokens` array. This array must match the Pool's registered tokens. This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement their own custom logic. This typically requires additional information from the user (such as the expected number of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and passed directly to the Pool's contract. Emits a `PoolBalanceChanged` event.\"},\"flashLoan(address,address[],uint256[],bytes)\":{\"details\":\"Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it, and then reverting unless the tokens plus a proportional protocol fee have been returned. The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount for each token contract. `tokens` must be sorted in ascending order. The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the `receiveFlashLoan` call. Emits `FlashLoan` events.\"},\"getActionId(bytes4)\":{\"details\":\"Returns the action identifier associated with the external function described by `selector`.\"},\"getAuthorizer()\":{\"details\":\"Returns the Vault's Authorizer.\"},\"getDomainSeparator()\":{\"details\":\"Returns the EIP712 domain separator.\"},\"getInternalBalance(address,address[])\":{\"details\":\"Returns `user`'s Internal Balance for a set of tokens.\"},\"getNextNonce(address)\":{\"details\":\"Returns the next nonce used by an address to sign messages.\"},\"getPausedState()\":{\"details\":\"Returns the current contract pause status, as well as the end times of the Pause Window and Buffer Period.\"},\"getPool(bytes32)\":{\"details\":\"Returns a Pool's contract address and specialization setting.\"},\"getPoolTokenInfo(bytes32,address)\":{\"details\":\"Returns detailed information for a Pool's registered token. `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token` equals the sum of `cash` and `managed`. Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`, `managed` or `total` balance to be greater than 2^112 - 1. `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a change for this purpose, and will update `lastChangeBlock`. `assetManager` is the Pool's token Asset Manager.\"},\"getPoolTokens(bytes32)\":{\"details\":\"Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of the tokens' `balances` changed. The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order. If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same order as passed to `registerTokens`. Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo` instead.\"},\"getProtocolFeesCollector()\":{\"details\":\"Returns the current protocol fee module.\"},\"hasApprovedRelayer(address,address)\":{\"details\":\"Returns true if `user` has approved `relayer` to act as a relayer for them.\"},\"joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))\":{\"details\":\"Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized Pool shares. If the caller is not `sender`, it must be an authorized relayer for them. The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces these maximums. If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent back to the caller (not the sender, which is important for relayers). `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final `assets` array might not be sorted. Pools with no registered tokens cannot be joined. If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be withdrawn from Internal Balance: attempting to do so will trigger a revert. This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement their own custom logic. This typically requires additional information from the user (such as the expected number of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed directly to the Pool's contract, as is `recipient`. Emits a `PoolBalanceChanged` event.\"},\"managePoolBalance((uint8,bytes32,address,uint256)[])\":{\"details\":\"Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates. Pool Balance management features batching, which means a single contract call can be used to perform multiple operations of different kinds, with different Pools and tokens, at once. For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\"},\"manageUserBalance((uint8,address,uint256,address,address)[])\":{\"details\":\"Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer) and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as it lets integrators reuse a user's Vault allowance. For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\"},\"queryBatchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool))\":{\"details\":\"Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result. Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH) the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it receives are the same that an equivalent `batchSwap` call would receive. Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct. This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens, approve them for the Vault, or even know a user's address. Note that this function is not 'view' (due to implementation details): the client code must explicitly execute eth_call instead of eth_sendTransaction.\"},\"registerPool(uint8)\":{\"details\":\"Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be changed. The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`, depending on the chosen specialization setting. This contract is known as the Pool's contract. Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words, multiple Pools may share the same contract. Emits a `PoolRegistered` event.\"},\"registerTokens(bytes32,address[],address[])\":{\"details\":\"Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract. Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens, exit by receiving registered tokens, and can only swap registered tokens. Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in ascending order. The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`, depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore expected to be highly secured smart contracts with sound design principles, and the decision to register an Asset Manager should not be made lightly. Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset Manager is set, it cannot be changed except by deregistering the associated token and registering again with a different Asset Manager. Emits a `TokensRegistered` event.\"},\"setAuthorizer(address)\":{\"details\":\"Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this. Emits an `AuthorizerChanged` event.\"},\"setPaused(bool)\":{\"details\":\"Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an error in some part of the system. The Vault can only be paused during an initial time period, after which pausing is forever disabled. While the contract is paused, the following features are disabled: - depositing and transferring internal balance - transferring external balance (using the Vault's allowance) - swaps - joining Pools - Asset Manager interactions Internal Balance can still be withdrawn, and Pools exited.\"},\"setRelayerApproval(address,address,bool)\":{\"details\":\"Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise. Emits a `RelayerApprovalChanged` event.\"},\"swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)\":{\"details\":\"Performs a swap with a single Pool. If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens taken from the Pool, which must be greater than or equal to `limit`. If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens sent to the Pool, which must be less than or equal to `limit`. Internal Balance usage and the recipient are determined by the `funds` struct. Emits a `Swap` event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/vault/Vault.sol\":\"Vault\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":9999},\"remappings\":[]},\"sources\":{\"contracts/Authentication.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\nimport \\\"./IAuthentication.sol\\\";\\n\\n/**\\n * @dev Building block for performing access control on external functions.\\n *\\n * This contract is used via the `authenticate` modifier (or the `_authenticateCaller` function), which can be applied\\n * to external functions to only make them callable by authorized accounts.\\n *\\n * Derived contracts must implement the `_canPerform` function, which holds the actual access control logic.\\n */\\nabstract contract Authentication is IAuthentication {\\n    bytes32 private immutable _actionIdDisambiguator;\\n\\n    /**\\n     * @dev The main purpose of the `actionIdDisambiguator` is to prevent accidental function selector collisions in\\n     * multi contract systems.\\n     *\\n     * There are two main uses for it:\\n     *  - if the contract is a singleton, any unique identifier can be used to make the associated action identifiers\\n     *    unique. The contract's own address is a good option.\\n     *  - if the contract belongs to a family that shares action identifiers for the same functions, an identifier\\n     *    shared by the entire family (and no other contract) should be used instead.\\n     */\\n    constructor(bytes32 actionIdDisambiguator) {\\n        _actionIdDisambiguator = actionIdDisambiguator;\\n    }\\n\\n    /**\\n     * @dev Reverts unless the caller is allowed to call this function. Should only be applied to external functions.\\n     */\\n    modifier authenticate() {\\n        _authenticateCaller();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts unless the caller is allowed to call the entry point function.\\n     */\\n    function _authenticateCaller() internal view {\\n        bytes32 actionId = getActionId(msg.sig);\\n        _require(_canPerform(actionId, msg.sender), Errors.SENDER_NOT_ALLOWED);\\n    }\\n\\n    function getActionId(bytes4 selector) public view override returns (bytes32) {\\n        // Each external function is dynamically assigned an action identifier as the hash of the disambiguator and the\\n        // function selector. Disambiguation is necessary to avoid potential collisions in the function selectors of\\n        // multiple contracts.\\n        return keccak256(abi.encodePacked(_actionIdDisambiguator, selector));\\n    }\\n\\n    function _canPerform(bytes32 actionId, address user) internal view virtual returns (bool);\\n}\\n\",\"keccak256\":\"0xea892213ec2967f53e26a0dd833bde01e4d9b6e49dd91e6c59ff00044f83c28d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/BalancerErrors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n// solhint-disable\\n\\n/**\\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\n * supported.\\n */\\nfunction _require(bool condition, uint256 errorCode) pure {\\n    if (!condition) _revert(errorCode);\\n}\\n\\n/**\\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\n */\\nfunction _revert(uint256 errorCode) pure {\\n    // We're going to dynamically create a revert string based on the error code, with the following format:\\n    // 'BAL#{errorCode}'\\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\\n    //\\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\\n    // number (8 to 16 bits) than the individual string characters.\\n    //\\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\\n    assembly {\\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\\n        // the '0' character.\\n\\n        let units := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let tenths := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let hundreds := add(mod(errorCode, 10), 0x30)\\n\\n        // With the individual characters, we can now construct the full string. The \\\"BAL#\\\" part is a known constant\\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\\n        // characters to it, each shifted by a multiple of 8.\\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\\n        // array).\\n\\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\\n\\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\\n        // message will have the following layout:\\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\\n\\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\\n        // The string length is fixed: 7 characters.\\n        mstore(0x24, 7)\\n        // Finally, the string itself is stored.\\n        mstore(0x44, revertReason)\\n\\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\\n        revert(0, 100)\\n    }\\n}\\n\\nlibrary Errors {\\n    // Math\\n    uint256 internal constant ADD_OVERFLOW = 0;\\n    uint256 internal constant SUB_OVERFLOW = 1;\\n    uint256 internal constant SUB_UNDERFLOW = 2;\\n    uint256 internal constant MUL_OVERFLOW = 3;\\n    uint256 internal constant ZERO_DIVISION = 4;\\n    uint256 internal constant DIV_INTERNAL = 5;\\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\\n    uint256 internal constant INVALID_EXPONENT = 9;\\n\\n    // Input\\n    uint256 internal constant OUT_OF_BOUNDS = 100;\\n    uint256 internal constant UNSORTED_ARRAY = 101;\\n    uint256 internal constant UNSORTED_TOKENS = 102;\\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\\n    uint256 internal constant ZERO_TOKEN = 104;\\n\\n    // Shared pools\\n    uint256 internal constant MIN_TOKENS = 200;\\n    uint256 internal constant MAX_TOKENS = 201;\\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\\n    uint256 internal constant MINIMUM_BPT = 204;\\n    uint256 internal constant CALLER_NOT_VAULT = 205;\\n    uint256 internal constant UNINITIALIZED = 206;\\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\\n    uint256 internal constant EXPIRED_PERMIT = 209;\\n    uint256 internal constant NOT_TWO_TOKENS = 210;\\n\\n    // Pools\\n    uint256 internal constant MIN_AMP = 300;\\n    uint256 internal constant MAX_AMP = 301;\\n    uint256 internal constant MIN_WEIGHT = 302;\\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\\n    uint256 internal constant MAX_IN_RATIO = 304;\\n    uint256 internal constant MAX_OUT_RATIO = 305;\\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\\n    uint256 internal constant INVALID_TOKEN = 309;\\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\\n    uint256 internal constant ZERO_INVARIANT = 311;\\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\\n    uint256 internal constant ORACLE_BAD_SECS = 316;\\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\\n    uint256 internal constant SWAPS_DISABLED = 327;\\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\\n    uint256 internal constant UNHANDLED_BY_INVESTMENT_POOL = 339;\\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\\n    uint256 internal constant INVALID_INITIALIZATION = 342;\\n\\n    // Lib\\n    uint256 internal constant REENTRANCY = 400;\\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\\n    uint256 internal constant PAUSED = 402;\\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\\n\\n    // Vault\\n    uint256 internal constant INVALID_POOL_ID = 500;\\n    uint256 internal constant CALLER_NOT_POOL = 501;\\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\\n    uint256 internal constant INVALID_SIGNATURE = 504;\\n    uint256 internal constant EXIT_BELOW_MIN = 505;\\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\\n    uint256 internal constant SWAP_LIMIT = 507;\\n    uint256 internal constant SWAP_DEADLINE = 508;\\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\\n    uint256 internal constant INSUFFICIENT_ETH = 516;\\n    uint256 internal constant UNALLOCATED_ETH = 517;\\n    uint256 internal constant ETH_TRANSFER = 518;\\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\\n    uint256 internal constant TOKENS_MISMATCH = 520;\\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\\n    uint256 internal constant POOL_NO_TOKENS = 527;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\\n\\n    // Fees\\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\\n}\\n\",\"keccak256\":\"0x7a697c1ffbd94649e71264715963d45ea6a2d8f725a059c61446062018c60afb\",\"license\":\"GPL-3.0-or-later\"},\"contracts/ERC20/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        _require(address(this).balance >= amount, Errors.ADDRESS_INSUFFICIENT_BALANCE);\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        _require(success, Errors.ADDRESS_CANNOT_SEND_VALUE);\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        _require(isContract(target), Errors.CALL_TO_NON_CONTRACT);\\n\\n        (bool success, bytes memory returndata) = target.call(data);\\n        return verifyCallResult(success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling up the\\n     * revert reason or using the one provided.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                _revert(Errors.LOW_LEVEL_CALL_FAILED);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9750992b04f27f260d701a3cb920f3b6d5d9544c34ddda7a86fc352973840020\",\"license\":\"MIT\"},\"contracts/ERC20/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _HASHED_NAME = keccak256(bytes(name));\\n        _HASHED_VERSION = keccak256(bytes(version));\\n        _TYPE_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _domainSeparatorV4(), structHash));\\n    }\\n\\n    function _getChainId() private view returns (uint256 chainId) {\\n        // Silence state mutability warning without generating bytecode.\\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\\n        // https://github.com/ethereum/solidity/issues/2691\\n        this;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0cf3ec5d6130aac057e69df14b1ff87baf9c6c2cb13bc545952def004e629ac0\",\"license\":\"MIT\"},\"contracts/ERC20/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Based on the EnumerableMap library from OpenZeppelin Contracts, altered to include the following:\\n//  * a map from IERC20 to bytes32\\n//  * entries are stored in mappings instead of arrays, reducing implicit storage reads for out-of-bounds checks\\n//  * unchecked_at and unchecked_valueAt, which allow for more gas efficient data reads in some scenarios\\n//  * indexOf, unchecked_indexOf and unchecked_setAt, which allow for more gas efficient data writes in some scenarios\\n//\\n// Additionally, the base private functions that work on bytes32 were removed and replaced with a native implementation\\n// for IERC20 keys, to reduce bytecode size and runtime costs.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\nimport \\\"../BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n */\\nlibrary EnumerableMap {\\n    // The original OpenZeppelin implementation uses a generic Map type with bytes32 keys: this was replaced with\\n    // IERC20ToBytes32Map and IERC20ToUint256Map, resulting in more dense bytecode (as long as each contract only uses\\n    // one of these - there'll otherwise be duplicated code).\\n\\n    // IERC20ToBytes32Map\\n\\n    struct IERC20ToBytes32MapEntry {\\n        IERC20 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct IERC20ToBytes32Map {\\n        // Number of entries in the map\\n        uint256 _length;\\n        // Storage of map keys and values\\n        mapping(uint256 => IERC20ToBytes32MapEntry) _entries;\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping(IERC20 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        IERC20ToBytes32Map storage map,\\n        IERC20 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to !contains(map, key)\\n        if (keyIndex == 0) {\\n            uint256 previousLength = map._length;\\n            map._entries[previousLength] = IERC20ToBytes32MapEntry({ _key: key, _value: value });\\n            map._length = previousLength + 1;\\n\\n            // The entry is stored at previousLength, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = previousLength + 1;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via\\n     * {unchecked_indexOf}, and it should be noted that key indices may change when calling {set} or {remove}. O(1).\\n     *\\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_setAt(\\n        IERC20ToBytes32Map storage map,\\n        uint256 index,\\n        bytes32 value\\n    ) internal {\\n        map._entries[index]._value = value;\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(IERC20ToBytes32Map storage map, IERC20 key) internal returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to contains(map, key)\\n        if (keyIndex != 0) {\\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\\n            // one at the highest index, and then remove this last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the pseudo-array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._length - 1;\\n\\n            // The swap is only necessary if we're not removing the last element\\n            if (toDeleteIndex != lastIndex) {\\n                IERC20ToBytes32MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n                // Move the last entry to the index where the entry to delete is\\n                map._entries[toDeleteIndex] = lastEntry;\\n                // Update the index for the moved entry\\n                map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n            }\\n\\n            // Delete the slot where the moved entry was stored\\n            delete map._entries[lastIndex];\\n            map._length = lastIndex;\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(IERC20ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._length;\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\\n        _require(map._length > index, Errors.OUT_OF_BOUNDS);\\n        return unchecked_at(map, index);\\n    }\\n\\n    /**\\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is equal or larger\\n     * than {length}). O(1).\\n     *\\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\\n        IERC20ToBytes32MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Same as {unchecked_At}, except it only returns the value and not the key (performing one less storage\\n     * read). O(1).\\n     */\\n    function unchecked_valueAt(IERC20ToBytes32Map storage map, uint256 index) internal view returns (bytes32) {\\n        return map._entries[index]._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map. Reverts with `errorCode` otherwise.\\n     */\\n    function get(\\n        IERC20ToBytes32Map storage map,\\n        IERC20 key,\\n        uint256 errorCode\\n    ) internal view returns (bytes32) {\\n        uint256 index = map._indexes[key];\\n        _require(index > 0, errorCode);\\n        return unchecked_valueAt(map, index - 1);\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key`.\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function indexOf(\\n        IERC20ToBytes32Map storage map,\\n        IERC20 key,\\n        uint256 errorCode\\n    ) internal view returns (uint256) {\\n        uint256 uncheckedIndex = unchecked_indexOf(map, key);\\n        _require(uncheckedIndex != 0, errorCode);\\n        return uncheckedIndex - 1;\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key` **plus one**. Does not revert if the key is not in the map, and returns 0\\n     * instead.\\n     */\\n    function unchecked_indexOf(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (uint256) {\\n        return map._indexes[key];\\n    }\\n\\n    // IERC20ToUint256Map\\n\\n    struct IERC20ToUint256MapEntry {\\n        IERC20 _key;\\n        uint256 _value;\\n    }\\n\\n    struct IERC20ToUint256Map {\\n        // Number of entries in the map\\n        uint256 _length;\\n        // Storage of map keys and values\\n        mapping(uint256 => IERC20ToUint256MapEntry) _entries;\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping(IERC20 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        IERC20ToUint256Map storage map,\\n        IERC20 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to !contains(map, key)\\n        if (keyIndex == 0) {\\n            uint256 previousLength = map._length;\\n            map._entries[previousLength] = IERC20ToUint256MapEntry({ _key: key, _value: value });\\n            map._length = previousLength + 1;\\n\\n            // The entry is stored at previousLength, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = previousLength + 1;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via\\n     * {unchecked_indexOf}, and it should be noted that key indices may change when calling {set} or {remove}. O(1).\\n     *\\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_setAt(\\n        IERC20ToUint256Map storage map,\\n        uint256 index,\\n        uint256 value\\n    ) internal {\\n        map._entries[index]._value = value;\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(IERC20ToUint256Map storage map, IERC20 key) internal returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to contains(map, key)\\n        if (keyIndex != 0) {\\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\\n            // one at the highest index, and then remove this last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the pseudo-array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._length - 1;\\n\\n            // The swap is only necessary if we're not removing the last element\\n            if (toDeleteIndex != lastIndex) {\\n                IERC20ToUint256MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n                // Move the last entry to the index where the entry to delete is\\n                map._entries[toDeleteIndex] = lastEntry;\\n                // Update the index for the moved entry\\n                map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n            }\\n\\n            // Delete the slot where the moved entry was stored\\n            delete map._entries[lastIndex];\\n            map._length = lastIndex;\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(IERC20ToUint256Map storage map, IERC20 key) internal view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(IERC20ToUint256Map storage map) internal view returns (uint256) {\\n        return map._length;\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(IERC20ToUint256Map storage map, uint256 index) internal view returns (IERC20, uint256) {\\n        _require(map._length > index, Errors.OUT_OF_BOUNDS);\\n        return unchecked_at(map, index);\\n    }\\n\\n    /**\\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is equal or larger\\n     * than {length}). O(1).\\n     *\\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_at(IERC20ToUint256Map storage map, uint256 index) internal view returns (IERC20, uint256) {\\n        IERC20ToUint256MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Same as {unchecked_At}, except it only returns the value and not the key (performing one less storage\\n     * read). O(1).\\n     */\\n    function unchecked_valueAt(IERC20ToUint256Map storage map, uint256 index) internal view returns (uint256) {\\n        return map._entries[index]._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map. Reverts with `errorCode` otherwise.\\n     */\\n    function get(\\n        IERC20ToUint256Map storage map,\\n        IERC20 key,\\n        uint256 errorCode\\n    ) internal view returns (uint256) {\\n        uint256 index = map._indexes[key];\\n        _require(index > 0, errorCode);\\n        return unchecked_valueAt(map, index - 1);\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key`.\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function indexOf(\\n        IERC20ToUint256Map storage map,\\n        IERC20 key,\\n        uint256 errorCode\\n    ) internal view returns (uint256) {\\n        uint256 uncheckedIndex = unchecked_indexOf(map, key);\\n        _require(uncheckedIndex != 0, errorCode);\\n        return uncheckedIndex - 1;\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key` **plus one**. Does not revert if the key is not in the map, and returns 0\\n     * instead.\\n     */\\n    function unchecked_indexOf(IERC20ToUint256Map storage map, IERC20 key) internal view returns (uint256) {\\n        return map._indexes[key];\\n    }\\n}\\n\",\"keccak256\":\"0x7246d380315c6a43dd2a107c1fd69893a462c6bfbec05492f9ee74e5caf7c875\",\"license\":\"MIT\"},\"contracts/ERC20/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Based on the EnumerableSet library from OpenZeppelin Contracts, altered to remove the base private functions that\\n// work on bytes32, replacing them with a native implementation for address values, to reduce bytecode size and runtime\\n// costs.\\n// The `unchecked_at` function was also added, which allows for more gas efficient data reads in some scenarios.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // The original OpenZeppelin implementation uses a generic Set type with bytes32 values: this was replaced with\\n    // AddressSet, which uses address keys natively, resulting in more dense bytecode.\\n\\n    struct AddressSet {\\n        // Storage of set values\\n        address[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(address => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        if (!contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // The swap is only necessary if we're not removing the last element\\n            if (toDeleteIndex != lastIndex) {\\n                address lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        _require(set._values.length > index, Errors.OUT_OF_BOUNDS);\\n        return unchecked_at(set, index);\\n    }\\n\\n    /**\\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the set (i.e. if it is equal or larger\\n     * than {length}). O(1).\\n     *\\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return set._values[index];\\n    }\\n\\n    function rawIndexOf(AddressSet storage set, address value) internal view returns (uint256) {\\n        return set._indexes[value] - 1;\\n    }\\n}\\n\",\"keccak256\":\"0xed7f64289a2e945b1bb38bcab43e794bc92e5a2650b9de56d6f6cf05ff0184e2\",\"license\":\"MIT\"},\"contracts/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xd828a935a72a6d182912abba290e4debb8c684c36fd756088f7acb30e0b2bb76\",\"license\":\"MIT\"},\"contracts/ERC20/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        _require(value < 2**255, Errors.SAFE_CAST_VALUE_CANT_FIT_INT256);\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xa65b80cc254ba115ce64fa5cf25ff982c726244eb1c4525f6352146b9e58b82f\",\"license\":\"MIT\"},\"contracts/ERC20/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Based on the ReentrancyGuard library from OpenZeppelin Contracts, altered to reduce gas costs.\\n// The `safeTransfer` and `safeTransferFrom` functions assume that `token` is a contract (an account with code), and\\n// work differently from the OpenZeppelin version if it is not.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     *\\n     * WARNING: `token` is assumed to be a contract: calls to EOAs will *not* revert.\\n     */\\n    function _callOptionalReturn(address token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n        (bool success, bytes memory returndata) = token.call(data);\\n\\n        // If the low-level call didn't succeed we return whatever was returned from it.\\n        assembly {\\n            if eq(success, 0) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        // Finally we check the returndata size is either zero or true - note that this check will always pass for EOAs\\n        _require(returndata.length == 0 || abi.decode(returndata, (bool)), Errors.SAFE_ERC20_CALL_FAILED);\\n    }\\n}\\n\",\"keccak256\":\"0x7ec0492420f7c7ea4b2e5810f96e295d77edc3998031a5275c710a4e31b014a5\",\"license\":\"MIT\"},\"contracts/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./LogExpMath.sol\\\";\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((aInflated - 1) / b) + 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return sub(raw, maxError);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        return add(raw, maxError);\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf11b46d44740391d1bf1454e1ea3ccaa743e131599e675ab867a00165a306a44\",\"license\":\"GPL-3.0-or-later\"},\"contracts/IAuthentication.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IAuthentication {\\n    /**\\n     * @dev Returns the action identifier associated with the external function described by `selector`.\\n     */\\n    function getActionId(bytes4 selector) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xfd687ced203d2c6da8189792e1719a5182faf45956129388b231ee76740b99a6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/InputHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ERC20/IERC20.sol\\\";\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\nlibrary InputHelpers {\\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\\n        _require(a == b, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureInputLengthMatch(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) internal pure {\\n        _require(a == b && b == c, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\\n        address[] memory addressArray;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addressArray := array\\n        }\\n        ensureArrayIsSorted(addressArray);\\n    }\\n\\n    function ensureArrayIsSorted(address[] memory array) internal pure {\\n        if (array.length < 2) {\\n            return;\\n        }\\n\\n        address previous = array[0];\\n        for (uint256 i = 1; i < array.length; ++i) {\\n            address current = array[i];\\n            _require(previous < current, Errors.UNSORTED_ARRAY);\\n            previous = current;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9687cff775a4c7e280c656b24ec084320b736673c77b756a50741c149c74e6da\",\"license\":\"GPL-3.0-or-later\"},\"contracts/LogExpMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\\n// documentation files (the \\u201cSoftware\\u201d), to deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\\n// Software.\\n\\n// THE SOFTWARE IS PROVIDED \\u201cAS IS\\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        if (y == 0) {\\n            // We solve the 0^0 indetermination by making it equal one.\\n            return uint256(ONE_18);\\n        }\\n\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n        // x^y = exp(y * ln(x)).\\n\\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\\n        int256 x_int256 = int256(x);\\n\\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\\n        int256 y_int256 = int256(y);\\n\\n        int256 logx_times_y;\\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n            int256 ln_36_x = _ln_36(x_int256);\\n\\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n            // (downscaled) last 18 decimals.\\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\\n        } else {\\n            logx_times_y = _ln(x_int256) * y_int256;\\n        }\\n        logx_times_y /= ONE_18;\\n\\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n        _require(\\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n            Errors.PRODUCT_OUT_OF_BOUNDS\\n        );\\n\\n        return uint256(exp(logx_times_y));\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\\n\\n        if (x < 0) {\\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n            // Fixed point division requires multiplying by ONE_18.\\n            return ((ONE_18 * ONE_18) / exp(-x));\\n        }\\n\\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n        // decomposition.\\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest x_n.\\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n        // decomposition.\\n\\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n        // it and compute the accumulated product.\\n\\n        int256 firstAN;\\n        if (x >= x0) {\\n            x -= x0;\\n            firstAN = a0;\\n        } else if (x >= x1) {\\n            x -= x1;\\n            firstAN = a1;\\n        } else {\\n            firstAN = 1; // One with no decimal places\\n        }\\n\\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n        // smaller terms.\\n        x *= 100;\\n\\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n        int256 product = ONE_20;\\n\\n        if (x >= x2) {\\n            x -= x2;\\n            product = (product * a2) / ONE_20;\\n        }\\n        if (x >= x3) {\\n            x -= x3;\\n            product = (product * a3) / ONE_20;\\n        }\\n        if (x >= x4) {\\n            x -= x4;\\n            product = (product * a4) / ONE_20;\\n        }\\n        if (x >= x5) {\\n            x -= x5;\\n            product = (product * a5) / ONE_20;\\n        }\\n        if (x >= x6) {\\n            x -= x6;\\n            product = (product * a6) / ONE_20;\\n        }\\n        if (x >= x7) {\\n            x -= x7;\\n            product = (product * a7) / ONE_20;\\n        }\\n        if (x >= x8) {\\n            x -= x8;\\n            product = (product * a8) / ONE_20;\\n        }\\n        if (x >= x9) {\\n            x -= x9;\\n            product = (product * a9) / ONE_20;\\n        }\\n\\n        // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n        // The first term is simply x.\\n        term = x;\\n        seriesSum += term;\\n\\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n        term = ((term * x) / ONE_20) / 2;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 3;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 4;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 5;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 6;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 7;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 8;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 9;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 10;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 11;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 12;\\n        seriesSum += term;\\n\\n        // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n        // and then drop two digits to return an 18 decimal value.\\n\\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n        // upscaling.\\n\\n        int256 logBase;\\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n            logBase = _ln_36(base);\\n        } else {\\n            logBase = _ln(base) * ONE_18;\\n        }\\n\\n        int256 logArg;\\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n            logArg = _ln_36(arg);\\n        } else {\\n            logArg = _ln(arg) * ONE_18;\\n        }\\n\\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n        return (logArg * ONE_18) / logBase;\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        // The real natural logarithm is not defined for negative numbers or zero.\\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n            return _ln_36(a) / ONE_18;\\n        } else {\\n            return _ln(a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        if (a < ONE_18) {\\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n            // Fixed point division requires multiplying by ONE_18.\\n            return (-_ln((ONE_18 * ONE_18) / a));\\n        }\\n\\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest a_n.\\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n        // ONE_18 to convert them to fixed point.\\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n        // by it and compute the accumulated sum.\\n\\n        int256 sum = 0;\\n        if (a >= a0 * ONE_18) {\\n            a /= a0; // Integer, not fixed point division\\n            sum += x0;\\n        }\\n\\n        if (a >= a1 * ONE_18) {\\n            a /= a1; // Integer, not fixed point division\\n            sum += x1;\\n        }\\n\\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n        sum *= 100;\\n        a *= 100;\\n\\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n        if (a >= a2) {\\n            a = (a * ONE_20) / a2;\\n            sum += x2;\\n        }\\n\\n        if (a >= a3) {\\n            a = (a * ONE_20) / a3;\\n            sum += x3;\\n        }\\n\\n        if (a >= a4) {\\n            a = (a * ONE_20) / a4;\\n            sum += x4;\\n        }\\n\\n        if (a >= a5) {\\n            a = (a * ONE_20) / a5;\\n            sum += x5;\\n        }\\n\\n        if (a >= a6) {\\n            a = (a * ONE_20) / a6;\\n            sum += x6;\\n        }\\n\\n        if (a >= a7) {\\n            a = (a * ONE_20) / a7;\\n            sum += x7;\\n        }\\n\\n        if (a >= a8) {\\n            a = (a * ONE_20) / a8;\\n            sum += x8;\\n        }\\n\\n        if (a >= a9) {\\n            a = (a * ONE_20) / a9;\\n            sum += x9;\\n        }\\n\\n        if (a >= a10) {\\n            a = (a * ONE_20) / a10;\\n            sum += x10;\\n        }\\n\\n        if (a >= a11) {\\n            a = (a * ONE_20) / a11;\\n            sum += x11;\\n        }\\n\\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n        // Let z = (a - 1) / (a + 1).\\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n        // division by ONE_20.\\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n        int256 z_squared = (z * z) / ONE_20;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 11;\\n\\n        // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n        seriesSum *= 2;\\n\\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n        // value.\\n\\n        return (sum + seriesSum) / 100;\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n        // worthwhile.\\n\\n        // First, we transform x to a 36 digit fixed point value.\\n        x *= ONE_18;\\n\\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n        // division by ONE_36.\\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n        int256 z_squared = (z * z) / ONE_36;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 11;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 13;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 15;\\n\\n        // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // All that remains is multiplying by 2 (non fixed point).\\n        return seriesSum * 2;\\n    }\\n}\\n\",\"keccak256\":\"0x3649ab52cd8c59ca022f2798cb7d276b68da284553421323258230becfc7e659\",\"license\":\"MIT\"},\"contracts/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\\n * Adapted from OpenZeppelin's SafeMath library\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers of 256 bits.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers of 256 bits.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        _require(a == 0 || c / a == b, Errors.MUL_OVERFLOW);\\n        return c;\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        bool roundUp\\n    ) internal pure returns (uint256) {\\n        return roundUp ? divUp(a, b) : divDown(a, b);\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n        return a / b;\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            return 1 + (a - 1) / b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x197a9106dedcccfb77dcf5979f7bdd2735dbe4106155ff34b1c2271c9aa5c668\",\"license\":\"MIT\"},\"contracts/misc/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for WETH9.\\n * See https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\\n */\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x927146eb7e703ccd975f90c0880b5c301b8203e06c1455a14c35109c74f2a12d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/ISignaturesValidator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\\n */\\ninterface ISignaturesValidator {\\n    /**\\n     * @dev Returns the EIP712 domain separator.\\n     */\\n    function getDomainSeparator() external view returns (bytes32);\\n\\n    /**\\n     * @dev Returns the next nonce used by an address to sign messages.\\n     */\\n    function getNextNonce(address user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x2fe46b13b7c8bfc6f5c539c0b73d6325813f383f551b71fb6bca8dafd06964e1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/ITemporarilyPausable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface for the TemporarilyPausable helper.\\n */\\ninterface ITemporarilyPausable {\\n    /**\\n     * @dev Emitted every time the pause state changes by `_setPaused`.\\n     */\\n    event PausedStateChanged(bool paused);\\n\\n    /**\\n     * @dev Returns the current paused state.\\n     */\\n    function getPausedState()\\n        external\\n        view\\n        returns (\\n            bool paused,\\n            uint256 pauseWindowEndTime,\\n            uint256 bufferPeriodEndTime\\n        );\\n}\\n\",\"keccak256\":\"0xb3e5b7c63f80b80ef3f0138eac56c397a439bf6b667fc06d5061aa869828b562\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Based on the ReentrancyGuard library from OpenZeppelin Contracts, altered to reduce bytecode size.\\n// Modifier code is inlined by the compiler, which causes its code to appear multiple times in the codebase. By using\\n// private functions, we achieve the same end result with slightly higher runtime gas costs, but reduced bytecode size.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _enterNonReentrant();\\n        _;\\n        _exitNonReentrant();\\n    }\\n\\n    function _enterNonReentrant() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        _require(_status != _ENTERED, Errors.REENTRANCY);\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _exitNonReentrant() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x13b37e6b7a9300c9148f7636075e2c30e356112df2f4130c197a6510feadfeb6\",\"license\":\"MIT\"},\"contracts/utils/SignaturesValidator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"./ISignaturesValidator.sol\\\";\\nimport \\\"../ERC20/EIP712.sol\\\";\\n\\n/**\\n * @dev Utility for signing Solidity function calls.\\n *\\n * This contract relies on the fact that Solidity contracts can be called with extra calldata, and enables\\n * meta-transaction schemes by appending an EIP712 signature of the original calldata at the end.\\n *\\n * Derived contracts must implement the `_typeHash` function to map function selectors to EIP712 structs.\\n */\\nabstract contract SignaturesValidator is ISignaturesValidator, EIP712 {\\n    // The appended data consists of a deadline, plus the [v,r,s] signature. For simplicity, we use a full 256 bit slot\\n    // for each of these values, even if 'v' is typically an 8 bit value.\\n    uint256 internal constant _EXTRA_CALLDATA_LENGTH = 4 * 32;\\n\\n    // Replay attack prevention for each user.\\n    mapping(address => uint256) internal _nextNonce;\\n\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function getDomainSeparator() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    function getNextNonce(address user) external view override returns (uint256) {\\n        return _nextNonce[user];\\n    }\\n\\n    /**\\n     * @dev Reverts with `errorCode` unless a valid signature for `user` was appended to the calldata.\\n     */\\n    function _validateSignature(address user, uint256 errorCode) internal {\\n        uint256 nextNonce = _nextNonce[user]++;\\n        _require(_isSignatureValid(user, nextNonce), errorCode);\\n    }\\n\\n    function _isSignatureValid(address user, uint256 nonce) private view returns (bool) {\\n        uint256 deadline = _deadline();\\n\\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\\n        // solhint-disable-next-line not-rely-on-time\\n        if (deadline < block.timestamp) {\\n            return false;\\n        }\\n\\n        bytes32 typeHash = _typeHash();\\n        if (typeHash == bytes32(0)) {\\n            // Prevent accidental signature validation for functions that don't have an associated type hash.\\n            return false;\\n        }\\n\\n        // All type hashes have this format: (bytes calldata, address sender, uint256 nonce, uint256 deadline).\\n        bytes32 structHash = keccak256(abi.encode(typeHash, keccak256(_calldata()), msg.sender, nonce, deadline));\\n        bytes32 digest = _hashTypedDataV4(structHash);\\n        (uint8 v, bytes32 r, bytes32 s) = _signature();\\n\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n        // ecrecover returns the zero address on recover failure, so we need to handle that explicitly.\\n        return recoveredAddress != address(0) && recoveredAddress == user;\\n    }\\n\\n    /**\\n     * @dev Returns the EIP712 type hash for the current entry point function, which can be identified by its function\\n     * selector (available as `msg.sig`).\\n     *\\n     * The type hash must conform to the following format:\\n     *  <name>(bytes calldata, address sender, uint256 nonce, uint256 deadline)\\n     *\\n     * If 0x00, all signatures will be considered invalid.\\n     */\\n    function _typeHash() internal view virtual returns (bytes32);\\n\\n    /**\\n     * @dev Extracts the signature deadline from extra calldata.\\n     *\\n     * This function returns bogus data if no signature is included.\\n     */\\n    function _deadline() internal pure returns (uint256) {\\n        // The deadline is the first extra argument at the end of the original calldata.\\n        return uint256(_decodeExtraCalldataWord(0));\\n    }\\n\\n    /**\\n     * @dev Extracts the signature parameters from extra calldata.\\n     *\\n     * This function returns bogus data if no signature is included. This is not a security risk, as that data would not\\n     * be considered a valid signature in the first place.\\n     */\\n    function _signature()\\n        internal\\n        pure\\n        returns (\\n            uint8 v,\\n            bytes32 r,\\n            bytes32 s\\n        )\\n    {\\n        // v, r and s are appended after the signature deadline, in that order.\\n        v = uint8(uint256(_decodeExtraCalldataWord(0x20)));\\n        r = _decodeExtraCalldataWord(0x40);\\n        s = _decodeExtraCalldataWord(0x60);\\n    }\\n\\n    /**\\n     * @dev Returns the original calldata, without the extra bytes containing the signature.\\n     *\\n     * This function returns bogus data if no signature is included.\\n     */\\n    function _calldata() internal pure returns (bytes memory result) {\\n        result = msg.data; // A calldata to memory assignment results in memory allocation and copy of contents.\\n        if (result.length > _EXTRA_CALLDATA_LENGTH) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                // We simply overwrite the array length with the reduced one.\\n                mstore(result, sub(calldatasize(), _EXTRA_CALLDATA_LENGTH))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a 256 bit word from 'extra' calldata, at some offset from the expected end of the original calldata.\\n     *\\n     * This function returns bogus data if no signature is included.\\n     */\\n    function _decodeExtraCalldataWord(uint256 offset) private pure returns (bytes32 result) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            result := calldataload(add(sub(calldatasize(), _EXTRA_CALLDATA_LENGTH), offset))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5d52be41f9a662b4da8c68c2248e8c96b1e5f51396dd73244d99fa37305a2c0b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/TemporarilyPausable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"./ITemporarilyPausable.sol\\\";\\n\\n/**\\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\\n * used as an emergency switch in case a security vulnerability or threat is identified.\\n *\\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\\n * analysis later determines there was a false alarm.\\n *\\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\\n *\\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\\n * irreversible.\\n */\\nabstract contract TemporarilyPausable is ITemporarilyPausable {\\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\\n    // solhint-disable not-rely-on-time\\n\\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\\n\\n    uint256 private immutable _pauseWindowEndTime;\\n    uint256 private immutable _bufferPeriodEndTime;\\n\\n    bool private _paused;\\n\\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\\n        _require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, Errors.MAX_PAUSE_WINDOW_DURATION);\\n        _require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, Errors.MAX_BUFFER_PERIOD_DURATION);\\n\\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\\n\\n        _pauseWindowEndTime = pauseWindowEndTime;\\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is paused.\\n     */\\n    modifier whenNotPaused() {\\n        _ensureNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\\n     * Period.\\n     */\\n    function getPausedState()\\n        external\\n        view\\n        override\\n        returns (\\n            bool paused,\\n            uint256 pauseWindowEndTime,\\n            uint256 bufferPeriodEndTime\\n        )\\n    {\\n        paused = !_isNotPaused();\\n        pauseWindowEndTime = _getPauseWindowEndTime();\\n        bufferPeriodEndTime = _getBufferPeriodEndTime();\\n    }\\n\\n    /**\\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\\n     * unpaused until the end of the Buffer Period.\\n     *\\n     * Once the Buffer Period expires, this function reverts unconditionally.\\n     */\\n    function _setPaused(bool paused) internal {\\n        if (paused) {\\n            _require(block.timestamp < _getPauseWindowEndTime(), Errors.PAUSE_WINDOW_EXPIRED);\\n        } else {\\n            _require(block.timestamp < _getBufferPeriodEndTime(), Errors.BUFFER_PERIOD_EXPIRED);\\n        }\\n\\n        _paused = paused;\\n        emit PausedStateChanged(paused);\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is paused.\\n     */\\n    function _ensureNotPaused() internal view {\\n        _require(_isNotPaused(), Errors.PAUSED);\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is unpaused.\\n     *\\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\\n     * longer accessed.\\n     */\\n    function _isNotPaused() internal view returns (bool) {\\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\\n        return block.timestamp > _getBufferPeriodEndTime() || !_paused;\\n    }\\n\\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\\n\\n    function _getPauseWindowEndTime() private view returns (uint256) {\\n        return _pauseWindowEndTime;\\n    }\\n\\n    function _getBufferPeriodEndTime() private view returns (uint256) {\\n        return _bufferPeriodEndTime;\\n    }\\n}\\n\",\"keccak256\":\"0xc35937fdd276677ad42b538f6a12640b7997131bb3f9a7c918e52e6c05aea42b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/AssetHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../misc/IWETH.sol\\\";\\n\\nimport \\\"./IAsset.sol\\\";\\n\\nabstract contract AssetHelpers {\\n    // solhint-disable-next-line var-name-mixedcase\\n    IWETH private immutable _weth;\\n\\n    // Sentinel value used to indicate WETH with wrapping/unwrapping semantics. The zero address is a good choice for\\n    // multiple reasons: it is cheap to pass as a calldata argument, it is a known invalid token and non-contract, and\\n    // it is an address Pools cannot register as a token.\\n    address private constant _ETH = address(0);\\n\\n    constructor(IWETH weth) {\\n        _weth = weth;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _WETH() internal view returns (IWETH) {\\n        return _weth;\\n    }\\n\\n    /**\\n     * @dev Returns true if `asset` is the sentinel value that represents ETH.\\n     */\\n    function _isETH(IAsset asset) internal pure returns (bool) {\\n        return address(asset) == _ETH;\\n    }\\n\\n    /**\\n     * @dev Translates `asset` into an equivalent IERC20 token address. If `asset` represents ETH, it will be translated\\n     * to the WETH contract.\\n     */\\n    function _translateToIERC20(IAsset asset) internal view returns (IERC20) {\\n        return _isETH(asset) ? _WETH() : _asIERC20(asset);\\n    }\\n\\n    /**\\n     * @dev Same as `_translateToIERC20(IAsset)`, but for an entire array.\\n     */\\n    function _translateToIERC20(IAsset[] memory assets) internal view returns (IERC20[] memory) {\\n        IERC20[] memory tokens = new IERC20[](assets.length);\\n        for (uint256 i = 0; i < assets.length; ++i) {\\n            tokens[i] = _translateToIERC20(assets[i]);\\n        }\\n        return tokens;\\n    }\\n\\n    /**\\n     * @dev Interprets `asset` as an IERC20 token. This function should only be called on `asset` if `_isETH` previously\\n     * returned false for it, that is, if `asset` is guaranteed not to be the ETH sentinel value.\\n     */\\n    function _asIERC20(IAsset asset) internal pure returns (IERC20) {\\n        return IERC20(address(asset));\\n    }\\n}\\n\",\"keccak256\":\"0x63c823344a5d641c3347da44a504e471c43f3f1f97734b23e1e3939df3b86de1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/AssetManagers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Math.sol\\\";\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../InputHelpers.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/SafeERC20.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./UserBalance.sol\\\";\\nimport \\\"./Balances/BalanceAllocation.sol\\\";\\nimport \\\"./Balances/GeneralPoolsBalance.sol\\\";\\nimport \\\"./Balances/MinimalSwapInfoPoolsBalance.sol\\\";\\nimport \\\"./Balances/TwoTokenPoolsBalance.sol\\\";\\n\\nabstract contract AssetManagers is\\n    ReentrancyGuard,\\n    GeneralPoolsBalance,\\n    MinimalSwapInfoPoolsBalance,\\n    TwoTokenPoolsBalance\\n{\\n    using Math for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Stores the Asset Manager for each token of each Pool.\\n    mapping(bytes32 => mapping(IERC20 => address)) internal _poolAssetManagers;\\n\\n    function managePoolBalance(PoolBalanceOp[] memory ops) external override nonReentrant whenNotPaused {\\n        // This variable could be declared inside the loop, but that causes the compiler to allocate memory on each\\n        // loop iteration, increasing gas costs.\\n        PoolBalanceOp memory op;\\n\\n        for (uint256 i = 0; i < ops.length; ++i) {\\n            // By indexing the array only once, we don't spend extra gas in the same bounds check.\\n            op = ops[i];\\n\\n            bytes32 poolId = op.poolId;\\n            _ensureRegisteredPool(poolId);\\n\\n            IERC20 token = op.token;\\n            _require(_isTokenRegistered(poolId, token), Errors.TOKEN_NOT_REGISTERED);\\n            _require(_poolAssetManagers[poolId][token] == msg.sender, Errors.SENDER_NOT_ASSET_MANAGER);\\n\\n            PoolBalanceOpKind kind = op.kind;\\n            uint256 amount = op.amount;\\n            (int256 cashDelta, int256 managedDelta) = _performPoolManagementOperation(kind, poolId, token, amount);\\n\\n            emit PoolBalanceManaged(poolId, msg.sender, token, cashDelta, managedDelta);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs the `kind` Asset Manager operation on a Pool.\\n     *\\n     * Withdrawals will transfer `amount` tokens to the caller, deposits will transfer `amount` tokens from the caller,\\n     * and updates will set the managed balance to `amount`.\\n     *\\n     * Returns a tuple with the 'cash' and 'managed' balance deltas as a result of this call.\\n     */\\n    function _performPoolManagementOperation(\\n        PoolBalanceOpKind kind,\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) private returns (int256, int256) {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n\\n        if (kind == PoolBalanceOpKind.WITHDRAW) {\\n            return _withdrawPoolBalance(poolId, specialization, token, amount);\\n        } else if (kind == PoolBalanceOpKind.DEPOSIT) {\\n            return _depositPoolBalance(poolId, specialization, token, amount);\\n        } else {\\n            // PoolBalanceOpKind.UPDATE\\n            return _updateManagedBalance(poolId, specialization, token, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Moves `amount` tokens from a Pool's 'cash' to 'managed' balance, and transfers them to the caller.\\n     *\\n     * Returns the 'cash' and 'managed' balance deltas as a result of this call, which will be complementary.\\n     */\\n    function _withdrawPoolBalance(\\n        bytes32 poolId,\\n        PoolSpecialization specialization,\\n        IERC20 token,\\n        uint256 amount\\n    ) private returns (int256 cashDelta, int256 managedDelta) {\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            _twoTokenPoolCashToManaged(poolId, token, amount);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _minimalSwapInfoPoolCashToManaged(poolId, token, amount);\\n        } else {\\n            // PoolSpecialization.GENERAL\\n            _generalPoolCashToManaged(poolId, token, amount);\\n        }\\n\\n        if (amount > 0) {\\n            token.safeTransfer(msg.sender, amount);\\n        }\\n\\n        // Since 'cash' and 'managed' are stored as uint112, `amount` is guaranteed to also fit in 112 bits. It will\\n        // therefore always fit in a 256 bit integer.\\n        cashDelta = int256(-amount);\\n        managedDelta = int256(amount);\\n    }\\n\\n    /**\\n     * @dev Moves `amount` tokens from a Pool's 'managed' to 'cash' balance, and transfers them from the caller.\\n     *\\n     * Returns the 'cash' and 'managed' balance deltas as a result of this call, which will be complementary.\\n     */\\n    function _depositPoolBalance(\\n        bytes32 poolId,\\n        PoolSpecialization specialization,\\n        IERC20 token,\\n        uint256 amount\\n    ) private returns (int256 cashDelta, int256 managedDelta) {\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            _twoTokenPoolManagedToCash(poolId, token, amount);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _minimalSwapInfoPoolManagedToCash(poolId, token, amount);\\n        } else {\\n            // PoolSpecialization.GENERAL\\n            _generalPoolManagedToCash(poolId, token, amount);\\n        }\\n\\n        if (amount > 0) {\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n        }\\n\\n        // Since 'cash' and 'managed' are stored as uint112, `amount` is guaranteed to also fit in 112 bits. It will\\n        // therefore always fit in a 256 bit integer.\\n        cashDelta = int256(amount);\\n        managedDelta = int256(-amount);\\n    }\\n\\n    /**\\n     * @dev Sets a Pool's 'managed' balance to `amount`.\\n     *\\n     * Returns the 'cash' and 'managed' balance deltas as a result of this call (the 'cash' delta will always be zero).\\n     */\\n    function _updateManagedBalance(\\n        bytes32 poolId,\\n        PoolSpecialization specialization,\\n        IERC20 token,\\n        uint256 amount\\n    ) private returns (int256 cashDelta, int256 managedDelta) {\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            managedDelta = _setTwoTokenPoolManagedBalance(poolId, token, amount);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            managedDelta = _setMinimalSwapInfoPoolManagedBalance(poolId, token, amount);\\n        } else {\\n            // PoolSpecialization.GENERAL\\n            managedDelta = _setGeneralPoolManagedBalance(poolId, token, amount);\\n        }\\n\\n        cashDelta = 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if `token` is registered for `poolId`.\\n     */\\n    function _isTokenRegistered(bytes32 poolId, IERC20 token) private view returns (bool) {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            return _isTwoTokenPoolTokenRegistered(poolId, token);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            return _isMinimalSwapInfoPoolTokenRegistered(poolId, token);\\n        } else {\\n            // PoolSpecialization.GENERAL\\n            return _isGeneralPoolTokenRegistered(poolId, token);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x42ba8bf5509a3b8bfd520cc6926f1aecdc0efe0366f2e76be09ec476ab9d26a1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/AssetTransfersHandler.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Math.sol\\\";\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/SafeERC20.sol\\\";\\nimport \\\"../ERC20/Address.sol\\\";\\nimport \\\"../misc/IWETH.sol\\\";\\n\\nimport \\\"./IAsset.sol\\\";\\nimport \\\"./IVault.sol\\\";\\n\\nimport \\\"./AssetHelpers.sol\\\";\\n\\nabstract contract AssetTransfersHandler is AssetHelpers {\\n    using SafeERC20 for IERC20;\\n    using Address for address payable;\\n\\n    /**\\n     * @dev Receives `amount` of `asset` from `sender`. If `fromInternalBalance` is true, it first withdraws as much\\n     * as possible from Internal Balance, then transfers any remaining amount.\\n     *\\n     * If `asset` is ETH, `fromInternalBalance` must be false (as ETH cannot be held as internal balance), and the funds\\n     * will be wrapped into WETH.\\n     *\\n     * WARNING: this function does not check that the contract caller has actually supplied any ETH - it is up to the\\n     * caller of this function to check that this is true to prevent the Vault from using its own ETH (though the Vault\\n     * typically doesn't hold any).\\n     */\\n    function _receiveAsset(\\n        IAsset asset,\\n        uint256 amount,\\n        address sender,\\n        bool fromInternalBalance\\n    ) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        if (_isETH(asset)) {\\n            _require(!fromInternalBalance, Errors.INVALID_ETH_INTERNAL_BALANCE);\\n\\n            // The ETH amount to receive is deposited into the WETH contract, which will in turn mint WETH for\\n            // the Vault at a 1:1 ratio.\\n\\n            // A check for this condition is also introduced by the compiler, but this one provides a revert reason.\\n            // Note we're checking for the Vault's total balance, *not* ETH sent in this transaction.\\n            _require(address(this).balance >= amount, Errors.INSUFFICIENT_ETH);\\n            _WETH().deposit{ value: amount }();\\n        } else {\\n            IERC20 token = _asIERC20(asset);\\n\\n            if (fromInternalBalance) {\\n                // We take as many tokens from Internal Balance as possible: any remaining amounts will be transferred.\\n                uint256 deductedBalance = _decreaseInternalBalance(sender, token, amount, true);\\n                // Because `deductedBalance` will be always the lesser of the current internal balance\\n                // and the amount to decrease, it is safe to perform unchecked arithmetic.\\n                amount -= deductedBalance;\\n            }\\n\\n            if (amount > 0) {\\n                token.safeTransferFrom(sender, address(this), amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Sends `amount` of `asset` to `recipient`. If `toInternalBalance` is true, the asset is deposited as Internal\\n     * Balance instead of being transferred.\\n     *\\n     * If `asset` is ETH, `toInternalBalance` must be false (as ETH cannot be held as internal balance), and the funds\\n     * are instead sent directly after unwrapping WETH.\\n     */\\n    function _sendAsset(\\n        IAsset asset,\\n        uint256 amount,\\n        address payable recipient,\\n        bool toInternalBalance\\n    ) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        if (_isETH(asset)) {\\n            // Sending ETH is not as involved as receiving it: the only special behavior is it cannot be\\n            // deposited to Internal Balance.\\n            _require(!toInternalBalance, Errors.INVALID_ETH_INTERNAL_BALANCE);\\n\\n            // First, the Vault withdraws deposited ETH from the WETH contract, by burning the same amount of WETH\\n            // from the Vault. This receipt will be handled by the Vault's `receive`.\\n            _WETH().withdraw(amount);\\n\\n            // Then, the withdrawn ETH is sent to the recipient.\\n            recipient.sendValue(amount);\\n        } else {\\n            IERC20 token = _asIERC20(asset);\\n            if (toInternalBalance) {\\n                _increaseInternalBalance(recipient, token, amount);\\n            } else {\\n                token.safeTransfer(recipient, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns excess ETH back to the contract caller, assuming `amountUsed` has been spent. Reverts\\n     * if the caller sent less ETH than `amountUsed`.\\n     *\\n     * Because the caller might not know exactly how much ETH a Vault action will require, they may send extra.\\n     * Note that this excess value is returned *to the contract caller* (msg.sender). If caller and e.g. swap sender are\\n     * not the same (because the caller is a relayer for the sender), then it is up to the caller to manage this\\n     * returned ETH.\\n     */\\n    function _handleRemainingEth(uint256 amountUsed) internal {\\n        _require(msg.value >= amountUsed, Errors.INSUFFICIENT_ETH);\\n\\n        uint256 excess = msg.value - amountUsed;\\n        if (excess > 0) {\\n            msg.sender.sendValue(excess);\\n        }\\n    }\\n\\n    /**\\n     * @dev Enables the Vault to receive ETH. This is required for it to be able to unwrap WETH, which sends ETH to the\\n     * caller.\\n     *\\n     * Any ETH sent to the Vault outside of the WETH unwrapping mechanism would be forever locked inside the Vault, so\\n     * we prevent that from happening. Other mechanisms used to send ETH to the Vault (such as being the recipient of an\\n     * ETH swap, Pool exit or withdrawal, contract self-destruction, or receiving the block mining reward) will result\\n     * in locked funds, but are not otherwise a security or soundness issue. This check only exists as an attempt to\\n     * prevent user error.\\n     */\\n    receive() external payable {\\n        _require(msg.sender == address(_WETH()), Errors.ETH_TRANSFER);\\n    }\\n\\n    // This contract uses virtual internal functions instead of inheriting from the modules that implement them (in\\n    // this case UserBalance) in order to decouple it from the rest of the system and enable standalone testing by\\n    // implementing these with mocks.\\n\\n    function _increaseInternalBalance(\\n        address account,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal virtual;\\n\\n    function _decreaseInternalBalance(\\n        address account,\\n        IERC20 token,\\n        uint256 amount,\\n        bool capped\\n    ) internal virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x27010ca4dc643c9e7c4717f827cca5269c64b3ee6ee5f6522f04557de22e882e\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Balances/BalanceAllocation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../Math.sol\\\";\\n\\n// This library is used to create a data structure that represents a token's balance for a Pool. 'cash' is how many\\n// tokens the Pool has sitting inside of the Vault. 'managed' is how many tokens were withdrawn from the Vault by the\\n// Pool's Asset Manager. 'total' is the sum of these two, and represents the Pool's total token balance, including\\n// tokens that are *not* inside of the Vault.\\n//\\n// 'cash' is updated whenever tokens enter and exit the Vault, while 'managed' is only updated if the reason tokens are\\n// moving is due to an Asset Manager action. This is reflected in the different methods available: 'increaseCash'\\n// and 'decreaseCash' for swaps and add/remove liquidity events, and 'cashToManaged' and 'managedToCash' for events\\n// transferring funds to and from the Asset Manager.\\n//\\n// The Vault disallows the Pool's 'cash' from becoming negative. In other words, it can never use any tokens that are\\n// not inside the Vault.\\n//\\n// One of the goals of this library is to store the entire token balance in a single storage slot, which is why we use\\n// 112 bit unsigned integers for 'cash' and 'managed'. For consistency, we also disallow any combination of 'cash' and\\n// 'managed' that yields a 'total' that doesn't fit in 112 bits.\\n//\\n// The remaining 32 bits of the slot are used to store the most recent block when the total balance changed. This\\n// can be used to implement price oracles that are resilient to 'sandwich' attacks.\\n//\\n// We could use a Solidity struct to pack these three values together in a single storage slot, but unfortunately\\n// Solidity only allows for structs to live in either storage, calldata or memory. Because a memory struct still takes\\n// up a slot in the stack (to store its memory location), and because the entire balance fits in a single stack slot\\n// (two 112 bit values plus the 32 bit block), using memory is strictly less gas performant. Therefore, we do manual\\n// packing and unpacking.\\n//\\n// Since we cannot define new types, we rely on bytes32 to represent these values instead, as it doesn't have any\\n// associated arithmetic operations and therefore reduces the chance of misuse.\\nlibrary BalanceAllocation {\\n    using Math for uint256;\\n\\n    // The 'cash' portion of the balance is stored in the least significant 112 bits of a 256 bit word, while the\\n    // 'managed' part uses the following 112 bits. The most significant 32 bits are used to store the block\\n\\n    /**\\n     * @dev Returns the total amount of Pool tokens, including those that are not currently in the Vault ('managed').\\n     */\\n    function total(bytes32 balance) internal pure returns (uint256) {\\n        // Since 'cash' and 'managed' are 112 bit values, we don't need checked arithmetic. Additionally, `toBalance`\\n        // ensures that 'total' always fits in 112 bits.\\n        return cash(balance) + managed(balance);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of Pool tokens currently in the Vault.\\n     */\\n    function cash(bytes32 balance) internal pure returns (uint256) {\\n        uint256 mask = 2**(112) - 1;\\n        return uint256(balance) & mask;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of Pool tokens that are being managed by an Asset Manager.\\n     */\\n    function managed(bytes32 balance) internal pure returns (uint256) {\\n        uint256 mask = 2**(112) - 1;\\n        return uint256(balance >> 112) & mask;\\n    }\\n\\n    /**\\n     * @dev Returns the last block when the total balance changed.\\n     */\\n    function lastChangeBlock(bytes32 balance) internal pure returns (uint256) {\\n        uint256 mask = 2**(32) - 1;\\n        return uint256(balance >> 224) & mask;\\n    }\\n\\n    /**\\n     * @dev Returns the difference in 'managed' between two balances.\\n     */\\n    function managedDelta(bytes32 newBalance, bytes32 oldBalance) internal pure returns (int256) {\\n        // Because `managed` is a 112 bit value, we can safely perform unchecked arithmetic in 256 bits.\\n        return int256(managed(newBalance)) - int256(managed(oldBalance));\\n    }\\n\\n    /**\\n     * @dev Returns the total balance for each entry in `balances`, as well as the latest block when the total\\n     * balance of *any* of them last changed.\\n     */\\n    function totalsAndLastChangeBlock(bytes32[] memory balances)\\n        internal\\n        pure\\n        returns (\\n            uint256[] memory results,\\n            uint256 lastChangeBlock_ // Avoid shadowing\\n        )\\n    {\\n        results = new uint256[](balances.length);\\n        lastChangeBlock_ = 0;\\n\\n        for (uint256 i = 0; i < results.length; i++) {\\n            bytes32 balance = balances[i];\\n            results[i] = total(balance);\\n            lastChangeBlock_ = Math.max(lastChangeBlock_, lastChangeBlock(balance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if `balance`'s 'total' balance is zero. Costs less gas than computing 'total' and comparing\\n     * with zero.\\n     */\\n    function isZero(bytes32 balance) internal pure returns (bool) {\\n        // We simply need to check the least significant 224 bytes of the word: the block does not affect this.\\n        uint256 mask = 2**(224) - 1;\\n        return (uint256(balance) & mask) == 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if `balance`'s 'total' balance is not zero. Costs less gas than computing 'total' and comparing\\n     * with zero.\\n     */\\n    function isNotZero(bytes32 balance) internal pure returns (bool) {\\n        return !isZero(balance);\\n    }\\n\\n    /**\\n     * @dev Packs together `cash` and `managed` amounts with a block to create a balance value.\\n     *\\n     * For consistency, this also checks that the sum of `cash` and `managed` (`total`) fits in 112 bits.\\n     */\\n    function toBalance(\\n        uint256 _cash,\\n        uint256 _managed,\\n        uint256 _blockNumber\\n    ) internal pure returns (bytes32) {\\n        uint256 _total = _cash + _managed;\\n\\n        // Since both 'cash' and 'managed' are positive integers, by checking that their sum ('total') fits in 112 bits\\n        // we are also indirectly checking that both 'cash' and 'managed' themselves fit in 112 bits.\\n        _require(_total >= _cash && _total < 2**112, Errors.BALANCE_TOTAL_OVERFLOW);\\n\\n        // We assume the block fits in 32 bits - this is expected to hold for at least a few decades.\\n        return _pack(_cash, _managed, _blockNumber);\\n    }\\n\\n    /**\\n     * @dev Increases a Pool's 'cash' (and therefore its 'total'). Called when Pool tokens are sent to the Vault (except\\n     * for Asset Manager deposits).\\n     *\\n     * Updates the last total balance change block, even if `amount` is zero.\\n     */\\n    function increaseCash(bytes32 balance, uint256 amount) internal view returns (bytes32) {\\n        uint256 newCash = cash(balance).add(amount);\\n        uint256 currentManaged = managed(balance);\\n        uint256 newLastChangeBlock = block.number;\\n\\n        return toBalance(newCash, currentManaged, newLastChangeBlock);\\n    }\\n\\n    /**\\n     * @dev Decreases a Pool's 'cash' (and therefore its 'total'). Called when Pool tokens are sent from the Vault\\n     * (except for Asset Manager withdrawals).\\n     *\\n     * Updates the last total balance change block, even if `amount` is zero.\\n     */\\n    function decreaseCash(bytes32 balance, uint256 amount) internal view returns (bytes32) {\\n        uint256 newCash = cash(balance).sub(amount);\\n        uint256 currentManaged = managed(balance);\\n        uint256 newLastChangeBlock = block.number;\\n\\n        return toBalance(newCash, currentManaged, newLastChangeBlock);\\n    }\\n\\n    /**\\n     * @dev Moves 'cash' into 'managed', leaving 'total' unchanged. Called when an Asset Manager withdraws Pool tokens\\n     * from the Vault.\\n     */\\n    function cashToManaged(bytes32 balance, uint256 amount) internal pure returns (bytes32) {\\n        uint256 newCash = cash(balance).sub(amount);\\n        uint256 newManaged = managed(balance).add(amount);\\n        uint256 currentLastChangeBlock = lastChangeBlock(balance);\\n\\n        return toBalance(newCash, newManaged, currentLastChangeBlock);\\n    }\\n\\n    /**\\n     * @dev Moves 'managed' into 'cash', leaving 'total' unchanged. Called when an Asset Manager deposits Pool tokens\\n     * into the Vault.\\n     */\\n    function managedToCash(bytes32 balance, uint256 amount) internal pure returns (bytes32) {\\n        uint256 newCash = cash(balance).add(amount);\\n        uint256 newManaged = managed(balance).sub(amount);\\n        uint256 currentLastChangeBlock = lastChangeBlock(balance);\\n\\n        return toBalance(newCash, newManaged, currentLastChangeBlock);\\n    }\\n\\n    /**\\n     * @dev Sets 'managed' balance to an arbitrary value, changing 'total'. Called when the Asset Manager reports\\n     * profits or losses. It's the Manager's responsibility to provide a meaningful value.\\n     *\\n     * Updates the last total balance change block, even if `newManaged` is equal to the current 'managed' value.\\n     */\\n    function setManaged(bytes32 balance, uint256 newManaged) internal view returns (bytes32) {\\n        uint256 currentCash = cash(balance);\\n        uint256 newLastChangeBlock = block.number;\\n        return toBalance(currentCash, newManaged, newLastChangeBlock);\\n    }\\n\\n    // Alternative mode for Pools with the Two Token specialization setting\\n\\n    // Instead of storing cash and external for each 'token in' a single storage slot, Two Token Pools store the cash\\n    // for both tokens in the same slot, and the managed for both in another one. This reduces the gas cost for swaps,\\n    // because the only slot that needs to be updated is the one with the cash. However, it also means that managing\\n    // balances is more cumbersome, as both tokens need to be read/written at the same time.\\n    //\\n    // The field with both cash balances packed is called sharedCash, and the one with external amounts is called\\n    // sharedManaged. These two are collectively called the 'shared' balance fields. In both of these, the portion\\n    // that corresponds to token A is stored in the least significant 112 bits of a 256 bit word, while token B's part\\n    // uses the next least significant 112 bits.\\n    //\\n    // Because only cash is written to during a swap, we store the last total balance change block with the\\n    // packed cash fields. Typically Pools have a distinct block per token: in the case of Two Token Pools they\\n    // are the same.\\n\\n    /**\\n     * @dev Extracts the part of the balance that corresponds to token A. This function can be used to decode both\\n     * shared cash and managed balances.\\n     */\\n    function _decodeBalanceA(bytes32 sharedBalance) private pure returns (uint256) {\\n        uint256 mask = 2**(112) - 1;\\n        return uint256(sharedBalance) & mask;\\n    }\\n\\n    /**\\n     * @dev Extracts the part of the balance that corresponds to token B. This function can be used to decode both\\n     * shared cash and managed balances.\\n     */\\n    function _decodeBalanceB(bytes32 sharedBalance) private pure returns (uint256) {\\n        uint256 mask = 2**(112) - 1;\\n        return uint256(sharedBalance >> 112) & mask;\\n    }\\n\\n    // To decode the last balance change block, we can simply use the `blockNumber` function.\\n\\n    /**\\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token A.\\n     */\\n    function fromSharedToBalanceA(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\\n        // Note that we extract the block from the sharedCash field, which is the one that is updated by swaps.\\n        // Both token A and token B use the same block\\n        return toBalance(_decodeBalanceA(sharedCash), _decodeBalanceA(sharedManaged), lastChangeBlock(sharedCash));\\n    }\\n\\n    /**\\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token B.\\n     */\\n    function fromSharedToBalanceB(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\\n        // Note that we extract the block from the sharedCash field, which is the one that is updated by swaps.\\n        // Both token A and token B use the same block\\n        return toBalance(_decodeBalanceB(sharedCash), _decodeBalanceB(sharedManaged), lastChangeBlock(sharedCash));\\n    }\\n\\n    /**\\n     * @dev Returns the sharedCash shared field, given the current balances for token A and token B.\\n     */\\n    function toSharedCash(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\\n        // Both balances are assigned the same block  Since it is possible a single one of them has changed (for\\n        // example, in an Asset Manager update), we keep the latest (largest) one.\\n        uint32 newLastChangeBlock = uint32(Math.max(lastChangeBlock(tokenABalance), lastChangeBlock(tokenBBalance)));\\n\\n        return _pack(cash(tokenABalance), cash(tokenBBalance), newLastChangeBlock);\\n    }\\n\\n    /**\\n     * @dev Returns the sharedManaged shared field, given the current balances for token A and token B.\\n     */\\n    function toSharedManaged(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\\n        // We don't bother storing a last change block, as it is read from the shared cash field.\\n        return _pack(managed(tokenABalance), managed(tokenBBalance), 0);\\n    }\\n\\n    // Shared functions\\n\\n    /**\\n     * @dev Packs together two uint112 and one uint32 into a bytes32\\n     */\\n    function _pack(\\n        uint256 _leastSignificant,\\n        uint256 _midSignificant,\\n        uint256 _mostSignificant\\n    ) private pure returns (bytes32) {\\n        return bytes32((_mostSignificant << 224) + (_midSignificant << 112) + _leastSignificant);\\n    }\\n}\\n\",\"keccak256\":\"0xb2259fbfcdb36d9d563412c41162f74103d9905380a65810d308c2e1015317d0\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Balances/GeneralPoolsBalance.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../BalancerErrors.sol\\\";\\nimport \\\"../../ERC20/EnumerableMap.sol\\\";\\nimport \\\"../../ERC20/IERC20.sol\\\";\\n\\nimport \\\"./BalanceAllocation.sol\\\";\\n\\nabstract contract GeneralPoolsBalance {\\n    using BalanceAllocation for bytes32;\\n    using EnumerableMap for EnumerableMap.IERC20ToBytes32Map;\\n\\n    // Data for Pools with the General specialization setting\\n    //\\n    // These Pools use the IGeneralPool interface, which means the Vault must query the balance for *all* of their\\n    // tokens in every swap. If we kept a mapping of token to balance plus a set (array) of tokens, it'd be very gas\\n    // intensive to read all token addresses just to then do a lookup on the balance mapping.\\n    //\\n    // Instead, we use our customized EnumerableMap, which lets us read the N balances in N+1 storage accesses (one for\\n    // each token in the Pool), access the index of any 'token in' a single read (required for the IGeneralPool call),\\n    // and update an entry's value given its index.\\n\\n    // Map of token -> balance pairs for each Pool with this specialization. Many functions rely on storage pointers to\\n    // a Pool's EnumerableMap to save gas when computing storage slots.\\n    mapping(bytes32 => EnumerableMap.IERC20ToBytes32Map) internal _generalPoolsBalances;\\n\\n    /**\\n     * @dev Registers a list of tokens in a General Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokens` must not be registered in the Pool\\n     * - `tokens` must not contain duplicates\\n     */\\n    function _registerGeneralPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            // EnumerableMaps require an explicit initial value when creating a key-value pair: we use zero, the same\\n            // value that is found in uninitialized storage, which corresponds to an empty balance.\\n            bool added = poolBalances.set(tokens[i], 0);\\n            _require(added, Errors.TOKEN_ALREADY_REGISTERED);\\n        }\\n    }\\n\\n    /**\\n     * @dev Deregisters a list of tokens in a General Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokens` must be registered in the Pool\\n     * - `tokens` must have zero balance in the Vault\\n     * - `tokens` must not contain duplicates\\n     */\\n    function _deregisterGeneralPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            bytes32 currentBalance = _getGeneralPoolBalance(poolBalances, token);\\n            _require(currentBalance.isZero(), Errors.NONZERO_TOKEN_BALANCE);\\n\\n            // We don't need to check remove's return value, since _getGeneralPoolBalance already checks that the token\\n            // was registered.\\n            poolBalances.remove(token);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the balances of a General Pool's tokens to `balances`.\\n     *\\n     * WARNING: this assumes `balances` has the same length and order as the Pool's tokens.\\n     */\\n    function _setGeneralPoolBalances(bytes32 poolId, bytes32[] memory balances) internal {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n\\n        for (uint256 i = 0; i < balances.length; ++i) {\\n            // Since we assume all balances are properly ordered, we can simply use `unchecked_setAt` to avoid one less\\n            // storage read per token.\\n            poolBalances.unchecked_setAt(i, balances[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transforms `amount` of `token`'s balance in a General Pool from cash into managed.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\\n     * registered for that Pool.\\n     */\\n    function _generalPoolCashToManaged(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal {\\n        _updateGeneralPoolBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\\n    }\\n\\n    /**\\n     * @dev Transforms `amount` of `token`'s balance in a General Pool from managed into cash.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\\n     * registered for that Pool.\\n     */\\n    function _generalPoolManagedToCash(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal {\\n        _updateGeneralPoolBalance(poolId, token, BalanceAllocation.managedToCash, amount);\\n    }\\n\\n    /**\\n     * @dev Sets `token`'s managed balance in a General Pool to `amount`.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\\n     * registered for that Pool.\\n     *\\n     * Returns the managed balance delta as a result of this call.\\n     */\\n    function _setGeneralPoolManagedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal returns (int256) {\\n        return _updateGeneralPoolBalance(poolId, token, BalanceAllocation.setManaged, amount);\\n    }\\n\\n    /**\\n     * @dev Sets `token`'s balance in a General Pool to the result of the `mutation` function when called with the\\n     * current balance and `amount`.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the General specialization setting, and that `token` is\\n     * registered for that Pool.\\n     *\\n     * Returns the managed balance delta as a result of this call.\\n     */\\n    function _updateGeneralPoolBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        function(bytes32, uint256) returns (bytes32) mutation,\\n        uint256 amount\\n    ) private returns (int256) {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n        bytes32 currentBalance = _getGeneralPoolBalance(poolBalances, token);\\n\\n        bytes32 newBalance = mutation(currentBalance, amount);\\n        poolBalances.set(token, newBalance);\\n\\n        return newBalance.managedDelta(currentBalance);\\n    }\\n\\n    /**\\n     * @dev Returns an array with all the tokens and balances in a General Pool. The order may change when tokens are\\n     * registered or deregistered.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\\n     */\\n    function _getGeneralPoolTokens(bytes32 poolId)\\n        internal\\n        view\\n        returns (IERC20[] memory tokens, bytes32[] memory balances)\\n    {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n        tokens = new IERC20[](poolBalances.length());\\n        balances = new bytes32[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            // Because the iteration is bounded by `tokens.length`, which matches the EnumerableMap's length, we can use\\n            // `unchecked_at` as we know `i` is a valid token index, saving storage reads.\\n            (tokens[i], balances[i]) = poolBalances.unchecked_at(i);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the balance of a token in a General Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\\n     *\\n     * Requirements:\\n     *\\n     * - `token` must be registered in the Pool\\n     */\\n    function _getGeneralPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n        return _getGeneralPoolBalance(poolBalances, token);\\n    }\\n\\n    /**\\n     * @dev Same as `_getGeneralPoolBalance` but using a Pool's storage pointer, which saves gas in repeated reads and\\n     * writes.\\n     */\\n    function _getGeneralPoolBalance(EnumerableMap.IERC20ToBytes32Map storage poolBalances, IERC20 token)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        return poolBalances.get(token, Errors.TOKEN_NOT_REGISTERED);\\n    }\\n\\n    /**\\n     * @dev Returns true if `token` is registered in a General Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\\n     */\\n    function _isGeneralPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n        return poolBalances.contains(token);\\n    }\\n}\\n\",\"keccak256\":\"0x1ba4736de17c9da07c988f49fad4e59c68c4a54de0508c360ff4e80d6222460b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Balances/MinimalSwapInfoPoolsBalance.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../BalancerErrors.sol\\\";\\nimport \\\"../../ERC20/EnumerableSet.sol\\\";\\nimport \\\"../../ERC20/IERC20.sol\\\";\\n\\nimport \\\"./BalanceAllocation.sol\\\";\\nimport \\\"../PoolRegistry.sol\\\";\\n\\nabstract contract MinimalSwapInfoPoolsBalance is PoolRegistry {\\n    using BalanceAllocation for bytes32;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Data for Pools with the Minimal Swap Info specialization setting\\n    //\\n    // These Pools use the IMinimalSwapInfoPool interface, and so the Vault must read the balance of the two tokens\\n    // in the swap. The best solution is to use a mapping from token to balance, which lets us read or write any token's\\n    // balance in a single storage access.\\n    //\\n    // We also keep a set of registered tokens. Because tokens with non-zero balance are by definition registered, in\\n    // some balance getters we skip checking for token registration if a non-zero balance is found, saving gas by\\n    // performing a single read instead of two.\\n\\n    mapping(bytes32 => mapping(IERC20 => bytes32)) internal _minimalSwapInfoPoolsBalances;\\n    mapping(bytes32 => EnumerableSet.AddressSet) internal _minimalSwapInfoPoolsTokens;\\n\\n    /**\\n     * @dev Registers a list of tokens in a Minimal Swap Info Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokens` must not be registered in the Pool\\n     * - `tokens` must not contain duplicates\\n     */\\n    function _registerMinimalSwapInfoPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            bool added = poolTokens.add(address(tokens[i]));\\n            _require(added, Errors.TOKEN_ALREADY_REGISTERED);\\n            // Note that we don't initialize the balance mapping: the default value of zero corresponds to an empty\\n            // balance.\\n        }\\n    }\\n\\n    /**\\n     * @dev Deregisters a list of tokens in a Minimal Swap Info Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokens` must be registered in the Pool\\n     * - `tokens` must have zero balance in the Vault\\n     * - `tokens` must not contain duplicates\\n     */\\n    function _deregisterMinimalSwapInfoPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            _require(_minimalSwapInfoPoolsBalances[poolId][token].isZero(), Errors.NONZERO_TOKEN_BALANCE);\\n\\n            // For consistency with other Pool specialization settings, we explicitly reset the balance (which may have\\n            // a non-zero last change block).\\n            delete _minimalSwapInfoPoolsBalances[poolId][token];\\n\\n            bool removed = poolTokens.remove(address(token));\\n            _require(removed, Errors.TOKEN_NOT_REGISTERED);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the balances of a Minimal Swap Info Pool's tokens to `balances`.\\n     *\\n     * WARNING: this assumes `balances` has the same length and order as the Pool's tokens.\\n     */\\n    function _setMinimalSwapInfoPoolBalances(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        bytes32[] memory balances\\n    ) internal {\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            _minimalSwapInfoPoolsBalances[poolId][tokens[i]] = balances[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev Transforms `amount` of `token`'s balance in a Minimal Swap Info Pool from cash into managed.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\\n     * `token` is registered for that Pool.\\n     */\\n    function _minimalSwapInfoPoolCashToManaged(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal {\\n        _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\\n    }\\n\\n    /**\\n     * @dev Transforms `amount` of `token`'s balance in a Minimal Swap Info Pool from managed into cash.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\\n     * `token` is registered for that Pool.\\n     */\\n    function _minimalSwapInfoPoolManagedToCash(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal {\\n        _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.managedToCash, amount);\\n    }\\n\\n    /**\\n     * @dev Sets `token`'s managed balance in a Minimal Swap Info Pool to `amount`.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\\n     * `token` is registered for that Pool.\\n     *\\n     * Returns the managed balance delta as a result of this call.\\n     */\\n    function _setMinimalSwapInfoPoolManagedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal returns (int256) {\\n        return _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.setManaged, amount);\\n    }\\n\\n    /**\\n     * @dev Sets `token`'s balance in a Minimal Swap Info Pool to the result of the `mutation` function when called with\\n     * the current balance and `amount`.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the Minimal Swap Info specialization setting, and that\\n     * `token` is registered for that Pool.\\n     *\\n     * Returns the managed balance delta as a result of this call.\\n     */\\n    function _updateMinimalSwapInfoPoolBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        function(bytes32, uint256) returns (bytes32) mutation,\\n        uint256 amount\\n    ) internal returns (int256) {\\n        bytes32 currentBalance = _getMinimalSwapInfoPoolBalance(poolId, token);\\n\\n        bytes32 newBalance = mutation(currentBalance, amount);\\n        _minimalSwapInfoPoolsBalances[poolId][token] = newBalance;\\n\\n        return newBalance.managedDelta(currentBalance);\\n    }\\n\\n    /**\\n     * @dev Returns an array with all the tokens and balances in a Minimal Swap Info Pool. The order may change when\\n     * tokens are registered or deregistered.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\\n     */\\n    function _getMinimalSwapInfoPoolTokens(bytes32 poolId)\\n        internal\\n        view\\n        returns (IERC20[] memory tokens, bytes32[] memory balances)\\n    {\\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\\n        tokens = new IERC20[](poolTokens.length());\\n        balances = new bytes32[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            // Because the iteration is bounded by `tokens.length`, which matches the EnumerableSet's length, we can use\\n            // `unchecked_at` as we know `i` is a valid token index, saving storage reads.\\n            IERC20 token = IERC20(poolTokens.unchecked_at(i));\\n            tokens[i] = token;\\n            balances[i] = _minimalSwapInfoPoolsBalances[poolId][token];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the balance of a token in a Minimal Swap Info Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - `poolId` must be a Minimal Swap Info Pool\\n     * - `token` must be registered in the Pool\\n     */\\n    function _getMinimalSwapInfoPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\\n        bytes32 balance = _minimalSwapInfoPoolsBalances[poolId][token];\\n\\n        // A non-zero balance guarantees that the token is registered. If zero, we manually check if the token is\\n        // registered in the Pool. Token registration implies that the Pool is registered as well, which lets us save\\n        // gas by not performing the check.\\n        bool tokenRegistered = balance.isNotZero() || _minimalSwapInfoPoolsTokens[poolId].contains(address(token));\\n\\n        if (!tokenRegistered) {\\n            // The token might not be registered because the Pool itself is not registered. We check this to provide a\\n            // more accurate revert reason.\\n            _ensureRegisteredPool(poolId);\\n            _revert(Errors.TOKEN_NOT_REGISTERED);\\n        }\\n\\n        return balance;\\n    }\\n\\n    /**\\n     * @dev Returns true if `token` is registered in a Minimal Swap Info Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the Minimal Swap Info specialization setting.\\n     */\\n    function _isMinimalSwapInfoPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\\n        return poolTokens.contains(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x7efc7779763180a6a2e5981aefab333dceb82908a18b5def263ca845af4a0fc6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Balances/TwoTokenPoolsBalance.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../BalancerErrors.sol\\\";\\nimport \\\"../../ERC20/IERC20.sol\\\";\\n\\nimport \\\"../PoolRegistry.sol\\\";\\nimport \\\"./BalanceAllocation.sol\\\";\\n\\nabstract contract TwoTokenPoolsBalance is PoolRegistry {\\n    using BalanceAllocation for bytes32;\\n\\n    // Data for Pools with the Two Token specialization setting\\n    //\\n    // These are similar to the Minimal Swap Info Pool case (because the Pool only has two tokens, and therefore there\\n    // are only two balances to read), but there's a key difference in how data is stored. Keeping a set makes little\\n    // sense, as it will only ever hold two tokens, so we can just store those two directly.\\n    //\\n    // The gas savings associated with using these Pools come from how token balances are stored: cash amounts for token\\n    // A and token B are packed together, as are managed amounts. Because only cash changes in a swap, there's no need\\n    // to write to this second storage slot. A single last change block number for both tokens is stored with the packed\\n    // cash fields.\\n\\n    struct TwoTokenPoolBalances {\\n        bytes32 sharedCash;\\n        bytes32 sharedManaged;\\n    }\\n\\n    // We could just keep a mapping from Pool ID to TwoTokenSharedBalances, but there's an issue: we wouldn't know to\\n    // which tokens those balances correspond. This would mean having to also check which are registered with the Pool.\\n    //\\n    // What we do instead to save those storage reads is keep a nested mapping from the token pair hash to the balances\\n    // struct. The Pool only has two tokens, so only a single entry of this mapping is set (the one that corresponds to\\n    // that pair's hash).\\n    //\\n    // This has the trade-off of making Vault code that interacts with these Pools cumbersome: both balances must be\\n    // accessed at the same time by using both token addresses, and some logic is needed to determine how the pair hash\\n    // is computed. We do this by sorting the tokens, calling the token with the lowest numerical address value token A,\\n    // and the other one token B. In functions where the token arguments could be either A or B, we use X and Y instead.\\n    //\\n    // If users query a token pair containing an unregistered token, the Pool will generate a hash for a mapping entry\\n    // that was not set, and return zero balances. Non-zero balances are only possible if both tokens in the pair\\n    // are registered with the Pool, which means we don't have to check the TwoTokenPoolTokens struct, and can save\\n    // storage reads.\\n\\n    struct TwoTokenPoolTokens {\\n        IERC20 tokenA;\\n        IERC20 tokenB;\\n        mapping(bytes32 => TwoTokenPoolBalances) balances;\\n    }\\n\\n    mapping(bytes32 => TwoTokenPoolTokens) private _twoTokenPoolTokens;\\n\\n    /**\\n     * @dev Registers tokens in a Two Token Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenX` and `tokenY` must not be the same\\n     * - The tokens must be ordered: tokenX < tokenY\\n     */\\n    function _registerTwoTokenPoolTokens(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        IERC20 tokenY\\n    ) internal {\\n        // Not technically true since we didn't register yet, but this is consistent with the error messages of other\\n        // specialization settings.\\n        _require(tokenX != tokenY, Errors.TOKEN_ALREADY_REGISTERED);\\n\\n        _require(tokenX < tokenY, Errors.UNSORTED_TOKENS);\\n\\n        // A Two Token Pool with no registered tokens is identified by having zero addresses for tokens A and B.\\n        TwoTokenPoolTokens storage poolTokens = _twoTokenPoolTokens[poolId];\\n        _require(poolTokens.tokenA == IERC20(0) && poolTokens.tokenB == IERC20(0), Errors.TOKENS_ALREADY_SET);\\n\\n        // Since tokenX < tokenY, tokenX is A and tokenY is B\\n        poolTokens.tokenA = tokenX;\\n        poolTokens.tokenB = tokenY;\\n\\n        // Note that we don't initialize the balance mapping: the default value of zero corresponds to an empty\\n        // balance.\\n    }\\n\\n    /**\\n     * @dev Deregisters tokens in a Two Token Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenX` and `tokenY` must be registered in the Pool\\n     * - both tokens must have zero balance in the Vault\\n     */\\n    function _deregisterTwoTokenPoolTokens(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        IERC20 tokenY\\n    ) internal {\\n        (\\n            bytes32 balanceA,\\n            bytes32 balanceB,\\n            TwoTokenPoolBalances storage poolBalances\\n        ) = _getTwoTokenPoolSharedBalances(poolId, tokenX, tokenY);\\n\\n        _require(balanceA.isZero() && balanceB.isZero(), Errors.NONZERO_TOKEN_BALANCE);\\n\\n        delete _twoTokenPoolTokens[poolId];\\n\\n        // For consistency with other Pool specialization settings, we explicitly reset the packed cash field (which may\\n        // have a non-zero last change block).\\n        delete poolBalances.sharedCash;\\n    }\\n\\n    /**\\n     * @dev Sets the cash balances of a Two Token Pool's tokens.\\n     *\\n     * WARNING: this assumes `tokenA` and `tokenB` are the Pool's two registered tokens, and are in the correct order.\\n     */\\n    function _setTwoTokenPoolCashBalances(\\n        bytes32 poolId,\\n        IERC20 tokenA,\\n        bytes32 balanceA,\\n        IERC20 tokenB,\\n        bytes32 balanceB\\n    ) internal {\\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\\n        TwoTokenPoolBalances storage poolBalances = _twoTokenPoolTokens[poolId].balances[pairHash];\\n        poolBalances.sharedCash = BalanceAllocation.toSharedCash(balanceA, balanceB);\\n    }\\n\\n    /**\\n     * @dev Transforms `amount` of `token`'s balance in a Two Token Pool from cash into managed.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\\n     * registered for that Pool.\\n     */\\n    function _twoTokenPoolCashToManaged(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal {\\n        _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\\n    }\\n\\n    /**\\n     * @dev Transforms `amount` of `token`'s balance in a Two Token Pool from managed into cash.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\\n     * registered for that Pool.\\n     */\\n    function _twoTokenPoolManagedToCash(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal {\\n        _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.managedToCash, amount);\\n    }\\n\\n    /**\\n     * @dev Sets `token`'s managed balance in a Two Token Pool to `amount`.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\\n     * registered for that Pool.\\n     *\\n     * Returns the managed balance delta as a result of this call.\\n     */\\n    function _setTwoTokenPoolManagedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal returns (int256) {\\n        return _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.setManaged, amount);\\n    }\\n\\n    /**\\n     * @dev Sets `token`'s balance in a Two Token Pool to the result of the `mutation` function when called with\\n     * the current balance and `amount`.\\n     *\\n     * This function assumes `poolId` exists, corresponds to the Two Token specialization setting, and that `token` is\\n     * registered for that Pool.\\n     *\\n     * Returns the managed balance delta as a result of this call.\\n     */\\n    function _updateTwoTokenPoolSharedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        function(bytes32, uint256) returns (bytes32) mutation,\\n        uint256 amount\\n    ) private returns (int256) {\\n        (\\n            TwoTokenPoolBalances storage balances,\\n            IERC20 tokenA,\\n            bytes32 balanceA,\\n            ,\\n            bytes32 balanceB\\n        ) = _getTwoTokenPoolBalances(poolId);\\n\\n        int256 delta;\\n        if (token == tokenA) {\\n            bytes32 newBalance = mutation(balanceA, amount);\\n            delta = newBalance.managedDelta(balanceA);\\n            balanceA = newBalance;\\n        } else {\\n            // token == tokenB\\n            bytes32 newBalance = mutation(balanceB, amount);\\n            delta = newBalance.managedDelta(balanceB);\\n            balanceB = newBalance;\\n        }\\n\\n        balances.sharedCash = BalanceAllocation.toSharedCash(balanceA, balanceB);\\n        balances.sharedManaged = BalanceAllocation.toSharedManaged(balanceA, balanceB);\\n\\n        return delta;\\n    }\\n\\n    /*\\n     * @dev Returns an array with all the tokens and balances in a Two Token Pool. The order may change when\\n     * tokens are registered or deregistered.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\\n     */\\n    function _getTwoTokenPoolTokens(bytes32 poolId)\\n        internal\\n        view\\n        returns (IERC20[] memory tokens, bytes32[] memory balances)\\n    {\\n        (, IERC20 tokenA, bytes32 balanceA, IERC20 tokenB, bytes32 balanceB) = _getTwoTokenPoolBalances(poolId);\\n\\n        // Both tokens will either be zero (if unregistered) or non-zero (if registered), but we keep the full check for\\n        // clarity.\\n        if (tokenA == IERC20(0) || tokenB == IERC20(0)) {\\n            return (new IERC20[](0), new bytes32[](0));\\n        }\\n\\n        // Note that functions relying on this getter expect tokens to be properly ordered, so we use the (A, B)\\n        // ordering.\\n\\n        tokens = new IERC20[](2);\\n        tokens[0] = tokenA;\\n        tokens[1] = tokenB;\\n\\n        balances = new bytes32[](2);\\n        balances[0] = balanceA;\\n        balances[1] = balanceB;\\n    }\\n\\n    /**\\n     * @dev Same as `_getTwoTokenPoolTokens`, except it returns the two tokens and balances directly instead of using\\n     * an array, as well as a storage pointer to the `TwoTokenPoolBalances` struct, which can be used to update it\\n     * without having to recompute the pair hash and storage slot.\\n     */\\n    function _getTwoTokenPoolBalances(bytes32 poolId)\\n        private\\n        view\\n        returns (\\n            TwoTokenPoolBalances storage poolBalances,\\n            IERC20 tokenA,\\n            bytes32 balanceA,\\n            IERC20 tokenB,\\n            bytes32 balanceB\\n        )\\n    {\\n        TwoTokenPoolTokens storage poolTokens = _twoTokenPoolTokens[poolId];\\n        tokenA = poolTokens.tokenA;\\n        tokenB = poolTokens.tokenB;\\n\\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\\n        poolBalances = poolTokens.balances[pairHash];\\n\\n        bytes32 sharedCash = poolBalances.sharedCash;\\n        bytes32 sharedManaged = poolBalances.sharedManaged;\\n\\n        balanceA = BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\\n        balanceB = BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\\n    }\\n\\n    /**\\n     * @dev Returns the balance of a token in a Two Token Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the General specialization setting.\\n     *\\n     * This function is convenient but not particularly gas efficient, and should be avoided during gas-sensitive\\n     * operations, such as swaps. For those, _getTwoTokenPoolSharedBalances provides a more flexible interface.\\n     *\\n     * Requirements:\\n     *\\n     * - `token` must be registered in the Pool\\n     */\\n    function _getTwoTokenPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\\n        // We can't just read the balance of token, because we need to know the full pair in order to compute the pair\\n        // hash and access the balance mapping. We therefore rely on `_getTwoTokenPoolBalances`.\\n        (, IERC20 tokenA, bytes32 balanceA, IERC20 tokenB, bytes32 balanceB) = _getTwoTokenPoolBalances(poolId);\\n\\n        if (token == tokenA) {\\n            return balanceA;\\n        } else if (token == tokenB) {\\n            return balanceB;\\n        } else {\\n            _revert(Errors.TOKEN_NOT_REGISTERED);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the balance of the two tokens in a Two Token Pool.\\n     *\\n     * The returned balances are those of token A and token B, where token A is the lowest of token X and token Y, and\\n     * token B the other.\\n     *\\n     * This function also returns a storage pointer to the TwoTokenPoolBalances struct associated with the token pair,\\n     * which can be used to update it without having to recompute the pair hash and storage slot.\\n     *\\n     * Requirements:\\n     *\\n     * - `poolId` must be a Minimal Swap Info Pool\\n     * - `tokenX` and `tokenY` must be registered in the Pool\\n     */\\n    function _getTwoTokenPoolSharedBalances(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        IERC20 tokenY\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes32 balanceA,\\n            bytes32 balanceB,\\n            TwoTokenPoolBalances storage poolBalances\\n        )\\n    {\\n        (IERC20 tokenA, IERC20 tokenB) = _sortTwoTokens(tokenX, tokenY);\\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\\n\\n        poolBalances = _twoTokenPoolTokens[poolId].balances[pairHash];\\n\\n        // Because we're reading balances using the pair hash, if either token X or token Y is not registered then\\n        // *both* balance entries will be zero.\\n        bytes32 sharedCash = poolBalances.sharedCash;\\n        bytes32 sharedManaged = poolBalances.sharedManaged;\\n\\n        // A non-zero balance guarantees that both tokens are registered. If zero, we manually check whether each\\n        // token is registered in the Pool. Token registration implies that the Pool is registered as well, which\\n        // lets us save gas by not performing the check.\\n        bool tokensRegistered = sharedCash.isNotZero() ||\\n            sharedManaged.isNotZero() ||\\n            (_isTwoTokenPoolTokenRegistered(poolId, tokenA) && _isTwoTokenPoolTokenRegistered(poolId, tokenB));\\n\\n        if (!tokensRegistered) {\\n            // The tokens might not be registered because the Pool itself is not registered. We check this to provide a\\n            // more accurate revert reason.\\n            _ensureRegisteredPool(poolId);\\n            _revert(Errors.TOKEN_NOT_REGISTERED);\\n        }\\n\\n        balanceA = BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\\n        balanceB = BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\\n    }\\n\\n    /**\\n     * @dev Returns true if `token` is registered in a Two Token Pool.\\n     *\\n     * This function assumes `poolId` exists and corresponds to the Two Token specialization setting.\\n     */\\n    function _isTwoTokenPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\\n        TwoTokenPoolTokens storage poolTokens = _twoTokenPoolTokens[poolId];\\n\\n        // The zero address can never be a registered token.\\n        return (token == poolTokens.tokenA || token == poolTokens.tokenB) && token != IERC20(0);\\n    }\\n\\n    /**\\n     * @dev Returns the hash associated with a given token pair.\\n     */\\n    function _getTwoTokenPairHash(IERC20 tokenA, IERC20 tokenB) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(tokenA, tokenB));\\n    }\\n\\n    /**\\n     * @dev Sorts two tokens in ascending order, returning them as a (tokenA, tokenB) tuple.\\n     */\\n    function _sortTwoTokens(IERC20 tokenX, IERC20 tokenY) private pure returns (IERC20, IERC20) {\\n        return tokenX < tokenY ? (tokenX, tokenY) : (tokenY, tokenX);\\n    }\\n}\\n\",\"keccak256\":\"0xc1f311b1913cf57fe215cf8199fc8105d8c715dfd6dfca6c94551b9fb6fac7b1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Fees.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../FixedPoint.sol\\\";\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/SafeERC20.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./ProtocolFeesCollector.sol\\\";\\nimport \\\"./VaultAuthorization.sol\\\";\\nimport \\\"./IVault.sol\\\";\\n\\n/**\\n * @dev To reduce the bytecode size of the Vault, most of the protocol fee logic is not here, but in the\\n * ProtocolFeesCollector contract.\\n */\\nabstract contract Fees is IVault {\\n    using SafeERC20 for IERC20;\\n\\n    ProtocolFeesCollector private immutable _protocolFeesCollector;\\n\\n    constructor() {\\n        _protocolFeesCollector = new ProtocolFeesCollector(IVault(this));\\n    }\\n\\n    function getProtocolFeesCollector() public view override returns (IProtocolFeesCollector) {\\n        return _protocolFeesCollector;\\n    }\\n\\n    /**\\n     * @dev Returns the protocol swap fee percentage.\\n     */\\n    function _getProtocolSwapFeePercentage() internal view returns (uint256) {\\n        return getProtocolFeesCollector().getSwapFeePercentage();\\n    }\\n\\n    /**\\n     * @dev Returns the protocol fee amount to charge for a flash loan of `amount`.\\n     */\\n    function _calculateFlashLoanFeeAmount(uint256 amount) internal view returns (uint256) {\\n        // Fixed point multiplication introduces error: we round up, which means in certain scenarios the charged\\n        // percentage can be slightly higher than intended.\\n        uint256 percentage = getProtocolFeesCollector().getFlashLoanFeePercentage();\\n        return FixedPoint.mulUp(amount, percentage);\\n    }\\n\\n    function _payFeeAmount(IERC20 token, uint256 amount) internal {\\n        if (amount > 0) {\\n            token.safeTransfer(address(getProtocolFeesCollector()), amount);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa740084a281c95ec5173ece58a0b95c3241597f09372b1a45c61e6b5ab378295\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/FlashLoans.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// This flash loan provider was based on the Aave protocol's open source\\n// implementation and terminology and interfaces are intentionally kept\\n// similar\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/SafeERC20.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./Fees.sol\\\";\\nimport \\\"./IFlashLoanRecipient.sol\\\";\\n\\n/**\\n * @dev Handles Flash Loans through the Vault. Calls the `receiveFlashLoan` hook on the flash loan recipient\\n * contract, which implements the `IFlashLoanRecipient` interface.\\n */\\nabstract contract FlashLoans is Fees, ReentrancyGuard, TemporarilyPausable {\\n    using SafeERC20 for IERC20;\\n\\n    function flashLoan(\\n        IFlashLoanRecipient recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external override nonReentrant whenNotPaused {\\n        InputHelpers.ensureInputLengthMatch(tokens.length, amounts.length);\\n\\n        uint256[] memory feeAmounts = new uint256[](tokens.length);\\n        uint256[] memory preLoanBalances = new uint256[](tokens.length);\\n\\n        // Used to ensure `tokens` is sorted in ascending order, which ensures token uniqueness.\\n        IERC20 previousToken = IERC20(0);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            uint256 amount = amounts[i];\\n\\n            _require(token > previousToken, token == IERC20(0) ? Errors.ZERO_TOKEN : Errors.UNSORTED_TOKENS);\\n            previousToken = token;\\n\\n            preLoanBalances[i] = token.balanceOf(address(this));\\n            feeAmounts[i] = _calculateFlashLoanFeeAmount(amount);\\n\\n            _require(preLoanBalances[i] >= amount, Errors.INSUFFICIENT_FLASH_LOAN_BALANCE);\\n            token.safeTransfer(address(recipient), amount);\\n        }\\n\\n        recipient.receiveFlashLoan(tokens, amounts, feeAmounts, userData);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            uint256 preLoanBalance = preLoanBalances[i];\\n\\n            // Checking for loan repayment first (without accounting for fees) makes for simpler debugging, and results\\n            // in more accurate revert reasons if the flash loan protocol fee percentage is zero.\\n            uint256 postLoanBalance = token.balanceOf(address(this));\\n            _require(postLoanBalance >= preLoanBalance, Errors.INVALID_POST_LOAN_BALANCE);\\n\\n            // No need for checked arithmetic since we know the loan was fully repaid.\\n            uint256 receivedFeeAmount = postLoanBalance - preLoanBalance;\\n            _require(receivedFeeAmount >= feeAmounts[i], Errors.INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT);\\n\\n            _payFeeAmount(token, receivedFeeAmount);\\n            emit FlashLoan(recipient, token, amounts[i], receivedFeeAmount);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6598527bb91ab76e73c7f64f5db5c5d7a724f3e8e24751e90bbeebabf0744c66\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IAsset.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\\n * types.\\n *\\n * This concept is unrelated to a Pool's Asset Managers.\\n */\\ninterface IAsset {\\n    // solhint-disable-previous-line no-empty-blocks\\n}\\n\",\"keccak256\":\"0x70ecf1d48c285d78718bd2e159345677038ed8a81c74444bedd6a5c61af9aff6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IAuthorizer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IAuthorizer {\\n    /**\\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\\n     */\\n    function canPerform(\\n        bytes32 actionId,\\n        address account,\\n        address where\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x792871e208bba1dad291f8d1cffad86f4afa5e2360816bd9c43481f7297155f5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IBasePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IPoolSwapStructs.sol\\\";\\n\\n/**\\n * @dev Interface for adding and removing liquidity that all Pool contracts should implement. Note that this is not\\n * the complete Pool contract interface, as it is missing the swap hooks. Pool contracts should also inherit from\\n * either IGeneralPool or IMinimalSwapInfoPool\\n */\\ninterface IBasePool is IPoolSwapStructs {\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.joinPool` to add liquidity to this Pool. Returns how many of\\n     * each registered token the user should provide, as well as the amount of protocol fees the Pool owes to the Vault.\\n     * The Vault will then take tokens from `sender` and add them to the Pool's balances, as well as collect\\n     * the reported amount in protocol fees, which the pool should calculate based on `protocolSwapFeePercentage`.\\n     *\\n     * Protocol fees are reported and charged on join events so that the Pool is free of debt whenever new users join.\\n     *\\n     * `sender` is the account performing the join (from which tokens will be withdrawn), and `recipient` is the account\\n     * designated to receive any benefits (typically pool shares). `balances` contains the total balances\\n     * for each token the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\\n     *\\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\\n     * balance.\\n     *\\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\\n     * join (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\\n     *\\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\\n     * state-changing operations, such as minting pool shares.\\n     */\\n    function onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);\\n\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.exitPool` to remove liquidity from this Pool. Returns how many\\n     * tokens the Vault should deduct from the Pool's balances, as well as the amount of protocol fees the Pool owes\\n     * to the Vault. The Vault will then take tokens from the Pool's balances and send them to `recipient`,\\n     * as well as collect the reported amount in protocol fees, which the Pool should calculate based on\\n     * `protocolSwapFeePercentage`.\\n     *\\n     * Protocol fees are charged on exit events to guarantee that users exiting the Pool have paid their share.\\n     *\\n     * `sender` is the account performing the exit (typically the pool shareholder), and `recipient` is the account\\n     * to which the Vault will send the proceeds. `balances` contains the total token balances for each token\\n     * the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\\n     *\\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\\n     * balance.\\n     *\\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\\n     * exit (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\\n     *\\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\\n     * state-changing operations, such as burning pool shares.\\n     */\\n    function onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);\\n\\n    function getPoolId() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xceae7edca5dc3084127b998c4a5b4c8a01e00777484fb19fcc4d5199adc7f826\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IFlashLoanRecipient.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver.\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\ninterface IFlashLoanRecipient {\\n    /**\\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n     *\\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n     * Vault, or else the entire flash loan will revert.\\n     *\\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\\n     */\\n    function receiveFlashLoan(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\",\"keccak256\":\"0xbaa2bc80a63f8ae2d02c8a9c9ba98badc06de673161ec4ca775c14832d511a82\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IGeneralPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IBasePool.sol\\\";\\n\\n/**\\n * @dev IPools with the General specialization setting should implement this interface.\\n *\\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will\\n * grant to the pool in a 'given out' swap.\\n *\\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\\n * indeed the Vault.\\n */\\ninterface IGeneralPool is IBasePool {\\n    function onSwap(\\n        SwapRequest memory swapRequest,\\n        uint256[] memory balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) external returns (uint256 amount);\\n}\\n\",\"keccak256\":\"0x7f11733a5cd8f81c123c02f79d94ead7b65217021ebddafda10e796a25e1ef41\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IMinimalSwapInfoPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IBasePool.sol\\\";\\n\\n/**\\n * @dev Pool contracts with the MinimalSwapInfo or TwoToken specialization settings should implement this interface.\\n *\\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will grant\\n * to the pool in a 'given out' swap.\\n *\\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\\n * indeed the Vault.\\n */\\ninterface IMinimalSwapInfoPool is IBasePool {\\n    function onSwap(\\n        SwapRequest memory swapRequest,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) external returns (uint256 amount);\\n}\\n\",\"keccak256\":\"0x7469919e147c0db8b4f290d310ca3816dec5d3c6cc6b258cf6e0df820a20a179\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IPoolSwapStructs.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\n\\ninterface IPoolSwapStructs {\\n    // This is not really an interface - it just defines common structs used by other interfaces: IGeneralPool and\\n    // IMinimalSwapInfoPool.\\n    //\\n    // This data structure represents a request for a token swap, where `kind` indicates the swap type ('given in' or\\n    // 'given out') which indicates whether or not the amount sent by the pool is known.\\n    //\\n    // The pool receives `tokenIn` and sends `tokenOut`. `amount` is the number of `tokenIn` tokens the pool will take\\n    // in, or the number of `tokenOut` tokens the Pool will send out, depending on the given swap `kind`.\\n    //\\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\\n    // some Pools.\\n    //\\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\\n    // one Pool.\\n    //\\n    // The meaning of `lastChangeBlock` depends on the Pool specialization:\\n    //  - Two Token or Minimal Swap Info: the last block in which either `tokenIn` or `tokenOut` changed its total\\n    //    balance.\\n    //  - General: the last block in which *any* of the Pool's registered tokens changed its total balance.\\n    //\\n    // `from` is the origin address for the funds the Pool receives, and `to` is the destination address\\n    // where the Pool sends the outgoing tokens.\\n    //\\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\\n    struct SwapRequest {\\n        IVault.SwapKind kind;\\n        IERC20 tokenIn;\\n        IERC20 tokenOut;\\n        uint256 amount;\\n        // Misc data\\n        bytes32 poolId;\\n        uint256 lastChangeBlock;\\n        address from;\\n        address to;\\n        bytes userData;\\n    }\\n}\\n\",\"keccak256\":\"0x0851d9640a0866ee1722d637a9e4287d1b9f9d65aebd30f86a81ba66ab06c44d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IProtocolFeesCollector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\n\\ninterface IProtocolFeesCollector {\\n    event SwapFeePercentageChanged(uint256 newSwapFeePercentage);\\n    event FlashLoanFeePercentageChanged(uint256 newFlashLoanFeePercentage);\\n\\n    function withdrawCollectedFees(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address recipient\\n    ) external;\\n\\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external;\\n\\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external;\\n\\n    function getSwapFeePercentage() external view returns (uint256);\\n\\n    function getFlashLoanFeePercentage() external view returns (uint256);\\n\\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts);\\n\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    function vault() external view returns (IVault);\\n}\\n\",\"keccak256\":\"0x8a41dc4114e92f979545efb32d3030dce5f4a9c29065b77697be6001de22ff8f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../utils/ISignaturesValidator.sol\\\";\\nimport \\\"../utils/ITemporarilyPausable.sol\\\";\\nimport \\\"../misc/IWETH.sol\\\";\\n\\nimport \\\"./IAsset.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\nimport \\\"./IFlashLoanRecipient.sol\\\";\\nimport \\\"./IProtocolFeesCollector.sol\\\";\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\\n * don't override one of these declarations.\\n */\\ninterface IVault is ISignaturesValidator, ITemporarilyPausable {\\n    // Generalities about the Vault:\\n    //\\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\\n    //\\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\\n    //\\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\\n\\n    // Authorizer\\n    //\\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\\n    // can perform a given action.\\n\\n    /**\\n     * @dev Returns the Vault's Authorizer.\\n     */\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    /**\\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\\n     *\\n     * Emits an `AuthorizerChanged` event.\\n     */\\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\\n\\n    /**\\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\\n     */\\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\\n\\n    // Relayers\\n    //\\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\\n    // this power, two things must occur:\\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\\n    //    functions.\\n    //  - Each user must approve the relayer to act on their behalf.\\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\\n\\n    /**\\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\\n     */\\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\\n\\n    /**\\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\\n     *\\n     * Emits a `RelayerApprovalChanged` event.\\n     */\\n    function setRelayerApproval(\\n        address sender,\\n        address relayer,\\n        bool approved\\n    ) external;\\n\\n    /**\\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\\n     */\\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\\n\\n    // Internal Balance\\n    //\\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n    //\\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n    // operations of different kinds, with different senders and recipients, at once.\\n\\n    /**\\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\\n     */\\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\\n     * it lets integrators reuse a user's Vault allowance.\\n     *\\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n     */\\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\\n\\n    /**\\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\\n     without manual WETH wrapping or unwrapping.\\n     */\\n    struct UserBalanceOp {\\n        UserBalanceOpKind kind;\\n        IAsset asset;\\n        uint256 amount;\\n        address sender;\\n        address payable recipient;\\n    }\\n\\n    // There are four possible operations in `manageUserBalance`:\\n    //\\n    // - DEPOSIT_INTERNAL\\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\\n    // relevant for relayers).\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - WITHDRAW_INTERNAL\\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n    // it to the recipient as ETH.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_INTERNAL\\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_EXTERNAL\\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\\n    // relayers, as it lets them reuse a user's Vault allowance.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `ExternalBalanceTransfer` event.\\n\\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\\n\\n    /**\\n     * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\\n     * interacting with Pools using Internal Balance.\\n     *\\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\\n     * address.\\n     */\\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\\n\\n    /**\\n     * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\\n     */\\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\\n\\n    // Pools\\n    //\\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\\n    // functionality:\\n    //\\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n    // which increase with the number of registered tokens.\\n    //\\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n    // independent of the number of registered tokens.\\n    //\\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\\n\\n    /**\\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\\n     * changed.\\n     *\\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\\n     *\\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\\n     * multiple Pools may share the same contract.\\n     *\\n     * Emits a `PoolRegistered` event.\\n     */\\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n    /**\\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\\n     */\\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\\n\\n    /**\\n     * @dev Returns a Pool's contract address and specialization setting.\\n     */\\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n    /**\\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\\n     * exit by receiving registered tokens, and can only swap registered tokens.\\n     *\\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\\n     * ascending order.\\n     *\\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\\n     * Asset Manager should not be made lightly.\\n     *\\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\\n     * different Asset Manager.\\n     *\\n     * Emits a `TokensRegistered` event.\\n     */\\n    function registerTokens(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        address[] memory assetManagers\\n    ) external;\\n\\n    /**\\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\\n     */\\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\\n\\n    /**\\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\\n     * must be deregistered in the same `deregisterTokens` call.\\n     *\\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\\n     *\\n     * Emits a `TokensDeregistered` event.\\n     */\\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\\n\\n    /**\\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\\n     */\\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\\n\\n    /**\\n     * @dev Returns detailed information for a Pool's registered token.\\n     *\\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\\n     * equals the sum of `cash` and `managed`.\\n     *\\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\\n     * `managed` or `total` balance to be greater than 2^112 - 1.\\n     *\\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\\n     * change for this purpose, and will update `lastChangeBlock`.\\n     *\\n     * `assetManager` is the Pool's token Asset Manager.\\n     */\\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        returns (\\n            uint256 cash,\\n            uint256 managed,\\n            uint256 lastChangeBlock,\\n            address assetManager\\n        );\\n\\n    /**\\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\\n     * the tokens' `balances` changed.\\n     *\\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\\n     *\\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\\n     * order as passed to `registerTokens`.\\n     *\\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\\n     * instead.\\n     */\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (\\n            IERC20[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 lastChangeBlock\\n        );\\n\\n    /**\\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\\n     * Pool shares.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\\n     * these maximums.\\n     *\\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\\n     * back to the caller (not the sender, which is important for relayers).\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\\n     *\\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\\n     * directly to the Pool's contract, as is `recipient`.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external payable;\\n\\n    struct JoinPoolRequest {\\n        IAsset[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n     * `getPoolTokenInfo`).\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n     * it just enforces these minimums.\\n     *\\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\\n     *\\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n     * do so will trigger a revert.\\n     *\\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n     * passed directly to the Pool's contract.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external;\\n\\n    struct ExitPoolRequest {\\n        IAsset[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\\n     */\\n    event PoolBalanceChanged(\\n        bytes32 indexed poolId,\\n        address indexed liquidityProvider,\\n        IERC20[] tokens,\\n        int256[] deltas,\\n        uint256[] protocolFeeAmounts\\n    );\\n\\n    enum PoolBalanceChangeKind { JOIN, EXIT }\\n\\n    // Swaps\\n    //\\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n    //\\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n    // individual swaps.\\n    //\\n    // There are two swap kinds:\\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n    //\\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n    // the final intended token.\\n    //\\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n    // much less gas than they would otherwise.\\n    //\\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n    // updating the Pool's internal accounting).\\n    //\\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\\n    //\\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n    //\\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n    //\\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\\n\\n    /**\\n     * @dev Performs a swap with a single Pool.\\n     *\\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n     * taken from the Pool, which must be greater than or equal to `limit`.\\n     *\\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n     * sent to the Pool, which must be less than or equal to `limit`.\\n     *\\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\\n     *\\n     * Emits a `Swap` event.\\n     */\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n     * the `kind` value.\\n     *\\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        IAsset assetIn;\\n        IAsset assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\\n     *\\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\\n     * the same index in the `assets` array.\\n     *\\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n     * `amountOut` depending on the swap kind.\\n     *\\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\\n     *\\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\\n     * or unwrapped from WETH by the Vault.\\n     *\\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\\n     *\\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n     * equivalent `swap` call.\\n     *\\n     * Emits `Swap` events.\\n     */\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    ) external payable returns (int256[] memory);\\n\\n    /**\\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\\n     *\\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n     * from the previous swap, depending on the swap kind.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\\n     */\\n    event Swap(\\n        bytes32 indexed poolId,\\n        IERC20 indexed tokenIn,\\n        IERC20 indexed tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n\\n    /**\\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n     * `recipient` account.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *\\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     *\\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n     * revert.\\n     */\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\\n     *\\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\\n     * receives are the same that an equivalent `batchSwap` call would receive.\\n     *\\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\\n     * approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n    function queryBatchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds\\n    ) external returns (int256[] memory assetDeltas);\\n\\n    // Flash Loans\\n\\n    /**\\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\\n     *\\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\\n     * for each token contract. `tokens` must be sorted in ascending order.\\n     *\\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\\n     * `receiveFlashLoan` call.\\n     *\\n     * Emits `FlashLoan` events.\\n     */\\n    function flashLoan(\\n        IFlashLoanRecipient recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external;\\n\\n    /**\\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\\n     */\\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\\n\\n    // Asset Management\\n    //\\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\\n    //\\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\\n    //\\n    // This concept is unrelated to the IAsset interface.\\n\\n    /**\\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\\n     *\\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\\n     * operations of different kinds, with different Pools and tokens, at once.\\n     *\\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\\n     */\\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\\n\\n    struct PoolBalanceOp {\\n        PoolBalanceOpKind kind;\\n        bytes32 poolId;\\n        IERC20 token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\\n     *\\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\\n     *\\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\\n     */\\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\\n\\n    /**\\n     * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\\n     */\\n    event PoolBalanceManaged(\\n        bytes32 indexed poolId,\\n        address indexed assetManager,\\n        IERC20 indexed token,\\n        int256 cashDelta,\\n        int256 managedDelta\\n    );\\n\\n    // Protocol Fees\\n    //\\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\\n    // permissioned accounts.\\n    //\\n    // There are two kinds of protocol fees:\\n    //\\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\\n    //\\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\\n    // exiting a Pool in debt without first paying their share.\\n\\n    /**\\n     * @dev Returns the current protocol fee module.\\n     */\\n    function getProtocolFeesCollector() external view returns (IProtocolFeesCollector);\\n\\n    /**\\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\\n     * error in some part of the system.\\n     *\\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\\n     *\\n     * While the contract is paused, the following features are disabled:\\n     * - depositing and transferring internal balance\\n     * - transferring external balance (using the Vault's allowance)\\n     * - swaps\\n     * - joining Pools\\n     * - Asset Manager interactions\\n     *\\n     * Internal Balance can still be withdrawn, and Pools exited.\\n     */\\n    function setPaused(bool paused) external;\\n\\n    /**\\n     * @dev Returns the Vault's WETH instance.\\n     */\\n    function WETH() external view returns (IWETH);\\n    // solhint-disable-previous-line func-name-mixedcase\\n}\\n\",\"keccak256\":\"0xc54f6b798844fbe0e7ab737dcac04ff86f0522d1e7c89871c58f401ca88c3f55\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/PoolBalances.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Math.sol\\\";\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../InputHelpers.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/SafeERC20.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./Fees.sol\\\";\\nimport \\\"./PoolTokens.sol\\\";\\nimport \\\"./UserBalance.sol\\\";\\nimport \\\"./IBasePool.sol\\\";\\n\\n/**\\n * @dev Stores the Asset Managers (by Pool and token), and implements the top level Asset Manager and Pool interfaces,\\n * such as registering and deregistering tokens, joining and exiting Pools, and informational functions like `getPool`\\n * and `getPoolTokens`, delegating to specialization-specific functions as needed.\\n *\\n * `managePoolBalance` handles all Asset Manager interactions.\\n */\\nabstract contract PoolBalances is Fees, ReentrancyGuard, PoolTokens, UserBalance {\\n    using Math for uint256;\\n    using SafeERC20 for IERC20;\\n    using BalanceAllocation for bytes32;\\n    using BalanceAllocation for bytes32[];\\n\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external payable override whenNotPaused {\\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\\n\\n        // Note that `recipient` is not actually payable in the context of a join - we cast it because we handle both\\n        // joins and exits at once.\\n//        _joinOrExit(PoolBalanceChangeKind.JOIN, poolId, sender, payable(recipient), _toPoolBalanceChange(request));\\n    }\\n//\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external override {\\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\\n//        _joinOrExit(PoolBalanceChangeKind.EXIT, poolId, sender, recipient, _toPoolBalanceChange(request));\\n    }\\n\\n    // This has the exact same layout as JoinPoolRequest and ExitPoolRequest, except the `maxAmountsIn` and\\n    // `minAmountsOut` are called `limits`. Internally we use this struct for both since these two functions are quite\\n    // similar, but expose the others to callers for clarity.\\n    struct PoolBalanceChange {\\n        IAsset[] assets;\\n        uint256[] limits;\\n        bytes userData;\\n        bool useInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Converts a JoinPoolRequest into a PoolBalanceChange, with no runtime cost.\\n     */\\n    function _toPoolBalanceChange(JoinPoolRequest memory request)\\n        private\\n        pure\\n        returns (PoolBalanceChange memory change)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            change := request\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an ExitPoolRequest into a PoolBalanceChange, with no runtime cost.\\n     */\\n    function _toPoolBalanceChange(ExitPoolRequest memory request)\\n        private\\n        pure\\n        returns (PoolBalanceChange memory change)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            change := request\\n        }\\n    }\\n\\n    /**\\n     * @dev Implements both `joinPool` and `exitPool`, based on `kind`.\\n     */\\n//    function _joinOrExit(\\n//        PoolBalanceChangeKind kind,\\n//        bytes32 poolId,\\n//        address sender,\\n//        address payable recipient,\\n//        PoolBalanceChange memory change\\n//    ) private nonReentrant withRegisteredPool(poolId) authenticateFor(sender) {\\n//        // This function uses a large number of stack variables (poolId, sender and recipient, balances, amounts, fees,\\n//        // etc.), which leads to 'stack too deep' issues. It relies on private functions with seemingly arbitrary\\n//        // interfaces to work around this limitation.\\n//\\n//        InputHelpers.ensureInputLengthMatch(change.assets.length, change.limits.length);\\n//\\n//        // We first check that the caller passed the Pool's registered tokens in the correct order, and retrieve the\\n//        // current balance for each.\\n//        IERC20[] memory tokens = _translateToIERC20(change.assets);\\n//        bytes32[] memory balances = _validateTokensAndGetBalances(poolId, tokens);\\n//\\n//        // The bulk of the work is done here: the corresponding Pool hook is called, its final balances are computed,\\n//        // assets are transferred, and fees are paid.\\n//        (\\n//            bytes32[] memory finalBalances,\\n//            uint256[] memory amountsInOrOut,\\n//            uint256[] memory paidProtocolSwapFeeAmounts\\n//        ) = _callPoolBalanceChange(kind, poolId, sender, recipient, change, balances);\\n//\\n//        // All that remains is storing the new Pool balances.\\n//        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n//        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n//            _setTwoTokenPoolCashBalances(poolId, tokens[0], finalBalances[0], tokens[1], finalBalances[1]);\\n//        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n//            _setMinimalSwapInfoPoolBalances(poolId, tokens, finalBalances);\\n//        } else {\\n//            // PoolSpecialization.GENERAL\\n//            _setGeneralPoolBalances(poolId, finalBalances);\\n//        }\\n//\\n//        bool positive = kind == PoolBalanceChangeKind.JOIN; // Amounts in are positive, out are negative\\n//        emit PoolBalanceChanged(\\n//            poolId,\\n//            sender,\\n//            tokens,\\n//            // We can unsafely cast to int256 because balances are actually stored as uint112\\n//            _unsafeCastToInt256(amountsInOrOut, positive),\\n//            paidProtocolSwapFeeAmounts\\n//        );\\n//    }\\n\\n    /**\\n     * @dev Calls the corresponding Pool hook to get the amounts in/out plus protocol fee amounts, and performs the\\n     * associated token transfers and fee payments, returning the Pool's final balances.\\n     */\\n//    function _callPoolBalanceChange(\\n//        PoolBalanceChangeKind kind,\\n//        bytes32 poolId,\\n//        address sender,\\n//        address payable recipient,\\n//        PoolBalanceChange memory change,\\n//        bytes32[] memory balances\\n//    )\\n//        private\\n//        returns (\\n//            bytes32[] memory finalBalances,\\n//            uint256[] memory amountsInOrOut,\\n//            uint256[] memory dueProtocolFeeAmounts\\n//        )\\n//    {\\n//        (uint256[] memory totalBalances, uint256 lastChangeBlock) = balances.totalsAndLastChangeBlock();\\n//\\n//        IBasePool pool = IBasePool(_getPoolAddress(poolId));\\n//        (amountsInOrOut, dueProtocolFeeAmounts) = kind == PoolBalanceChangeKind.JOIN\\n//            ? pool.onJoinPool(\\n//                poolId,\\n//                sender,\\n//                recipient,\\n//                totalBalances,\\n//                lastChangeBlock,\\n//                _getProtocolSwapFeePercentage(),\\n//                change.userData\\n//            )\\n//            : pool.onExitPool(\\n//                poolId,\\n//                sender,\\n//                recipient,\\n//                totalBalances,\\n//                lastChangeBlock,\\n//                _getProtocolSwapFeePercentage(),\\n//                change.userData\\n//            );\\n//\\n//        InputHelpers.ensureInputLengthMatch(balances.length, amountsInOrOut.length, dueProtocolFeeAmounts.length);\\n//\\n//        // The Vault ignores the `recipient` in joins and the `sender` in exits: it is up to the Pool to keep track of\\n//        // their participation.\\n//        finalBalances = kind == PoolBalanceChangeKind.JOIN\\n//            ? _processJoinPoolTransfers(sender, change, balances, amountsInOrOut, dueProtocolFeeAmounts)\\n//            : _processExitPoolTransfers(recipient, change, balances, amountsInOrOut, dueProtocolFeeAmounts);\\n//    }\\n\\n    /**\\n     * @dev Transfers `amountsIn` from `sender`, checking that they are within their accepted limits, and pays\\n     * accumulated protocol swap fees.\\n     *\\n     * Returns the Pool's final balances, which are the current balances plus `amountsIn` minus accumulated protocol\\n     * swap fees.\\n     */\\n    function _processJoinPoolTransfers(\\n        address sender,\\n        PoolBalanceChange memory change,\\n        bytes32[] memory balances,\\n        uint256[] memory amountsIn,\\n        uint256[] memory dueProtocolFeeAmounts\\n    ) private returns (bytes32[] memory finalBalances) {\\n        // We need to track how much of the received ETH was used and wrapped into WETH to return any excess.\\n        uint256 wrappedEth = 0;\\n\\n        finalBalances = new bytes32[](balances.length);\\n        for (uint256 i = 0; i < change.assets.length; ++i) {\\n            uint256 amountIn = amountsIn[i];\\n            _require(amountIn <= change.limits[i], Errors.JOIN_ABOVE_MAX);\\n\\n            // Receive assets from the sender - possibly from Internal Balance.\\n            IAsset asset = change.assets[i];\\n            _receiveAsset(asset, amountIn, sender, change.useInternalBalance);\\n\\n            if (_isETH(asset)) {\\n                wrappedEth = wrappedEth.add(amountIn);\\n            }\\n\\n            uint256 feeAmount = dueProtocolFeeAmounts[i];\\n            _payFeeAmount(_translateToIERC20(asset), feeAmount);\\n\\n            // Compute the new Pool balances. Note that the fee amount might be larger than `amountIn`,\\n            // resulting in an overall decrease of the Pool's balance for a token.\\n            finalBalances[i] = (amountIn >= feeAmount) // This lets us skip checked arithmetic\\n                ? balances[i].increaseCash(amountIn - feeAmount)\\n                : balances[i].decreaseCash(feeAmount - amountIn);\\n        }\\n\\n        // Handle any used and remaining ETH.\\n        _handleRemainingEth(wrappedEth);\\n    }\\n\\n    /**\\n     * @dev Transfers `amountsOut` to `recipient`, checking that they are within their accepted limits, and pays\\n     * accumulated protocol swap fees from the Pool.\\n     *\\n     * Returns the Pool's final balances, which are the current `balances` minus `amountsOut` and fees paid\\n     * (`dueProtocolFeeAmounts`).\\n     */\\n    function _processExitPoolTransfers(\\n        address payable recipient,\\n        PoolBalanceChange memory change,\\n        bytes32[] memory balances,\\n        uint256[] memory amountsOut,\\n        uint256[] memory dueProtocolFeeAmounts\\n    ) private returns (bytes32[] memory finalBalances) {\\n        finalBalances = new bytes32[](balances.length);\\n        for (uint256 i = 0; i < change.assets.length; ++i) {\\n            uint256 amountOut = amountsOut[i];\\n            _require(amountOut >= change.limits[i], Errors.EXIT_BELOW_MIN);\\n\\n            // Send tokens to the recipient - possibly to Internal Balance\\n            IAsset asset = change.assets[i];\\n            _sendAsset(asset, amountOut, recipient, change.useInternalBalance);\\n\\n            uint256 feeAmount = dueProtocolFeeAmounts[i];\\n            _payFeeAmount(_translateToIERC20(asset), feeAmount);\\n\\n            // Compute the new Pool balances. A Pool's token balance always decreases after an exit (potentially by 0).\\n            finalBalances[i] = balances[i].decreaseCash(amountOut.add(feeAmount));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total balance for `poolId`'s `expectedTokens`.\\n     *\\n     * `expectedTokens` must exactly equal the token array returned by `getPoolTokens`: both arrays must have the same\\n     * length, elements and order. Additionally, the Pool must have at least one registered token.\\n     */\\n    function _validateTokensAndGetBalances(bytes32 poolId, IERC20[] memory expectedTokens)\\n        private\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        (IERC20[] memory actualTokens, bytes32[] memory balances) = _getPoolTokens(poolId);\\n        InputHelpers.ensureInputLengthMatch(actualTokens.length, expectedTokens.length);\\n        _require(actualTokens.length > 0, Errors.POOL_NO_TOKENS);\\n\\n        for (uint256 i = 0; i < actualTokens.length; ++i) {\\n            _require(actualTokens[i] == expectedTokens[i], Errors.TOKENS_MISMATCH);\\n        }\\n\\n        return balances;\\n    }\\n\\n    /**\\n     * @dev Casts an array of uint256 to int256, setting the sign of the result according to the `positive` flag,\\n     * without checking whether the values fit in the signed 256 bit range.\\n     */\\n    function _unsafeCastToInt256(uint256[] memory values, bool positive)\\n        private\\n        pure\\n        returns (int256[] memory signedValues)\\n    {\\n        signedValues = new int256[](values.length);\\n        for (uint256 i = 0; i < values.length; i++) {\\n            signedValues[i] = positive ? int256(values[i]) : -int256(values[i]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3d9c8936b6dcfb5eba9fe0032545df2e0541d005b7d7d4dac8ec398d4cb015f4\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/PoolRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./VaultAuthorization.sol\\\";\\n\\n/**\\n * @dev Maintains the Pool ID data structure, implements Pool ID creation and registration, and defines useful modifiers\\n * and helper functions for ensuring correct behavior when working with Pools.\\n */\\nabstract contract PoolRegistry is ReentrancyGuard, VaultAuthorization {\\n    // Each pool is represented by their unique Pool ID. We use `bytes32` for them, for lack of a way to define new\\n    // types.\\n    mapping(bytes32 => bool) private _isPoolRegistered;\\n\\n    // We keep an increasing nonce to make Pool IDs unique. It is interpreted as a `uint80`, but storing it as a\\n    // `uint256` results in reduced bytecode on reads and writes due to the lack of masking.\\n    uint256 private _nextPoolNonce;\\n\\n    /**\\n     * @dev Reverts unless `poolId` corresponds to a registered Pool.\\n     */\\n    modifier withRegisteredPool(bytes32 poolId) {\\n        _ensureRegisteredPool(poolId);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts unless `poolId` corresponds to a registered Pool, and the caller is the Pool's contract.\\n     */\\n    modifier onlyPool(bytes32 poolId) {\\n        _ensurePoolIsSender(poolId);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts unless `poolId` corresponds to a registered Pool.\\n     */\\n    function _ensureRegisteredPool(bytes32 poolId) internal view {\\n        _require(_isPoolRegistered[poolId], Errors.INVALID_POOL_ID);\\n    }\\n\\n    /**\\n     * @dev Reverts unless `poolId` corresponds to a registered Pool, and the caller is the Pool's contract.\\n     */\\n    function _ensurePoolIsSender(bytes32 poolId) private view {\\n        _ensureRegisteredPool(poolId);\\n        _require(msg.sender == _getPoolAddress(poolId), Errors.CALLER_NOT_POOL);\\n    }\\n\\n    function registerPool(PoolSpecialization specialization)\\n        external\\n        override\\n        nonReentrant\\n        whenNotPaused\\n        returns (bytes32)\\n    {\\n        // Each Pool is assigned a unique ID based on an incrementing nonce. This assumes there will never be more than\\n        // 2**80 Pools, and the nonce will not overflow.\\n\\n        bytes32 poolId = _toPoolId(msg.sender, specialization, uint80(_nextPoolNonce));\\n\\n        _require(!_isPoolRegistered[poolId], Errors.INVALID_POOL_ID); // Should never happen as Pool IDs are unique.\\n        _isPoolRegistered[poolId] = true;\\n\\n        _nextPoolNonce += 1;\\n\\n        // Note that msg.sender is the pool's contract\\n        emit PoolRegistered(poolId, msg.sender, specialization);\\n        return poolId;\\n    }\\n\\n    function getPool(bytes32 poolId)\\n        external\\n        view\\n        override\\n        withRegisteredPool(poolId)\\n        returns (address, PoolSpecialization)\\n    {\\n        return (_getPoolAddress(poolId), _getPoolSpecialization(poolId));\\n    }\\n\\n    /**\\n     * @dev Creates a Pool ID.\\n     *\\n     * These are deterministically created by packing the Pool's contract address and its specialization setting into\\n     * the ID. This saves gas by making this data easily retrievable from a Pool ID with no storage accesses.\\n     *\\n     * Since a single contract can register multiple Pools, a unique nonce must be provided to ensure Pool IDs are\\n     * unique.\\n     *\\n     * Pool IDs have the following layout:\\n     * | 20 bytes pool contract address | 2 bytes specialization setting | 10 bytes nonce |\\n     * MSB                                                                              LSB\\n     *\\n     * 2 bytes for the specialization setting is a bit overkill: there only three of them, which means two bits would\\n     * suffice. However, there's nothing else of interest to store in this extra space.\\n     */\\n    function _toPoolId(\\n        address pool,\\n        PoolSpecialization specialization,\\n        uint80 nonce\\n    ) internal pure returns (bytes32) {\\n        bytes32 serialized;\\n\\n        serialized |= bytes32(uint256(nonce));\\n        serialized |= bytes32(uint256(specialization)) << (10 * 8);\\n        serialized |= bytes32(uint256(pool)) << (12 * 8);\\n\\n        return serialized;\\n    }\\n\\n    /**\\n     * @dev Returns the address of a Pool's contract.\\n     *\\n     * Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\\n     */\\n    function _getPoolAddress(bytes32 poolId) internal pure returns (address) {\\n        // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\\n        // since the logical shift already sets the upper bits to zero.\\n        return address(uint256(poolId) >> (12 * 8));\\n    }\\n\\n    /**\\n     * @dev Returns the specialization setting of a Pool.\\n     *\\n     * Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\\n     */\\n    function _getPoolSpecialization(bytes32 poolId) internal pure returns (PoolSpecialization specialization) {\\n        // 10 byte logical shift left to remove the nonce, followed by a 2 byte mask to remove the address.\\n        uint256 value = uint256(poolId >> (10 * 8)) & (2**(2 * 8) - 1);\\n\\n        // Casting a value into an enum results in a runtime check that reverts unless the value is within the enum's\\n        // range. Passing an invalid Pool ID to this function would then result in an obscure revert with no reason\\n        // string: we instead perform the check ourselves to help in error diagnosis.\\n\\n        // There are three Pool specialization settings: general, minimal swap info and two tokens, which correspond to\\n        // values 0, 1 and 2.\\n        _require(value < 3, Errors.INVALID_POOL_ID);\\n\\n        // Because we have checked that `value` is within the enum range, we can use assembly to skip the runtime check.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            specialization := value\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd220d5732b103d97700062e30c6691b2dd80f2aa91ac7746122e0b6e5d704a4d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/PoolTokens.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./AssetManagers.sol\\\";\\nimport \\\"./PoolRegistry.sol\\\";\\nimport \\\"./Balances/BalanceAllocation.sol\\\";\\n\\nabstract contract PoolTokens is ReentrancyGuard, PoolRegistry, AssetManagers {\\n    using BalanceAllocation for bytes32;\\n    using BalanceAllocation for bytes32[];\\n\\n    function registerTokens(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        address[] memory assetManagers\\n    ) external override nonReentrant whenNotPaused onlyPool(poolId) {\\n        InputHelpers.ensureInputLengthMatch(tokens.length, assetManagers.length);\\n\\n        // Validates token addresses and assigns Asset Managers\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            _require(token != IERC20(0), Errors.INVALID_TOKEN);\\n\\n            _poolAssetManagers[poolId][token] = assetManagers[i];\\n        }\\n\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\\n            _registerTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _registerMinimalSwapInfoPoolTokens(poolId, tokens);\\n        } else {\\n            // PoolSpecialization.GENERAL\\n            _registerGeneralPoolTokens(poolId, tokens);\\n        }\\n\\n        emit TokensRegistered(poolId, tokens, assetManagers);\\n    }\\n\\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens)\\n        external\\n        override\\n        nonReentrant\\n        whenNotPaused\\n        onlyPool(poolId)\\n    {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\\n            _deregisterTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _deregisterMinimalSwapInfoPoolTokens(poolId, tokens);\\n        } else {\\n            // PoolSpecialization.GENERAL\\n            _deregisterGeneralPoolTokens(poolId, tokens);\\n        }\\n\\n        // The deregister calls above ensure the total token balance is zero. Therefore it is now safe to remove any\\n        // associated Asset Managers, since they hold no Pool balance.\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            delete _poolAssetManagers[poolId][tokens[i]];\\n        }\\n\\n        emit TokensDeregistered(poolId, tokens);\\n    }\\n\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        override\\n        withRegisteredPool(poolId)\\n        returns (\\n            IERC20[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 lastChangeBlock\\n        )\\n    {\\n        bytes32[] memory rawBalances;\\n        (tokens, rawBalances) = _getPoolTokens(poolId);\\n        (balances, lastChangeBlock) = rawBalances.totalsAndLastChangeBlock();\\n    }\\n\\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        override\\n        withRegisteredPool(poolId)\\n        returns (\\n            uint256 cash,\\n            uint256 managed,\\n            uint256 lastChangeBlock,\\n            address assetManager\\n        )\\n    {\\n        bytes32 balance;\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            balance = _getTwoTokenPoolBalance(poolId, token);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            balance = _getMinimalSwapInfoPoolBalance(poolId, token);\\n        } else {\\n            // PoolSpecialization.GENERAL\\n            balance = _getGeneralPoolBalance(poolId, token);\\n        }\\n\\n        cash = balance.cash();\\n        managed = balance.managed();\\n        lastChangeBlock = balance.lastChangeBlock();\\n        assetManager = _poolAssetManagers[poolId][token];\\n    }\\n\\n    /**\\n     * @dev Returns all of `poolId`'s registered tokens, along with their raw balances.\\n     */\\n    function _getPoolTokens(bytes32 poolId) internal view returns (IERC20[] memory tokens, bytes32[] memory balances) {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            return _getTwoTokenPoolTokens(poolId);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            return _getMinimalSwapInfoPoolTokens(poolId);\\n        } else {\\n            // PoolSpecialization.GENERAL\\n            return _getGeneralPoolTokens(poolId);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5136980d2e3334167fe3a16c606ee797842acda2cc960f0fae1daeadb5d60a7\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/ProtocolFeesCollector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../InputHelpers.sol\\\";\\nimport \\\"../Authentication.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\nimport \\\"../ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"./IProtocolFeesCollector.sol\\\";\\n\\n/**\\n * @dev This an auxiliary contract to the Vault, deployed by it during construction. It offloads some of the tasks the\\n * Vault performs to reduce its overall bytecode size.\\n *\\n * The current values for all protocol fee percentages are stored here, and any tokens charged as protocol fees are\\n * sent to this contract, where they may be withdrawn by authorized entities. All authorization tasks are delegated\\n * to the Vault's own authorizer.\\n */\\ncontract ProtocolFeesCollector is IProtocolFeesCollector, Authentication, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    // Absolute maximum fee percentages (1e18 = 100%, 1e16 = 1%).\\n    uint256 private constant _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE = 50e16; // 50%\\n    uint256 private constant _MAX_PROTOCOL_FLASH_LOAN_FEE_PERCENTAGE = 1e16; // 1%\\n\\n    IVault public immutable override vault;\\n\\n    // All fee percentages are 18-decimal fixed point numbers.\\n\\n    // The swap fee is charged whenever a swap occurs, as a percentage of the fee charged by the Pool. These are not\\n    // actually charged on each individual swap: the `Vault` relies on the Pools being honest and reporting fees due\\n    // when users join and exit them.\\n    uint256 private _swapFeePercentage;\\n\\n    // The flash loan fee is charged whenever a flash loan occurs, as a percentage of the tokens lent.\\n    uint256 private _flashLoanFeePercentage;\\n\\n    constructor(IVault _vault)\\n        // The ProtocolFeesCollector is a singleton, so it simply uses its own address to disambiguate action\\n        // identifiers.\\n        Authentication(bytes32(uint256(address(this))))\\n    {\\n        vault = _vault;\\n    }\\n\\n    function withdrawCollectedFees(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address recipient\\n    ) external override nonReentrant authenticate {\\n        InputHelpers.ensureInputLengthMatch(tokens.length, amounts.length);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            uint256 amount = amounts[i];\\n            token.safeTransfer(recipient, amount);\\n        }\\n    }\\n\\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external override authenticate {\\n        _require(newSwapFeePercentage <= _MAX_PROTOCOL_SWAP_FEE_PERCENTAGE, Errors.SWAP_FEE_PERCENTAGE_TOO_HIGH);\\n        _swapFeePercentage = newSwapFeePercentage;\\n        emit SwapFeePercentageChanged(newSwapFeePercentage);\\n    }\\n\\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external override authenticate {\\n        _require(\\n            newFlashLoanFeePercentage <= _MAX_PROTOCOL_FLASH_LOAN_FEE_PERCENTAGE,\\n            Errors.FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH\\n        );\\n        _flashLoanFeePercentage = newFlashLoanFeePercentage;\\n        emit FlashLoanFeePercentageChanged(newFlashLoanFeePercentage);\\n    }\\n\\n    function getSwapFeePercentage() external view override returns (uint256) {\\n        return _swapFeePercentage;\\n    }\\n\\n    function getFlashLoanFeePercentage() external view override returns (uint256) {\\n        return _flashLoanFeePercentage;\\n    }\\n\\n    function getCollectedFeeAmounts(IERC20[] memory tokens)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory feeAmounts)\\n    {\\n        feeAmounts = new uint256[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            feeAmounts[i] = tokens[i].balanceOf(address(this));\\n        }\\n    }\\n\\n    function getAuthorizer() external view override returns (IAuthorizer) {\\n        return _getAuthorizer();\\n    }\\n\\n    function _canPerform(bytes32 actionId, address account) internal view override returns (bool) {\\n        return _getAuthorizer().canPerform(actionId, account, address(this));\\n    }\\n\\n    function _getAuthorizer() internal view returns (IAuthorizer) {\\n        return vault.getAuthorizer();\\n    }\\n}\\n\",\"keccak256\":\"0xb1073499e5a63e6f77285ec76a2683d8fe81c8213ebd1b5fcdb2eafd8c1d5e1d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Swaps.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Math.sol\\\";\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../InputHelpers.sol\\\";\\nimport \\\"../ERC20/EnumerableMap.sol\\\";\\nimport \\\"../ERC20/EnumerableSet.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\nimport \\\"../ERC20/SafeCast.sol\\\";\\nimport \\\"../ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"./PoolBalances.sol\\\";\\nimport \\\"./IPoolSwapStructs.sol\\\";\\nimport \\\"./IGeneralPool.sol\\\";\\nimport \\\"./IMinimalSwapInfoPool.sol\\\";\\nimport \\\"./Balances/BalanceAllocation.sol\\\";\\n\\n/**\\n * Implements the Vault's high-level swap functionality.\\n *\\n * Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. They need not trust the Pool\\n * contracts to do this: all security checks are made by the Vault.\\n *\\n * The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n * In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n * and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n * More complex swaps, such as one 'token in' to multiple tokens out can be achieved by batching together\\n * individual swaps.\\n */\\nabstract contract Swaps is ReentrancyGuard, PoolBalances {\\n    using SafeERC20 for IERC20;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableMap for EnumerableMap.IERC20ToBytes32Map;\\n\\n    using Math for int256;\\n    using Math for uint256;\\n    using SafeCast for uint256;\\n    using BalanceAllocation for bytes32;\\n\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        whenNotPaused\\n        authenticateFor(funds.sender)\\n        returns (uint256 amountCalculated)\\n    {\\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\\n        // solhint-disable-next-line not-rely-on-time\\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\\n\\n        // This revert reason is for consistency with `batchSwap`: an equivalent `swap` performed using that function\\n        // would result in this error.\\n        _require(singleSwap.amount > 0, Errors.UNKNOWN_AMOUNT_IN_FIRST_SWAP);\\n\\n        IERC20 tokenIn = _translateToIERC20(singleSwap.assetIn);\\n        IERC20 tokenOut = _translateToIERC20(singleSwap.assetOut);\\n        _require(tokenIn != tokenOut, Errors.CANNOT_SWAP_SAME_TOKEN);\\n\\n        // Initializing each struct field one-by-one uses less gas than setting all at once.\\n        IPoolSwapStructs.SwapRequest memory poolRequest;\\n        poolRequest.poolId = singleSwap.poolId;\\n        poolRequest.kind = singleSwap.kind;\\n        poolRequest.tokenIn = tokenIn;\\n        poolRequest.tokenOut = tokenOut;\\n        poolRequest.amount = singleSwap.amount;\\n        poolRequest.userData = singleSwap.userData;\\n        poolRequest.from = funds.sender;\\n        poolRequest.to = funds.recipient;\\n        // The lastChangeBlock field is left uninitialized.\\n\\n        uint256 amountIn;\\n        uint256 amountOut;\\n\\n        (amountCalculated, amountIn, amountOut) = _swapWithPool(poolRequest);\\n        _require(singleSwap.kind == SwapKind.GIVEN_IN ? amountOut >= limit : amountIn <= limit, Errors.SWAP_LIMIT);\\n\\n        _receiveAsset(singleSwap.assetIn, amountIn, funds.sender, funds.fromInternalBalance);\\n        _sendAsset(singleSwap.assetOut, amountOut, funds.recipient, funds.toInternalBalance);\\n\\n        // If the asset in is ETH, then `amountIn` ETH was wrapped into WETH.\\n        _handleRemainingEth(_isETH(singleSwap.assetIn) ? amountIn : 0);\\n    }\\n\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        whenNotPaused\\n        authenticateFor(funds.sender)\\n        returns (int256[] memory assetDeltas)\\n    {\\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\\n        // solhint-disable-next-line not-rely-on-time\\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\\n\\n        InputHelpers.ensureInputLengthMatch(assets.length, limits.length);\\n\\n        // Perform the swaps, updating the Pool token balances and computing the net Vault asset deltas.\\n        assetDeltas = _swapWithPools(swaps, assets, funds, kind);\\n\\n        // Process asset deltas, by either transferring assets from the sender (for positive deltas) or to the recipient\\n        // (for negative deltas).\\n        uint256 wrappedEth = 0;\\n        for (uint256 i = 0; i < assets.length; ++i) {\\n            IAsset asset = assets[i];\\n            int256 delta = assetDeltas[i];\\n            _require(delta <= limits[i], Errors.SWAP_LIMIT);\\n\\n            if (delta > 0) {\\n                uint256 toReceive = uint256(delta);\\n                _receiveAsset(asset, toReceive, funds.sender, funds.fromInternalBalance);\\n\\n                if (_isETH(asset)) {\\n                    wrappedEth = wrappedEth.add(toReceive);\\n                }\\n            } else if (delta < 0) {\\n                uint256 toSend = uint256(-delta);\\n                _sendAsset(asset, toSend, funds.recipient, funds.toInternalBalance);\\n            }\\n        }\\n\\n        // Handle any used and remaining ETH.\\n        _handleRemainingEth(wrappedEth);\\n    }\\n\\n    // For `_swapWithPools` to handle both 'given in' and 'given out' swaps, it internally tracks the 'given' amount\\n    // (supplied by the caller), and the 'calculated' amount (returned by the Pool in response to the swap request).\\n\\n    /**\\n     * @dev Given the two swap tokens and the swap kind, returns which one is the 'given' token (the token whose\\n     * amount is supplied by the caller).\\n     */\\n    function _tokenGiven(\\n        SwapKind kind,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut\\n    ) private pure returns (IERC20) {\\n        return kind == SwapKind.GIVEN_IN ? tokenIn : tokenOut;\\n    }\\n\\n    /**\\n     * @dev Given the two swap tokens and the swap kind, returns which one is the 'calculated' token (the token whose\\n     * amount is calculated by the Pool).\\n     */\\n    function _tokenCalculated(\\n        SwapKind kind,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut\\n    ) private pure returns (IERC20) {\\n        return kind == SwapKind.GIVEN_IN ? tokenOut : tokenIn;\\n    }\\n\\n    /**\\n     * @dev Returns an ordered pair (amountIn, amountOut) given the 'given' and 'calculated' amounts, and the swap kind.\\n     */\\n    function _getAmounts(\\n        SwapKind kind,\\n        uint256 amountGiven,\\n        uint256 amountCalculated\\n    ) private pure returns (uint256 amountIn, uint256 amountOut) {\\n        if (kind == SwapKind.GIVEN_IN) {\\n            (amountIn, amountOut) = (amountGiven, amountCalculated);\\n        } else {\\n            // SwapKind.GIVEN_OUT\\n            (amountIn, amountOut) = (amountCalculated, amountGiven);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs all `swaps`, calling swap hooks on the Pool contracts and updating their balances. Does not cause\\n     * any transfer of tokens - instead it returns the net Vault token deltas: positive if the Vault should receive\\n     * tokens, and negative if it should send them.\\n     */\\n    function _swapWithPools(\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds,\\n        SwapKind kind\\n    ) private returns (int256[] memory assetDeltas) {\\n        assetDeltas = new int256[](assets.length);\\n\\n        // These variables could be declared inside the loop, but that causes the compiler to allocate memory on each\\n        // loop iteration, increasing gas costs.\\n        BatchSwapStep memory batchSwapStep;\\n        IPoolSwapStructs.SwapRequest memory poolRequest;\\n\\n        // These store data about the previous swap here to implement multihop logic across swaps.\\n        IERC20 previousTokenCalculated;\\n        uint256 previousAmountCalculated;\\n\\n        for (uint256 i = 0; i < swaps.length; ++i) {\\n            batchSwapStep = swaps[i];\\n\\n            bool withinBounds = batchSwapStep.assetInIndex < assets.length &&\\n                batchSwapStep.assetOutIndex < assets.length;\\n            _require(withinBounds, Errors.OUT_OF_BOUNDS);\\n\\n            IERC20 tokenIn = _translateToIERC20(assets[batchSwapStep.assetInIndex]);\\n            IERC20 tokenOut = _translateToIERC20(assets[batchSwapStep.assetOutIndex]);\\n            _require(tokenIn != tokenOut, Errors.CANNOT_SWAP_SAME_TOKEN);\\n\\n            // Sentinel value for multihop logic\\n            if (batchSwapStep.amount == 0) {\\n                // When the amount given is zero, we use the calculated amount for the previous swap, as long as the\\n                // current swap's given token is the previous calculated token. This makes it possible to swap a\\n                // given amount of token A for token B, and then use the resulting token B amount to swap for token C.\\n                _require(i > 0, Errors.UNKNOWN_AMOUNT_IN_FIRST_SWAP);\\n                bool usingPreviousToken = previousTokenCalculated == _tokenGiven(kind, tokenIn, tokenOut);\\n                _require(usingPreviousToken, Errors.MALCONSTRUCTED_MULTIHOP_SWAP);\\n                batchSwapStep.amount = previousAmountCalculated;\\n            }\\n\\n            // Initializing each struct field one-by-one uses less gas than setting all at once\\n            poolRequest.poolId = batchSwapStep.poolId;\\n            poolRequest.kind = kind;\\n            poolRequest.tokenIn = tokenIn;\\n            poolRequest.tokenOut = tokenOut;\\n            poolRequest.amount = batchSwapStep.amount;\\n            poolRequest.userData = batchSwapStep.userData;\\n            poolRequest.from = funds.sender;\\n            poolRequest.to = funds.recipient;\\n            // The lastChangeBlock field is left uninitialized\\n\\n            uint256 amountIn;\\n            uint256 amountOut;\\n            (previousAmountCalculated, amountIn, amountOut) = _swapWithPool(poolRequest);\\n\\n            previousTokenCalculated = _tokenCalculated(kind, tokenIn, tokenOut);\\n\\n            // Accumulate Vault deltas across swaps\\n            assetDeltas[batchSwapStep.assetInIndex] = assetDeltas[batchSwapStep.assetInIndex].add(amountIn.toInt256());\\n            assetDeltas[batchSwapStep.assetOutIndex] = assetDeltas[batchSwapStep.assetOutIndex].sub(\\n                amountOut.toInt256()\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a swap according to the parameters specified in `request`, calling the Pool's contract hook and\\n     * updating the Pool's balance.\\n     *\\n     * Returns the amount of tokens going into or out of the Vault as a result of this swap, depending on the swap kind.\\n     */\\n    function _swapWithPool(IPoolSwapStructs.SwapRequest memory request)\\n        private\\n        returns (\\n            uint256 amountCalculated,\\n            uint256 amountIn,\\n            uint256 amountOut\\n        )\\n    {\\n        // Get the calculated amount from the Pool and update its balances\\n        address pool = _getPoolAddress(request.poolId);\\n        PoolSpecialization specialization = _getPoolSpecialization(request.poolId);\\n\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            amountCalculated = _processTwoTokenPoolSwapRequest(request, IMinimalSwapInfoPool(pool));\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            amountCalculated = _processMinimalSwapInfoPoolSwapRequest(request, IMinimalSwapInfoPool(pool));\\n        } else {\\n            // PoolSpecialization.GENERAL\\n            amountCalculated = _processGeneralPoolSwapRequest(request, IGeneralPool(pool));\\n        }\\n\\n        (amountIn, amountOut) = _getAmounts(request.kind, request.amount, amountCalculated);\\n        emit Swap(request.poolId, request.tokenIn, request.tokenOut, amountIn, amountOut);\\n    }\\n\\n    function _processTwoTokenPoolSwapRequest(IPoolSwapStructs.SwapRequest memory request, IMinimalSwapInfoPool pool)\\n        private\\n        returns (uint256 amountCalculated)\\n    {\\n        // For gas efficiency reasons, this function uses low-level knowledge of how Two Token Pool balances are\\n        // stored internally, instead of using getters and setters for all operations.\\n\\n        (\\n            bytes32 tokenABalance,\\n            bytes32 tokenBBalance,\\n            TwoTokenPoolBalances storage poolBalances\\n        ) = _getTwoTokenPoolSharedBalances(request.poolId, request.tokenIn, request.tokenOut);\\n\\n        // We have the two Pool balances, but we don't know which one is 'token in' or 'token out'.\\n        bytes32 tokenInBalance;\\n        bytes32 tokenOutBalance;\\n\\n        // In Two Token Pools, token A has a smaller address than token B\\n        if (request.tokenIn < request.tokenOut) {\\n            // in is A, out is B\\n            tokenInBalance = tokenABalance;\\n            tokenOutBalance = tokenBBalance;\\n        } else {\\n            // in is B, out is A\\n            tokenOutBalance = tokenABalance;\\n            tokenInBalance = tokenBBalance;\\n        }\\n\\n        // Perform the swap request and compute the new balances for 'token in' and 'token out' after the swap\\n        (tokenInBalance, tokenOutBalance, amountCalculated) = _callMinimalSwapInfoPoolOnSwapHook(\\n            request,\\n            pool,\\n            tokenInBalance,\\n            tokenOutBalance\\n        );\\n\\n        // We check the token ordering again to create the new shared cash packed struct\\n        poolBalances.sharedCash = request.tokenIn < request.tokenOut\\n            ? BalanceAllocation.toSharedCash(tokenInBalance, tokenOutBalance) // in is A, out is B\\n            : BalanceAllocation.toSharedCash(tokenOutBalance, tokenInBalance); // in is B, out is A\\n    }\\n\\n    function _processMinimalSwapInfoPoolSwapRequest(\\n        IPoolSwapStructs.SwapRequest memory request,\\n        IMinimalSwapInfoPool pool\\n    ) private returns (uint256 amountCalculated) {\\n        bytes32 tokenInBalance = _getMinimalSwapInfoPoolBalance(request.poolId, request.tokenIn);\\n        bytes32 tokenOutBalance = _getMinimalSwapInfoPoolBalance(request.poolId, request.tokenOut);\\n\\n        // Perform the swap request and compute the new balances for 'token in' and 'token out' after the swap\\n        (tokenInBalance, tokenOutBalance, amountCalculated) = _callMinimalSwapInfoPoolOnSwapHook(\\n            request,\\n            pool,\\n            tokenInBalance,\\n            tokenOutBalance\\n        );\\n\\n        _minimalSwapInfoPoolsBalances[request.poolId][request.tokenIn] = tokenInBalance;\\n        _minimalSwapInfoPoolsBalances[request.poolId][request.tokenOut] = tokenOutBalance;\\n    }\\n\\n    /**\\n     * @dev Calls the onSwap hook for a Pool that implements IMinimalSwapInfoPool: both Minimal Swap Info and Two Token\\n     * Pools do this.\\n     */\\n    function _callMinimalSwapInfoPoolOnSwapHook(\\n        IPoolSwapStructs.SwapRequest memory request,\\n        IMinimalSwapInfoPool pool,\\n        bytes32 tokenInBalance,\\n        bytes32 tokenOutBalance\\n    )\\n        internal\\n        returns (\\n            bytes32 newTokenInBalance,\\n            bytes32 newTokenOutBalance,\\n            uint256 amountCalculated\\n        )\\n    {\\n        uint256 tokenInTotal = tokenInBalance.total();\\n        uint256 tokenOutTotal = tokenOutBalance.total();\\n        request.lastChangeBlock = Math.max(tokenInBalance.lastChangeBlock(), tokenOutBalance.lastChangeBlock());\\n\\n        // Perform the swap request callback, and compute the new balances for 'token in' and 'token out' after the swap\\n        amountCalculated = pool.onSwap(request, tokenInTotal, tokenOutTotal);\\n        (uint256 amountIn, uint256 amountOut) = _getAmounts(request.kind, request.amount, amountCalculated);\\n\\n        newTokenInBalance = tokenInBalance.increaseCash(amountIn);\\n        newTokenOutBalance = tokenOutBalance.decreaseCash(amountOut);\\n    }\\n\\n    function _processGeneralPoolSwapRequest(IPoolSwapStructs.SwapRequest memory request, IGeneralPool pool)\\n        private\\n        returns (uint256 amountCalculated)\\n    {\\n        bytes32 tokenInBalance;\\n        bytes32 tokenOutBalance;\\n\\n        // We access both token indexes without checking existence, because we will do it manually immediately after.\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[request.poolId];\\n        uint256 indexIn = poolBalances.unchecked_indexOf(request.tokenIn);\\n        uint256 indexOut = poolBalances.unchecked_indexOf(request.tokenOut);\\n\\n        if (indexIn == 0 || indexOut == 0) {\\n            // The tokens might not be registered because the Pool itself is not registered. We check this to provide a\\n            // more accurate revert reason.\\n            _ensureRegisteredPool(request.poolId);\\n            _revert(Errors.TOKEN_NOT_REGISTERED);\\n        }\\n\\n        // EnumerableMap stores indices *plus one* to use the zero index as a sentinel value - because these are valid,\\n        // we can undo this.\\n        indexIn -= 1;\\n        indexOut -= 1;\\n\\n        uint256 tokenAmount = poolBalances.length();\\n        uint256[] memory currentBalances = new uint256[](tokenAmount);\\n\\n        request.lastChangeBlock = 0;\\n        for (uint256 i = 0; i < tokenAmount; i++) {\\n            // Because the iteration is bounded by `tokenAmount`, and no tokens are registered or deregistered here, we\\n            // know `i` is a valid token index and can use `unchecked_valueAt` to save storage reads.\\n            bytes32 balance = poolBalances.unchecked_valueAt(i);\\n\\n            currentBalances[i] = balance.total();\\n            request.lastChangeBlock = Math.max(request.lastChangeBlock, balance.lastChangeBlock());\\n\\n            if (i == indexIn) {\\n                tokenInBalance = balance;\\n            } else if (i == indexOut) {\\n                tokenOutBalance = balance;\\n            }\\n        }\\n\\n        // Perform the swap request callback and compute the new balances for 'token in' and 'token out' after the swap\\n        amountCalculated = pool.onSwap(request, currentBalances, indexIn, indexOut);\\n        (uint256 amountIn, uint256 amountOut) = _getAmounts(request.kind, request.amount, amountCalculated);\\n        tokenInBalance = tokenInBalance.increaseCash(amountIn);\\n        tokenOutBalance = tokenOutBalance.decreaseCash(amountOut);\\n\\n        // Because no tokens were registered or deregistered between now or when we retrieved the indexes for\\n        // 'token in' and 'token out', we can use `unchecked_setAt` to save storage reads.\\n        poolBalances.unchecked_setAt(indexIn, tokenInBalance);\\n        poolBalances.unchecked_setAt(indexOut, tokenOutBalance);\\n    }\\n\\n    // This function is not marked as `nonReentrant` because the underlying mechanism relies on reentrancy\\n    function queryBatchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds\\n    ) external override returns (int256[] memory) {\\n        // In order to accurately 'simulate' swaps, this function actually does perform the swaps, including calling the\\n        // Pool hooks and updating balances in storage. However, once it computes the final Vault Deltas, it\\n        // reverts unconditionally, returning this array as the revert data.\\n        //\\n        // By wrapping this reverting call, we can decode the deltas 'returned' and return them as a normal Solidity\\n        // function would. The only caveat is the function becomes non-view, but off-chain clients can still call it\\n        // via eth_call to get the expected result.\\n        //\\n        // This technique was inspired by the work from the Gnosis team in the Gnosis Safe contract:\\n        // https://github.com/gnosis/safe-contracts/blob/v1.2.0/contracts/GnosisSafe.sol#L265\\n        //\\n        // Most of this function is implemented using inline assembly, as the actual work it needs to do is not\\n        // significant, and Solidity is not particularly well-suited to generate this behavior, resulting in a large\\n        // amount of generated bytecode.\\n\\n        if (msg.sender != address(this)) {\\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\\n            // the preceding if statement will be executed instead.\\n\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = address(this).call(msg.data);\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                // This call should always revert to decode the actual asset deltas from the revert reason\\n                switch success\\n                    case 0 {\\n                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\\n                        // stored there as we take full control of the execution and then immediately return.\\n\\n                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\\n                        // there was another revert reason and we should forward it.\\n                        returndatacopy(0, 0, 0x04)\\n                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\\n\\n                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.\\n                        if eq(eq(error, 0xfa61cc1200000000000000000000000000000000000000000000000000000000), 0) {\\n                            returndatacopy(0, 0, returndatasize())\\n                            revert(0, returndatasize())\\n                        }\\n\\n                        // The returndata contains the signature, followed by the raw memory representation of an array:\\n                        // length + data. We need to return an ABI-encoded representation of this array.\\n                        // An ABI-encoded array contains an additional field when compared to its raw memory\\n                        // representation: an offset to the location of the length. The offset itself is 32 bytes long,\\n                        // so the smallest value we  can use is 32 for the data to be located immediately after it.\\n                        mstore(0, 32)\\n\\n                        // We now copy the raw memory array from returndata into memory. Since the offset takes up 32\\n                        // bytes, we start copying at address 0x20. We also get rid of the error signature, which takes\\n                        // the first four bytes of returndata.\\n                        let size := sub(returndatasize(), 0x04)\\n                        returndatacopy(0x20, 0x04, size)\\n\\n                        // We finally return the ABI-encoded array, which has a total length equal to that of the array\\n                        // (returndata), plus the 32 bytes for the offset.\\n                        return(0, add(size, 32))\\n                    }\\n                    default {\\n                        // This call should always revert, but we fail nonetheless if that didn't happen\\n                        invalid()\\n                    }\\n            }\\n        } else {\\n            int256[] memory deltas = _swapWithPools(swaps, assets, funds, kind);\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                // We will return a raw representation of the array in memory, which is composed of a 32 byte length,\\n                // followed by the 32 byte int256 values. Because revert expects a size in bytes, we multiply the array\\n                // length (stored at `deltas`) by 32.\\n                let size := mul(mload(deltas), 32)\\n\\n                // We send one extra value for the error signature \\\"QueryError(int256[])\\\" which is 0xfa61cc12.\\n                // We store it in the previous slot to the `deltas` array. We know there will be at least one available\\n                // slot due to how the memory scratch space works.\\n                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\\n                mstore(sub(deltas, 0x20), 0x00000000000000000000000000000000000000000000000000000000fa61cc12)\\n                let start := sub(deltas, 0x04)\\n\\n                // When copying from `deltas` into returndata, we copy an additional 36 bytes to also return the array's\\n                // length and the error signature.\\n                revert(start, add(size, 36))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4678ad241498693524a692b1bc2bd40523e523cd6c916a05d9f07e03965774b6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/UserBalance.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../Math.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/SafeCast.sol\\\";\\nimport \\\"../ERC20/SafeERC20.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./AssetTransfersHandler.sol\\\";\\nimport \\\"./VaultAuthorization.sol\\\";\\n\\n/**\\n * Implement User Balance interactions, which combine Internal Balance and using the Vault's ERC20 allowance.\\n *\\n * Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n * transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n * when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n * gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n *\\n * Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n * operations of different kinds, with different senders and recipients, at once.\\n */\\nabstract contract UserBalance is ReentrancyGuard, AssetTransfersHandler, VaultAuthorization {\\n    using Math for uint256;\\n    using SafeCast for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Internal Balance for each token, for each account.\\n    mapping(address => mapping(IERC20 => uint256)) private _internalTokenBalance;\\n\\n    function getInternalBalance(address user, IERC20[] memory tokens)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory balances)\\n    {\\n        balances = new uint256[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            balances[i] = _getInternalBalance(user, tokens[i]);\\n        }\\n    }\\n\\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable override nonReentrant {\\n        // We need to track how much of the received ETH was used and wrapped into WETH to return any excess.\\n        uint256 ethWrapped = 0;\\n\\n        // Cache for these checks so we only perform them once (if at all).\\n        bool checkedCallerIsRelayer = false;\\n        bool checkedNotPaused = false;\\n\\n        for (uint256 i = 0; i < ops.length; i++) {\\n            UserBalanceOpKind kind;\\n            IAsset asset;\\n            uint256 amount;\\n            address sender;\\n            address payable recipient;\\n\\n            // This destructuring by calling `_validateUserBalanceOp` seems odd, but results in reduced bytecode size.\\n            (kind, asset, amount, sender, recipient, checkedCallerIsRelayer) = _validateUserBalanceOp(\\n                ops[i],\\n                checkedCallerIsRelayer\\n            );\\n\\n            if (kind == UserBalanceOpKind.WITHDRAW_INTERNAL) {\\n                // Internal Balance withdrawals can always be performed by an authorized account.\\n                _withdrawFromInternalBalance(asset, sender, recipient, amount);\\n            } else {\\n                // All other operations are blocked if the contract is paused.\\n\\n                // We cache the result of the pause check and skip it for other operations in this same transaction\\n                // (if any).\\n                if (!checkedNotPaused) {\\n                    _ensureNotPaused();\\n                    checkedNotPaused = true;\\n                }\\n\\n                if (kind == UserBalanceOpKind.DEPOSIT_INTERNAL) {\\n                    _depositToInternalBalance(asset, sender, recipient, amount);\\n\\n                    // Keep track of all ETH wrapped into WETH as part of a deposit.\\n                    if (_isETH(asset)) {\\n                        ethWrapped = ethWrapped.add(amount);\\n                    }\\n                } else {\\n                    // Transfers don't support ETH.\\n                    _require(!_isETH(asset), Errors.CANNOT_USE_ETH_SENTINEL);\\n                    IERC20 token = _asIERC20(asset);\\n\\n                    if (kind == UserBalanceOpKind.TRANSFER_INTERNAL) {\\n                        _transferInternalBalance(token, sender, recipient, amount);\\n                    } else {\\n                        // TRANSFER_EXTERNAL\\n                        _transferToExternalBalance(token, sender, recipient, amount);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Handle any remaining ETH.\\n        _handleRemainingEth(ethWrapped);\\n    }\\n\\n    function _depositToInternalBalance(\\n        IAsset asset,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        _increaseInternalBalance(recipient, _translateToIERC20(asset), amount);\\n        _receiveAsset(asset, amount, sender, false);\\n    }\\n\\n    function _withdrawFromInternalBalance(\\n        IAsset asset,\\n        address sender,\\n        address payable recipient,\\n        uint256 amount\\n    ) private {\\n        // A partial decrease of Internal Balance is disallowed: `sender` must have the full `amount`.\\n        _decreaseInternalBalance(sender, _translateToIERC20(asset), amount, false);\\n        _sendAsset(asset, amount, recipient, false);\\n    }\\n\\n    function _transferInternalBalance(\\n        IERC20 token,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        // A partial decrease of Internal Balance is disallowed: `sender` must have the full `amount`.\\n        _decreaseInternalBalance(sender, token, amount, false);\\n        _increaseInternalBalance(recipient, token, amount);\\n    }\\n\\n    function _transferToExternalBalance(\\n        IERC20 token,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        if (amount > 0) {\\n            token.safeTransferFrom(sender, recipient, amount);\\n            emit ExternalBalanceTransfer(token, sender, recipient, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Increases `account`'s Internal Balance for `token` by `amount`.\\n     */\\n    function _increaseInternalBalance(\\n        address account,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal override {\\n        uint256 currentBalance = _getInternalBalance(account, token);\\n        uint256 newBalance = currentBalance.add(amount);\\n        _setInternalBalance(account, token, newBalance, amount.toInt256());\\n    }\\n\\n    /**\\n     * @dev Decreases `account`'s Internal Balance for `token` by `amount`. If `allowPartial` is true, this function\\n     * doesn't revert if `account` doesn't have enough balance, and sets it to zero and returns the deducted amount\\n     * instead.\\n     */\\n    function _decreaseInternalBalance(\\n        address account,\\n        IERC20 token,\\n        uint256 amount,\\n        bool allowPartial\\n    ) internal override returns (uint256 deducted) {\\n        uint256 currentBalance = _getInternalBalance(account, token);\\n        _require(allowPartial || (currentBalance >= amount), Errors.INSUFFICIENT_INTERNAL_BALANCE);\\n\\n        deducted = Math.min(currentBalance, amount);\\n        // By construction, `deducted` is lower or equal to `currentBalance`, so we don't need to use checked\\n        // arithmetic.\\n        uint256 newBalance = currentBalance - deducted;\\n        _setInternalBalance(account, token, newBalance, -(deducted.toInt256()));\\n    }\\n\\n    /**\\n     * @dev Sets `account`'s Internal Balance for `token` to `newBalance`.\\n     *\\n     * Emits an `InternalBalanceChanged` event. This event includes `delta`, which is the amount the balance increased\\n     * (if positive) or decreased (if negative). To avoid reading the current balance in order to compute the delta,\\n     * this function relies on the caller providing it directly.\\n     */\\n    function _setInternalBalance(\\n        address account,\\n        IERC20 token,\\n        uint256 newBalance,\\n        int256 delta\\n    ) private {\\n        _internalTokenBalance[account][token] = newBalance;\\n        emit InternalBalanceChanged(account, token, delta);\\n    }\\n\\n    /**\\n     * @dev Returns `account`'s Internal Balance for `token`.\\n     */\\n    function _getInternalBalance(address account, IERC20 token) internal view returns (uint256) {\\n        return _internalTokenBalance[account][token];\\n    }\\n\\n    /**\\n     * @dev Destructures a User Balance operation, validating that the contract caller is allowed to perform it.\\n     */\\n    function _validateUserBalanceOp(UserBalanceOp memory op, bool checkedCallerIsRelayer)\\n        private\\n        view\\n        returns (\\n            UserBalanceOpKind,\\n            IAsset,\\n            uint256,\\n            address,\\n            address payable,\\n            bool\\n        )\\n    {\\n        // The only argument we need to validate is `sender`, which can only be either the contract caller, or a\\n        // relayer approved by `sender`.\\n        address sender = op.sender;\\n\\n        if (sender != msg.sender) {\\n            // We need to check both that the contract caller is a relayer, and that `sender` approved them.\\n\\n            // Because the relayer check is global (i.e. independent of `sender`), we cache that result and skip it for\\n            // other operations in this same transaction (if any).\\n            if (!checkedCallerIsRelayer) {\\n                _authenticateCaller();\\n                checkedCallerIsRelayer = true;\\n            }\\n\\n            _require(_hasApprovedRelayer(sender, msg.sender), Errors.USER_DOESNT_ALLOW_RELAYER);\\n        }\\n\\n        return (op.kind, op.asset, op.amount, sender, op.recipient, checkedCallerIsRelayer);\\n    }\\n}\\n\",\"keccak256\":\"0x4cf9c8a46544af8d5de2cd1f9d191f846e02e7b7397db0e2c1c7d7b08d85ce4e\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../misc/IWETH.sol\\\";\\n\\nimport \\\"./IAuthorizer.sol\\\";\\n\\nimport \\\"./VaultAuthorization.sol\\\";\\nimport \\\"./FlashLoans.sol\\\";\\nimport \\\"./Swaps.sol\\\";\\n\\n/**\\n * @dev The `Vault` is Balancer V2's core contract. A single instance of it exists for the entire network, and it is the\\n * entity used to interact with Pools by Liquidity Providers who join and exit them, Traders who swap, and Asset\\n * Managers who withdraw and deposit tokens.\\n *\\n * The `Vault`'s source code is split among a number of sub-contracts, with the goal of improving readability and making\\n * understanding the system easier. Most sub-contracts have been marked as `abstract` to explicitly indicate that only\\n * the full `Vault` is meant to be deployed.\\n *\\n * Roughly speaking, these are the contents of each sub-contract:\\n *\\n *  - `AssetManagers`: Pool token Asset Manager registry, and Asset Manager interactions.\\n *  - `Fees`: set and compute protocol fees.\\n *  - `FlashLoans`: flash loan transfers and fees.\\n *  - `PoolBalances`: Pool joins and exits.\\n *  - `PoolRegistry`: Pool registration, ID management, and basic queries.\\n *  - `PoolTokens`: Pool token registration and registration, and balance queries.\\n *  - `Swaps`: Pool swaps.\\n *  - `UserBalance`: manage user balances (Internal Balance operations and external balance transfers)\\n *  - `VaultAuthorization`: access control, relayers and signature validation.\\n *\\n * Additionally, the different Pool specializations are handled by the `GeneralPoolsBalance`,\\n * `MinimalSwapInfoPoolsBalance` and `TwoTokenPoolsBalance` sub-contracts, which in turn make use of the\\n * `BalanceAllocation` library.\\n *\\n * The most important goal of the `Vault` is to make token swaps use as little gas as possible. This is reflected in a\\n * multitude of design decisions, from minor things like the format used to store Pool IDs, to major features such as\\n * the different Pool specialization settings.\\n *\\n * Finally, the large number of tasks carried out by the Vault means its bytecode is very large, close to exceeding\\n * the contract size limit imposed by EIP 170 (https://eips.ethereum.org/EIPS/eip-170). Manual tuning of the source code\\n * was required to improve code generation and bring the bytecode size below this limit. This includes extensive\\n * utilization of `internal` functions (particularly inside modifiers), usage of named return arguments, dedicated\\n * storage access methods, dynamic revert reason generation, and usage of inline assembly, to name a few.\\n */\\ncontract Vault is VaultAuthorization, FlashLoans, Swaps {\\n    constructor(\\n        IAuthorizer authorizer,\\n        IWETH weth,\\n        uint256 pauseWindowDuration,\\n        uint256 bufferPeriodDuration\\n    ) VaultAuthorization(authorizer) AssetHelpers(weth) TemporarilyPausable(pauseWindowDuration, bufferPeriodDuration) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function setPaused(bool paused) external override nonReentrant authenticate {\\n        _setPaused(paused);\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function WETH() external view override returns (IWETH) {\\n        return _WETH();\\n    }\\n}\\n\",\"keccak256\":\"0xb22f83c0f52edfbcde3f52b8d79d3f231abe46293d6bc74cc2612fa0531a3678\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/VaultAuthorization.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../BalancerErrors.sol\\\";\\nimport \\\"../Authentication.sol\\\";\\nimport \\\"../utils/TemporarilyPausable.sol\\\";\\nimport \\\"../utils/SignaturesValidator.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\n\\n/**\\n * @dev Manages access control of Vault permissioned functions by relying on the Authorizer and signature validation.\\n *\\n * Additionally handles relayer access and approval.\\n */\\nabstract contract VaultAuthorization is\\n    IVault,\\n    ReentrancyGuard,\\n    Authentication,\\n    SignaturesValidator,\\n    TemporarilyPausable\\n{\\n    // Ideally, we'd store the type hashes as immutable state variables to avoid computing the hash at runtime, but\\n    // unfortunately immutable variables cannot be used in assembly, so we just keep the precomputed hashes instead.\\n\\n    // _JOIN_TYPE_HASH = keccak256(\\\"JoinPool(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _JOIN_TYPE_HASH = 0x3f7b71252bd19113ff48c19c6e004a9bcfcca320a0d74d58e85877cbd7dcae58;\\n\\n    // _EXIT_TYPE_HASH = keccak256(\\\"ExitPool(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _EXIT_TYPE_HASH = 0x8bbc57f66ea936902f50a71ce12b92c43f3c5340bb40c27c4e90ab84eeae3353;\\n\\n    // _SWAP_TYPE_HASH = keccak256(\\\"Swap(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _SWAP_TYPE_HASH = 0xe192dcbc143b1e244ad73b813fd3c097b832ad260a157340b4e5e5beda067abe;\\n\\n    // _BATCH_SWAP_TYPE_HASH = keccak256(\\\"BatchSwap(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _BATCH_SWAP_TYPE_HASH = 0x9bfc43a4d98313c6766986ffd7c916c7481566d9f224c6819af0a53388aced3a;\\n\\n    // _SET_RELAYER_TYPE_HASH =\\n    //     keccak256(\\\"SetRelayerApproval(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32\\n        private constant _SET_RELAYER_TYPE_HASH = 0xa3f865aa351e51cfeb40f5178d1564bb629fe9030b83caf6361d1baaf5b90b5a;\\n\\n    IAuthorizer private _authorizer;\\n    mapping(address => mapping(address => bool)) private _approvedRelayers;\\n\\n    /**\\n     * @dev Reverts unless `user` is the caller, or the caller is approved by the Authorizer to call this function (that\\n     * is, it is a relayer for that function), and either:\\n     *  a) `user` approved the caller as a relayer (via `setRelayerApproval`), or\\n     *  b) a valid signature from them was appended to the calldata.\\n     *\\n     * Should only be applied to external functions.\\n     */\\n    modifier authenticateFor(address user) {\\n        _authenticateFor(user);\\n        _;\\n    }\\n\\n    constructor(IAuthorizer authorizer)\\n        // The Vault is a singleton, so it simply uses its own address to disambiguate action identifiers.\\n        Authentication(bytes32(uint256(address(this))))\\n        SignaturesValidator(\\\"Balancer V2 Vault\\\")\\n    {\\n        _setAuthorizer(authorizer);\\n    }\\n\\n    function setAuthorizer(IAuthorizer newAuthorizer) external override nonReentrant authenticate {\\n        _setAuthorizer(newAuthorizer);\\n    }\\n\\n    function _setAuthorizer(IAuthorizer newAuthorizer) private {\\n        emit AuthorizerChanged(newAuthorizer);\\n        _authorizer = newAuthorizer;\\n    }\\n\\n    function getAuthorizer() external view override returns (IAuthorizer) {\\n        return _authorizer;\\n    }\\n\\n    function setRelayerApproval(\\n        address sender,\\n        address relayer,\\n        bool approved\\n    ) external override nonReentrant whenNotPaused authenticateFor(sender) {\\n        _approvedRelayers[sender][relayer] = approved;\\n        emit RelayerApprovalChanged(relayer, sender, approved);\\n    }\\n\\n    function hasApprovedRelayer(address user, address relayer) external view override returns (bool) {\\n        return _hasApprovedRelayer(user, relayer);\\n    }\\n\\n    /**\\n     * @dev Reverts unless `user` is the caller, or the caller is approved by the Authorizer to call the entry point\\n     * function (that is, it is a relayer for that function) and either:\\n     *  a) `user` approved the caller as a relayer (via `setRelayerApproval`), or\\n     *  b) a valid signature from them was appended to the calldata.\\n     */\\n    function _authenticateFor(address user) internal {\\n        if (msg.sender != user) {\\n            // In this context, 'permission to call a function' means 'being a relayer for a function'.\\n            _authenticateCaller();\\n\\n            // Being a relayer is not sufficient: `user` must have also approved the caller either via\\n            // `setRelayerApproval`, or by providing a signature appended to the calldata.\\n            if (!_hasApprovedRelayer(user, msg.sender)) {\\n                _validateSignature(user, Errors.USER_DOESNT_ALLOW_RELAYER);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if `user` approved `relayer` to act as a relayer for them.\\n     */\\n    function _hasApprovedRelayer(address user, address relayer) internal view returns (bool) {\\n        return _approvedRelayers[user][relayer];\\n    }\\n\\n    function _canPerform(bytes32 actionId, address user) internal view override returns (bool) {\\n        // Access control is delegated to the Authorizer.\\n        return _authorizer.canPerform(actionId, user, address(this));\\n    }\\n\\n    function _typeHash() internal pure override returns (bytes32 hash) {\\n        // This is a simple switch-case statement, trivially written in Solidity by chaining else-if statements, but the\\n        // assembly implementation results in much denser bytecode.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // The function selector is located at the first 4 bytes of calldata. We copy the first full calldata\\n            // 256 word, and then perform a logical shift to the right, moving the selector to the least significant\\n            // 4 bytes.\\n            let selector := shr(224, calldataload(0))\\n\\n            // With the selector in the least significant 4 bytes, we can use 4 byte literals with leading zeros,\\n            // resulting in dense bytecode (PUSH4 opcodes).\\n            switch selector\\n                case 0xb95cac28 {\\n                    hash := _JOIN_TYPE_HASH\\n                }\\n                case 0x8bdb3913 {\\n                    hash := _EXIT_TYPE_HASH\\n                }\\n                case 0x52bbbe29 {\\n                    hash := _SWAP_TYPE_HASH\\n                }\\n                case 0x945bcec9 {\\n                    hash := _BATCH_SWAP_TYPE_HASH\\n                }\\n                case 0xfa6e671d {\\n                    hash := _SET_RELAYER_TYPE_HASH\\n                }\\n                default {\\n                    hash := 0x0000000000000000000000000000000000000000000000000000000000000000\\n                }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x76b4176c34d5f21c4511f51874941a596eef51fc7f3b5cf3e608caea8cd84365\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x6101806040523480156200001257600080fd5b50604051620066f6380380620066f6833981016040819052620000359162000253565b8382826040518060400160405280601181526020017010985b185b98d95c88158c8815985d5b1d607a1b81525080604051806040016040528060018152602001603160f81b815250306001600160a01b031660001b89806001600160a01b03166080816001600160a01b031660601b815250505030604051620000b89062000245565b620000c491906200029f565b604051809103906000f080158015620000e1573d6000803e3d6000fd5b5060601b6001600160601b03191660a052600160005560c052815160209283012060e052805191012061010052507f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f61012052620001486276a70083111561019462000181565b6200015c62278d0082111561019562000181565b429091016101408190520161016052620001768162000196565b5050505050620002cc565b8162000192576200019281620001f2565b5050565b6040516001600160a01b038216907f94b979b6831a51293e2641426f97747feed46f17779fed9cd18d1ecefcfe92ef90600090a2600380546001600160a01b0390921661010002610100600160a81b0319909216919091179055565b62461bcd60e51b6000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b610c798062005a7d83390190565b6000806000806080858703121562000269578384fd5b84516200027681620002b3565b60208601519094506200028981620002b3565b6040860151606090960151949790965092505050565b6001600160a01b0391909116815260200190565b6001600160a01b0381168114620002c957600080fd5b50565b60805160601c60a05160601c60c05160e0516101005161012051610140516101605161574d6200033060003980611ba0525080611b7c5250806128035250806128455250806128245250806111585250806113e5525080610535525061574d6000f3fe6080604052600436106101a55760003560e01c8063945bcec9116100e1578063e6c460921161008a578063f84d066e11610064578063f84d066e14610497578063f94d4668146104b7578063fa6e671d146104e6578063fec90d7214610506576101d3565b8063e6c4609214610434578063ed24911d14610454578063f6c0092714610469576101d3565b8063b05f8e48116100bb578063b05f8e48146103dc578063b95cac281461040c578063d2946c2b1461041f576101d3565b8063945bcec914610385578063aaabadc5146103a5578063ad5c4648146103c7576101d3565b806352bbbe291161014e5780637d3aeb96116101285780637d3aeb9614610305578063851c1bb3146103255780638bdb39131461034557806390193b7c14610365576101d3565b806352bbbe29146102b25780635c38449e146102c557806366a9c7d2146102e5576101d3565b80630f5a6efa1161017f5780630f5a6efa1461024157806316c38b3c1461026e5780631c0de0511461028e576101d3565b8063058a628f146101d857806309b2760f146101f85780630e8e3e841461022e576101d3565b366101d3576101d16101b5610533565b6001600160a01b0316336001600160a01b031614610206610558565b005b600080fd5b3480156101e457600080fd5b506101d16101f336600461494b565b61056a565b34801561020457600080fd5b50610218610213366004614e9b565b61058e565b6040516102259190615529565b60405180910390f35b6101d161023c366004614b12565b61065f565b34801561024d57600080fd5b5061026161025c3660046149e9565b61079b565b60405161022591906154f3565b34801561027a57600080fd5b506101d1610289366004614bf9565b610831565b34801561029a57600080fd5b506102a361084a565b60405161022593929190615511565b6102186102c0366004615044565b610873565b3480156102d157600080fd5b506101d16102e0366004614e10565b610a14565b3480156102f157600080fd5b506101d1610300366004614ce2565b610e31565b34801561031157600080fd5b506101d1610320366004614cb3565b610fe8565b34801561033157600080fd5b50610218610340366004614dd0565b611154565b34801561035157600080fd5b506101d1610360366004614c49565b610e2b565b34801561037157600080fd5b5061021861038036600461494b565b6111a6565b610398610393366004614f3b565b6111c1565b60405161022591906154af565b3480156103b157600080fd5b506103ba6112f5565b6040516102259190615343565b3480156103d357600080fd5b506103ba611309565b3480156103e857600080fd5b506103fc6103f7366004614dac565b611318565b6040516102259493929190615646565b6101d161041a366004614c49565b6113db565b34801561042b57600080fd5b506103ba6113e3565b34801561044057600080fd5b506101d161044f366004614a37565b611407565b34801561046057600080fd5b50610218611523565b34801561047557600080fd5b50610489610484366004614c31565b61152d565b60405161022592919061537b565b3480156104a357600080fd5b506103986104b2366004614eb7565b611557565b3480156104c357600080fd5b506104d76104d2366004614c31565b61166c565b60405161022593929190615479565b3480156104f257600080fd5b506101d161050136600461499f565b6116a0565b34801561051257600080fd5b50610526610521366004614967565b611750565b6040516102259190615506565b7f00000000000000000000000000000000000000000000000000000000000000005b90565b816105665761056681611765565b5050565b6105726117d2565b61057a6117eb565b61058381611831565b61058b6118a4565b50565b60006105986117d2565b6105a06118ab565b60006105af33846006546118c0565b6000818152600560205260409020549091506105d19060ff16156101f4610558565b6000818152600560205260409081902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600190811790915560068054909101905551339082907f3c13bc30b8e878c53fd2a36b679409c073afd75950be43d8858768e956fbc20e906106489087906155c7565b60405180910390a3905061065a6118a4565b919050565b6106676117d2565b6000806000805b845181101561078657600080600080600061069c8a878151811061068e57fe5b602002602001015189611912565b9c5093985091965094509250905060018560038111156106b857fe5b14156106cf576106ca8483838661198a565b610775565b866106e1576106dc6118ab565b600196505b60008560038111156106ef57fe5b141561072057610701848383866119ad565b61070a846119cd565b156106ca5761071989846119da565b9850610775565b61073561072c856119cd565b15610207610558565b600061074085610555565b9050600286600381111561075057fe5b141561076757610762818484876119ec565b610773565b61077381848487611a05565b505b50506001909301925061066e915050565b5061079083611a73565b50505061058b6118a4565b6060815167ffffffffffffffff811180156107b557600080fd5b506040519080825280602002602001820160405280156107df578160200160208202803683370190505b50905060005b825181101561082a5761080b848483815181106107fe57fe5b6020026020010151611a96565b82828151811061081757fe5b60209081029190910101526001016107e5565b5092915050565b6108396117d2565b6108416117eb565b61058381611ac1565b6000806000610857611b5d565b159250610862611b7a565b915061086c611b9e565b9050909192565b600061087d6117d2565b6108856118ab565b835161089081611bc2565b61089f834211156101fc610558565b6108b260008760800151116101fe610558565b60006108c18760400151611bf4565b905060006108d28860600151611bf4565b90506108f5816001600160a01b0316836001600160a01b031614156101fd610558565b6108fd61455d565b8851608082015260208901518190600181111561091657fe5b9081600181111561092357fe5b9052506001600160a01b03808416602083015282811660408084019190915260808b0151606084015260a08b01516101008401528951821660c08401528901511660e082015260008061097583611c19565b919850925090506109ac60008c60200151600181111561099157fe5b1461099f57898311156109a4565b898210155b6101fb610558565b6109c48b60400151838c600001518d60200151611d0d565b6109dc8b60600151828c604001518d60600151611deb565b6109fe6109ec8c604001516119cd565b6109f75760006109f9565b825b611a73565b505050505050610a0c6118a4565b949350505050565b610a1c6117d2565b610a246118ab565b610a3083518351611ec0565b6060835167ffffffffffffffff81118015610a4a57600080fd5b50604051908082528060200260200182016040528015610a74578160200160208202803683370190505b5090506060845167ffffffffffffffff81118015610a9157600080fd5b50604051908082528060200260200182016040528015610abb578160200160208202803683370190505b5090506000805b8651811015610c34576000878281518110610ad957fe5b602002602001015190506000878381518110610af157fe5b60200260200101519050610b3c846001600160a01b0316836001600160a01b03161160006001600160a01b0316846001600160a01b031614610b34576066610b37565b60685b610558565b819350816001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610b6b9190615343565b60206040518083038186803b158015610b8357600080fd5b505afa158015610b97573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bbb919061511d565b858481518110610bc757fe5b602002602001018181525050610bdc81611ecd565b868481518110610be857fe5b602002602001018181525050610c1681868581518110610c0457fe5b60200260200101511015610210610558565b610c2a6001600160a01b0383168b83611f54565b5050600101610ac2565b506040517ff04f27070000000000000000000000000000000000000000000000000000000081526001600160a01b0388169063f04f270790610c80908990899088908a9060040161542c565b600060405180830381600087803b158015610c9a57600080fd5b505af1158015610cae573d6000803e3d6000fd5b5050505060005b8651811015610e1f576000878281518110610ccc57fe5b602002602001015190506000848381518110610ce457fe5b602002602001015190506000826001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610d1c9190615343565b60206040518083038186803b158015610d3457600080fd5b505afa158015610d48573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d6c919061511d565b9050610d7d82821015610203610558565b60008282039050610da6888681518110610d9357fe5b602002602001015182101561025a610558565b610db08482611fd7565b836001600160a01b03168c6001600160a01b03167f0d7d75e01ab95780d3cd1c8ec0dd6c2ce19e3a20427eec8bf53283b6fb8e95f08c8881518110610df157fe5b602002602001015184604051610e089291906155da565b60405180910390a350505050806001019050610cb5565b50505050610e2b6118a4565b50505050565b610e396117d2565b610e416118ab565b82610e4b81611ff9565b610e5783518351611ec0565b60005b8351811015610f0d576000848281518110610e7157fe5b60200260200101519050610e9d60006001600160a01b0316826001600160a01b03161415610135610558565b838281518110610ea957fe5b6020908102919091018101516000888152600a835260408082206001600160a01b0395861683529093529190912080547fffffffffffffffffffffffff00000000000000000000000000000000000000001692909116919091179055600101610e5a565b506000610f198561202a565b90506002816002811115610f2957fe5b1415610f7757610f3f845160021461020c610558565b610f728585600081518110610f5057fe5b602002602001015186600181518110610f6557fe5b6020026020010151612044565b610f9f565b6001816002811115610f8557fe5b1415610f9557610f728585612108565b610f9f8585612160565b847ff5847d3f2197b16cdcd2098ec95d0905cd1abdaf415f07bb7cef2bba8ac5dec48585604051610fd19291906153cd565b60405180910390a25050610fe36118a4565b505050565b610ff06117d2565b610ff86118ab565b8161100281611ff9565b600061100d8461202a565b9050600281600281111561101d57fe5b141561106b57611033835160021461020c610558565b611066848460008151811061104457fe5b60200260200101518560018151811061105957fe5b60200260200101516121b5565b611093565b600181600281111561107957fe5b141561108957611066848461223b565b61109384846122f5565b60005b835181101561111157600a600086815260200190815260200160002060008583815181106110c057fe5b6020908102919091018101516001600160a01b0316825281019190915260400160002080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055600101611096565b50837f7dcdc6d02ef40c7c1a7046a011b058bd7f988fa14e20a66344f9d4e60657d6108460405161114291906153ba565b60405180910390a250506105666118a4565b60007f000000000000000000000000000000000000000000000000000000000000000082604051602001611189929190615277565b604051602081830303815290604052805190602001209050919050565b6001600160a01b031660009081526002602052604090205490565b60606111cb6117d2565b6111d36118ab565b83516111de81611bc2565b6111ed834211156101fc610558565b6111f986518551611ec0565b6112058787878b612358565b91506000805b87518110156112d757600088828151811061122257fe5b60200260200101519050600085838151811061123a57fe5b6020026020010151905061126688848151811061125357fe5b60200260200101518213156101fb610558565b60008113156112a657885160208a015182916112859185918491611d0d565b61128e836119cd565b156112a05761129d85826119da565b94505b506112cd565b60008112156112cd5760008160000390506112cb83828c604001518d60600151611deb565b505b505060010161120b565b506112e181611a73565b50506112eb6118a4565b9695505050505050565b60035461010090046001600160a01b031690565b6000611313610533565b905090565b60008060008085611328816125e7565b6000806113348961202a565b9050600281600281111561134457fe5b141561135b576113548989612605565b9150611386565b600181600281111561136957fe5b141561137957611354898961267f565b61138389896126ed565b91505b61138f82612705565b965061139a82612718565b95506113a58261272e565b6000998a52600a60209081526040808c206001600160a01b039b8c168d5290915290992054969995989796909616955050505050565b610e2b6118ab565b7f000000000000000000000000000000000000000000000000000000000000000090565b61140f6117d2565b6114176118ab565b61141f6145ad565b60005b82518110156115195782818151811061143757fe5b60200260200101519150600082602001519050611453816125e7565b604083015161146d6114658383612734565b610209610558565b6000828152600a602090815260408083206001600160a01b0385811685529252909120546114a0911633146101f6610558565b835160608501516000806114b684878786612790565b91509150846001600160a01b0316336001600160a01b0316877f6edcaf6241105b4c94c2efdbf3a6b12458eb3d07be3a0e81d24b13c44045fe7a85856040516115009291906155da565b60405180910390a4505050505050806001019050611422565b505061058b6118a4565b60006113136127ff565b6000808261153a816125e7565b6115438461289c565b61154c8561202a565b925092505b50915091565b6060333014611642576000306001600160a01b031660003660405161157d9291906152a7565b6000604051808303816000865af19150503d80600081146115ba576040519150601f19603f3d011682016040523d82523d6000602084013e6115bf565b606091505b5050905080600081146115ce57fe5b60046000803e6000517fffffffff00000000000000000000000000000000000000000000000000000000167ffa61cc1200000000000000000000000000000000000000000000000000000000811461162a573d6000803e3d6000fd5b50602060005260043d0380600460203e602081016000f35b606061165085858589612358565b9050602081510263fa61cc126020830352600482036024820181fd5b60608060008361167b816125e7565b6060611686866128a2565b909550905061169481612904565b95979096509350505050565b6116a86117d2565b6116b06118ab565b826116ba81611bc2565b6001600160a01b038481166000818152600460209081526040808320948816808452949091529081902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016861515179055519091907f46961fdb4502b646d5095fba7600486a8ac05041d55cdf0f16ed677180b5cad89061173f908690615506565b60405180910390a350610fe36118a4565b600061175c83836129b3565b90505b92915050565b7f08c379a0000000000000000000000000000000000000000000000000000000006000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b6117e460026000541415610190610558565b6002600055565b600061181a6000357fffffffff0000000000000000000000000000000000000000000000000000000016611154565b905061058b61182982336129e1565b610191610558565b6040516001600160a01b038216907f94b979b6831a51293e2641426f97747feed46f17779fed9cd18d1ecefcfe92ef90600090a2600380546001600160a01b03909216610100027fffffffffffffffffffffff0000000000000000000000000000000000000000ff909216919091179055565b6001600055565b6118be6118b6611b5d565b610192610558565b565b600069ffffffffffffffffffff821660508460028111156118dd57fe5b901b17606085901b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000161790505b9392505050565b600080600080600080600088606001519050336001600160a01b0316816001600160a01b031614611964578761194f5761194a6117eb565b600197505b61196461195c82336129b3565b6101f7610558565b885160208a015160408b01516080909b0151919b909a9992985090965090945092505050565b61199f8361199786611bf4565b836000612a84565b50610e2b8482846000611deb565b6119c0826119ba86611bf4565b83612ada565b610e2b8482856000611d0d565b6001600160a01b03161590565b600082820161175c8482101583610558565b6119f98385836000612a84565b50610e2b828583612ada565b8015610e2b57611a206001600160a01b038516848484612b0a565b826001600160a01b0316846001600160a01b03167f540a1a3f28340caec336c81d8d7b3df139ee5cdc1839a4f283d7ebb7eaae2d5c8484604051611a659291906153a1565b60405180910390a350505050565b611a8281341015610204610558565b348190038015610566576105663382612b2b565b6001600160a01b039182166000908152600b6020908152604080832093909416825291909152205490565b8015611ae157611adc611ad2611b7a565b4210610193610558565b611af6565b611af6611aec611b9e565b42106101a9610558565b600380547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00168215151790556040517f9e3a5e37224532dea67b89face185703738a228a6e8a23dee546960180d3be6490611b52908390615506565b60405180910390a150565b6000611b67611b9e565b42118061131357505060035460ff161590565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b336001600160a01b0382161461058b57611bda6117eb565b611be481336129b3565b61058b5761058b816101f7612ba5565b6000611bff826119cd565b611c1157611c0c82610555565b61175f565b61175f610533565b600080600080611c2c856080015161289c565b90506000611c3d866080015161202a565b90506002816002811115611c4d57fe5b1415611c6457611c5d8683612bd9565b9450611c8f565b6001816002811115611c7257fe5b1415611c8257611c5d8683612c89565b611c8c8683612d1c565b94505b611ca28660000151876060015187612f5b565b809450819550505085604001516001600160a01b031686602001516001600160a01b031687608001517f2170c741c41531aec20e7c107c24eecfdd15e69c9bb0a8dd37b1840b9e0b207b8787604051611cfc9291906155da565b60405180910390a450509193909250565b82611d1757610e2b565b611d20846119cd565b15611da157611d328115610202610558565b611d4183471015610204610558565b611d49610533565b6001600160a01b031663d0e30db0846040518263ffffffff1660e01b81526004016000604051808303818588803b158015611d8357600080fd5b505af1158015611d97573d6000803e3d6000fd5b5050505050610e2b565b6000611dac85610555565b90508115611dc9576000611dc38483876001612a84565b90940393505b8315611de457611de46001600160a01b038216843087612b0a565b5050505050565b82611df557610e2b565b611dfe846119cd565b15611e8957611e108115610202610558565b611e18610533565b6001600160a01b0316632e1a7d4d846040518263ffffffff1660e01b8152600401611e439190615529565b600060405180830381600087803b158015611e5d57600080fd5b505af1158015611e71573d6000803e3d6000fd5b50610360925050506001600160a01b03831684612b2b565b6000611e9485610555565b90508115611eac57611ea7838286612ada565b611de4565b611de46001600160a01b0382168486611f54565b6105668183146067610558565b600080611ed86113e3565b6001600160a01b031663d877845c6040518163ffffffff1660e01b815260040160206040518083038186803b158015611f1057600080fd5b505afa158015611f24573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f48919061511d565b905061190b8382612f89565b610fe38363a9059cbb60e01b8484604051602401611f739291906153a1565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152612fd6565b801561056657610566611fe86113e3565b6001600160a01b0384169083611f54565b612002816125e7565b61058b61200e8261289c565b6001600160a01b0316336001600160a01b0316146101f5610558565b600061ffff605083901c1661175f600382106101f4610558565b612065816001600160a01b0316836001600160a01b0316141561020a610558565b612084816001600160a01b0316836001600160a01b0316106066610558565b600083815260096020526040902080546120c1906001600160a01b03161580156120b9575060018201546001600160a01b0316155b61020b610558565b80546001600160a01b039384167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161782556001909101805492909316911617905550565b6000828152600860205260408120905b8251811015610e2b57600061214984838151811061213257fe5b60200260200101518461307690919063ffffffff16565b90506121578161020a610558565b50600101612118565b6000828152600160205260408120905b8251811015610e2b57600061219e84838151811061218a57fe5b6020908102919091010151849060006130f1565b90506121ac8161020a610558565b50600101612170565b60008060006121c58686866131b6565b9250925092506121ef6121d78461327d565b80156121e757506121e78361327d565b61020d610558565b600095865260096020526040862080547fffffffffffffffffffffffff000000000000000000000000000000000000000090811682556001909101805490911690559490945550505050565b6000828152600860205260408120905b8251811015610e2b57600083828151811061226257fe5b602002602001015190506122ae6121e7600760008881526020019081526020016000206000846001600160a01b03166001600160a01b031681526020019081526020016000205461327d565b60008581526007602090815260408083206001600160a01b038516845290915281208190556122dd848361329f565b90506122eb81610209610558565b505060010161224b565b6000828152600160205260408120905b8251811015610e2b57600083828151811061231c57fe5b60200260200101519050600061233284836133dd565b90506123406121e78261327d565b61234a84836133ec565b505050806001019050612305565b6060835167ffffffffffffffff8111801561237257600080fd5b5060405190808252806020026020018201604052801561239c578160200160208202803683370190505b5090506123a76145d6565b6123af61455d565b60008060005b89518110156125da578981815181106123ca57fe5b602002602001015194506000895186602001511080156123ee575089518660400151105b90506123fb816064610558565b600061241d8b88602001518151811061241057fe5b6020026020010151611bf4565b905060006124348c89604001518151811061241057fe5b9050612457816001600160a01b0316836001600160a01b031614156101fd610558565b60608801516124a75761246f600085116101fe610558565b600061247c8b84846134ee565b6001600160a01b0316876001600160a01b031614905061249e816101ff610558565b50606088018590525b87516080880152868a60018111156124bb57fe5b908160018111156124c857fe5b9052506001600160a01b0380831660208901528181166040808a01919091526060808b0151908a015260808a01516101008a01528c51821660c08a01528c01511660e088015260008061251a89611c19565b9198509250905061252c8c8585613510565b975061256061253a8361352a565b8c8c602001518151811061254a57fe5b602002602001015161355e90919063ffffffff16565b8b8b602001518151811061257057fe5b6020026020010181815250506125ae6125888261352a565b8c8c604001518151811061259857fe5b602002602001015161359290919063ffffffff16565b8b8b60400151815181106125be57fe5b60200260200101818152505050505050508060010190506123b5565b5050505050949350505050565b60008181526005602052604090205461058b9060ff166101f4610558565b6000806000806000612616876135c6565b945094509450945050836001600160a01b0316866001600160a01b03161415612645578294505050505061175f565b816001600160a01b0316866001600160a01b0316141561266a57935061175f92505050565b612675610209611765565b5050505092915050565b60008281526007602090815260408083206001600160a01b0385168452909152812054816126ac8261363c565b806126ca575060008581526008602052604090206126ca908561364e565b9050806126e5576126da856125e7565b6126e5610209611765565b509392505050565b6000828152600160205260408120610a0c81846133dd565b6dffffffffffffffffffffffffffff1690565b60701c6dffffffffffffffffffffffffffff1690565b60e01c90565b6000806127408461202a565b9050600281600281111561275057fe5b141561276857612760848461366f565b91505061175f565b600181600281111561277657fe5b14156127865761276084846136c0565b61276084846136d8565b600080600061279e8661202a565b905060008760028111156127ae57fe5b14156127ca576127c0868287876136f0565b92509250506127f6565b60018760028111156127d857fe5b14156127ea576127c08682878761376b565b6127c0868287876137e7565b94509492505050565b60007f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000061286c61384a565b3060405160200161288195949392919061557d565b60405160208183030381529060405280519060200120905090565b60601c90565b60608060006128b08461202a565b905060028160028111156128c057fe5b14156128d9576128cf8461384e565b92509250506128ff565b60018160028111156128e757fe5b14156128f6576128cf84613983565b6128cf84613aaa565b915091565b60606000825167ffffffffffffffff8111801561292057600080fd5b5060405190808252806020026020018201604052801561294a578160200160208202803683370190505b5091506000905060005b825181101561155157600084828151811061296b57fe5b6020026020010151905061297e81613ba6565b84838151811061298a57fe5b6020026020010181815250506129a8836129a38361272e565b613bc1565b925050600101612954565b6001600160a01b03918216600090815260046020908152604080832093909416825291909152205460ff1690565b6003546040517f9be2a88400000000000000000000000000000000000000000000000000000000815260009161010090046001600160a01b031690639be2a88490612a3490869086903090600401615532565b60206040518083038186803b158015612a4c57600080fd5b505afa158015612a60573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061175c9190614c15565b600080612a918686611a96565b9050612aaa8380612aa25750848210155b610201610558565b612ab48185613bd8565b9150818103612ad0878783612ac88761352a565b600003613be7565b5050949350505050565b6000612ae68484611a96565b90506000612af482846119da565b9050611de4858583612b058761352a565b613be7565b610e2b846323b872dd60e01b858585604051602401611f7393929190615357565b612b3a814710156101a3610558565b6000826001600160a01b031682604051612b5390610555565b60006040518083038185875af1925050503d8060008114612b90576040519150601f19603f3d011682016040523d82523d6000602084013e612b95565b606091505b50509050610fe3816101a4610558565b6001600160a01b0382166000908152600260205260409020805460018101909155610fe3612bd38483613c42565b83610558565b600080600080612bf68660800151876020015188604001516131b6565b92509250925060008087604001516001600160a01b031688602001516001600160a01b03161015612c2b575083905082612c31565b50829050835b612c3d88888484613d68565b60408b015160208c01519199509294509092506001600160a01b03918216911610612c7157612c6c8183613e7e565b612c7b565b612c7b8282613e7e565b909255509295945050505050565b600080612c9e8460800151856020015161267f565b90506000612cb48560800151866040015161267f565b9050612cc285858484613d68565b6080880180516000908152600760208181526040808420828e01516001600160a01b03908116865290835281852098909855935183529081528282209a830151909516815298909352919096209590955550929392505050565b60808201516000908152600160209081526040822090840151829182918290612d46908390613eb9565b90506000612d61886040015184613eb990919063ffffffff16565b9050811580612d6e575080155b15612d8b57612d8088608001516125e7565b612d8b610209611765565b60001991820191016000612d9e84613ed8565b905060608167ffffffffffffffff81118015612db957600080fd5b50604051908082528060200260200182016040528015612de3578160200160208202803683370190505b50600060a08c018190529091505b82811015612e63576000612e058783613edc565b9050612e1081613ba6565b838381518110612e1c57fe5b602002602001018181525050612e398c60a001516129a38361272e565b60a08d015281861415612e4e57809850612e5a565b84821415612e5a578097505b50600101612df1565b506040517f01ec954a0000000000000000000000000000000000000000000000000000000081526001600160a01b038a16906301ec954a90612eaf908d908590899089906004016155e8565b602060405180830381600087803b158015612ec957600080fd5b505af1158015612edd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f01919061511d565b9750600080612f198c600001518d606001518c612f5b565b9092509050612f288983613ef2565b9850612f348882613f23565b9750612f4187878b613f39565b612f4c87868a613f39565b50505050505050505092915050565b60008080856001811115612f6b57fe5b1415612f7b575082905081612f81565b50819050825b935093915050565b6000828202612fad841580612fa6575083858381612fa357fe5b04145b6003610558565b80612fbc57600091505061175f565b670de0b6b3a764000060001982010460010191505061175f565b60006060836001600160a01b031683604051612ff291906152b7565b6000604051808303816000865af19150503d806000811461302f576040519150601f19603f3d011682016040523d82523d6000602084013e613034565b606091505b5091509150600082141561304c573d6000803e3d6000fd5b610e2b81516000148061306e57508180602001905181019061306e9190614c15565b6101a2610558565b6000613082838361364e565b6130e957508154600180820184556000848152602080822090930180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0386169081179091558554908252828601909352604090209190915561175f565b50600061175f565b6001600160a01b03821660009081526002840160205260408120548061319657505082546040805180820182526001600160a01b03858116808352602080840187815260008781526001808c018452878220965187547fffffffffffffffffffffffff0000000000000000000000000000000000000000169616959095178655905194840194909455948201808955908352600288019094529190209190915561190b565b60001901600090815260018086016020526040822001839055905061190b565b60008060008060006131c88787613f51565b9150915060006131d88383613f82565b60008a81526009602090815260408083208484526002019091528120805460018201549197509293509061320b8361363c565b8061321a575061321a8261363c565b8061323b575061322a8c8761366f565b801561323b575061323b8c8661366f565b9050806132565761324b8c6125e7565b613256610209611765565b6132608383613fb5565b985061326c8383613fda565b975050505050505093509350939050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6001600160a01b038116600090815260018301602052604081205480156133d357835460001980830191018082146133635760008660000182815481106132e257fe5b60009182526020909120015487546001600160a01b039091169150819088908590811061330b57fe5b600091825260208083209190910180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0394851617905592909116815260018881019092526040902090830190555b855486908061336e57fe5b60008281526020808220830160001990810180547fffffffffffffffffffffffff00000000000000000000000000000000000000001690559092019092556001600160a01b038716825260018881019091526040822091909155935061175f92505050565b600091505061175f565b600061175c8383610209613ff1565b6001600160a01b038116600090815260028301602052604081205480156133d3578354600019808301910180821461348c576000818152600180880160209081526040808420868552818520815481547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039182161782558286015491860191909155905416845260028a0190915290912090830190555b600081815260018088016020908152604080842080547fffffffffffffffffffffffff000000000000000000000000000000000000000016815583018490559389556001600160a01b038816835260028901905291812055925061175f915050565b6000808460018111156134fd57fe5b146135085781610a0c565b509092915050565b60008084600181111561351f57fe5b1461082a5782610a0c565b600061355a7f800000000000000000000000000000000000000000000000000000000000000083106101a5610558565b5090565b600082820161175c8284128015906135765750848212155b8061358b575060008412801561358b57508482125b6000610558565b600081830361175c8284128015906135aa5750848213155b806135bf57506000841280156135bf57508482135b6001610558565b6000818152600960205260408120805460018201546001600160a01b03918216928492909116908290816135fa8685613f82565b60008181526002840160205260409020805460018201549199509192506136218282613fb5565b965061362d8282613fda565b94505050505091939590929450565b60006136478261327d565b1592915050565b6001600160a01b031660009081526001919091016020526040902054151590565b600082815260096020526040812080546001600160a01b03848116911614806136a7575060018101546001600160a01b038481169116145b8015610a0c575050506001600160a01b03161515919050565b6000828152600860205260408120610a0c818461364e565b6000828152600160205260408120610a0c818461402e565b600080600285600281111561370157fe5b14156137175761371286858561404f565b613741565b600185600281111561372557fe5b14156137365761371286858561405d565b61374186858561406b565b821561375b5761375b6001600160a01b0385163385611f54565b5050600081900394909350915050565b600080600285600281111561377c57fe5b14156137925761378d868585614079565b6137bc565b60018560028111156137a057fe5b14156137b15761378d868585614087565b6137bc868585614095565b82156137d7576137d76001600160a01b038516333086612b0a565b5090946000869003945092505050565b60008060028560028111156137f857fe5b1415613810576138098685856140a3565b905061383d565b600185600281111561381e57fe5b141561382f576138098685856140b3565b61383a8685856140c3565b90505b6000915094509492505050565b4690565b606080600080600080613860876135c6565b92975090955093509150506001600160a01b038416158061388857506001600160a01b038216155b156138b157505060408051600080825260208201908152818301909252945092506128ff915050565b604080516002808252606082018352909160208301908036833701905050955083866000815181106138df57fe5b60200260200101906001600160a01b031690816001600160a01b031681525050818660018151811061390d57fe5b6001600160a01b0392909216602092830291909101820152604080516002808252606082018352909290919083019080368337019050509450828560008151811061395457fe5b602002602001018181525050808560018151811061396e57fe5b60200260200101818152505050505050915091565b6000818152600860205260409020606090819061399f81613ed8565b67ffffffffffffffff811180156139b557600080fd5b506040519080825280602002602001820160405280156139df578160200160208202803683370190505b509250825167ffffffffffffffff811180156139fa57600080fd5b50604051908082528060200260200182016040528015613a24578160200160208202803683370190505b50915060005b8351811015613aa3576000613a3f83836140d3565b905080858381518110613a4e57fe5b6001600160a01b03928316602091820292909201810191909152600088815260078252604080822093851682529290915220548451859084908110613a8f57fe5b602090810291909101015250600101613a2a565b5050915091565b60008181526001602052604090206060908190613ac681613ed8565b67ffffffffffffffff81118015613adc57600080fd5b50604051908082528060200260200182016040528015613b06578160200160208202803683370190505b509250825167ffffffffffffffff81118015613b2157600080fd5b50604051908082528060200260200182016040528015613b4b578160200160208202803683370190505b50915060005b8351811015613aa357613b648282614100565b858381518110613b7057fe5b60200260200101858481518110613b8357fe5b60209081029190910101919091526001600160a01b039091169052600101613b51565b6000613bb182612718565b613bba83612705565b0192915050565b600081831015613bd1578161175c565b5090919050565b6000818310613bd1578161175c565b6001600160a01b038085166000818152600b602090815260408083209488168084529490915290819020859055517f18e1ea4139e68413d7d08aa752e71568e36b2c5bf940893314c2c5b01eaa0c4290611a65908590615529565b600080613c4d614124565b905042811015613c6157600091505061175f565b6000613c6b614130565b905080613c7d5760009250505061175f565b600081613c88614241565b8051602091820120604051613ca4939233918a91899101615551565b6040516020818303038152906040528051906020012090506000613cc782614290565b90506000806000613cd66142ac565b925092509250600060018585858560405160008152602001604052604051613d0194939291906155a9565b6020604051602081039080840390855afa158015613d23573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811615801590613d5957508a6001600160a01b0316816001600160a01b0316145b9b9a5050505050505050505050565b600080600080613d7786613ba6565b90506000613d8486613ba6565b9050613d9b613d928861272e565b6129a38861272e565b60a08a01526040517f9d2c110c0000000000000000000000000000000000000000000000000000000081526001600160a01b03891690639d2c110c90613de9908c9086908690600401615621565b602060405180830381600087803b158015613e0357600080fd5b505af1158015613e17573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613e3b919061511d565b9250600080613e538b600001518c6060015187612f5b565b9092509050613e628983613ef2565b9650613e6e8882613f23565b9550505050509450945094915050565b600080613e96613e8d8561272e565b6129a38561272e565b9050610a0c613ea485612705565b613ead85612705565b8363ffffffff166142d3565b6001600160a01b03166000908152600291909101602052604090205490565b5490565b6000908152600191820160205260409020015490565b600080613f0883613f0286612705565b906119da565b90506000613f1585612718565b9050436112eb8383836142e1565b600080613f0883613f3386612705565b9061431a565b60009182526001928301602052604090912090910155565b600080826001600160a01b0316846001600160a01b031610613f74578284613f77565b83835b915091509250929050565b60008282604051602001613f979291906152d3565b60405160208183030381529060405280519060200120905092915050565b600061175c613fc384612705565b613fcc84612705565b613fd58661272e565b6142e1565b600061175c613fe884612718565b613fcc84612718565b6001600160a01b038216600090815260028401602052604081205461401881151584610558565b6140258560018303613edc565b95945050505050565b6001600160a01b031660009081526002919091016020526040902054151590565b610e2b83836143308461436b565b610e2b838361433084614416565b610e2b838361433084614471565b610e2b83836144c08461436b565b610e2b83836144c084614416565b610e2b83836144c084614471565b6000610a0c84846144e18561436b565b6000610a0c84846144e185614416565b6000610a0c84846144e185614471565b60008260000182815481106140e457fe5b6000918252602090912001546001600160a01b03169392505050565b600090815260019182016020526040902080549101546001600160a01b0390911691565b600061131360006144fb565b6000803560e01c8063b95cac28811461417857638bdb391381146141a0576352bbbe2981146141c85763945bcec981146141f05763fa6e671d8114614218576000925061423c565b7f3f7b71252bd19113ff48c19c6e004a9bcfcca320a0d74d58e85877cbd7dcae58925061423c565b7f8bbc57f66ea936902f50a71ce12b92c43f3c5340bb40c27c4e90ab84eeae3353925061423c565b7fe192dcbc143b1e244ad73b813fd3c097b832ad260a157340b4e5e5beda067abe925061423c565b7f9bfc43a4d98313c6766986ffd7c916c7481566d9f224c6819af0a53388aced3a925061423c565b7fa3f865aa351e51cfeb40f5178d1564bb629fe9030b83caf6361d1baaf5b90b5a92505b505090565b60606000368080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505082519293505050608010156105555760803603815290565b600061429a6127ff565b8260405160200161118992919061530d565b60008060006142bb60206144fb565b92506142c760406144fb565b915061086c60606144fb565b60e01b60709190911b010190565b600083830161430f85821080159061430757506e01000000000000000000000000000082105b61020e610558565b6140258585856142d3565b600061432a838311156001610558565b50900390565b60008061434083613f3386612705565b9050600061435184613f0287612718565b9050600061435e8661272e565b90506112eb8383836142e1565b600080600080600061437c896135c6565b9450509350935093506000836001600160a01b0316896001600160a01b031614156143c75760006143b184898b63ffffffff16565b90506143bd8185614523565b90935090506143e9565b60006143d783898b63ffffffff16565b90506143e38184614523565b90925090505b6143f38383613e7e565b85556143ff838361453f565b600190950194909455509192505050949350505050565b600080614423868661267f565b9050600061443582858763ffffffff16565b60008881526007602090815260408083206001600160a01b038b168452909152902081905590506144668183614523565b979650505050505050565b60008481526001602052604081208161448a82876133dd565b9050600061449c82868863ffffffff16565b90506144a98388836130f1565b506144b48183614523565b98975050505050505050565b6000806144d083613f0286612705565b9050600061435184613f3387612718565b6000806144ed84612705565b9050436140258285836142e1565b36017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80013590565b600061452e82612718565b61453784612718565b039392505050565b600061175c61454d84612718565b61455684612718565b60006142d3565b60408051610120810190915280600081526000602082018190526040820181905260608083018290526080830182905260a0830182905260c0830182905260e08301919091526101009091015290565b604080516080810190915280600081526000602082018190526040820181905260609091015290565b6040518060a0016040528060008019168152602001600081526020016000815260200160008152602001606081525090565b803561175f816156e7565b600082601f830112614623578081fd5b813561463661463182615691565b61566a565b81815291506020808301908481018184028601820187101561465757600080fd5b60005b8481101561467f57813561466d816156e7565b8452928201929082019060010161465a565b505050505092915050565b600082601f83011261469a578081fd5b81356146a861463182615691565b818152915060208083019084810160005b8481101561467f578135870160a080601f19838c030112156146da57600080fd5b6146e38161566a565b85830135815260408084013587830152606080850135828401526080915081850135818401525082840135925067ffffffffffffffff83111561472557600080fd5b6147338c88858701016147b4565b908201528652505092820192908201906001016146b9565b600082601f83011261475b578081fd5b813561476961463182615691565b81815291506020808301908481018184028601820187101561478a57600080fd5b60005b8481101561467f5781358452928201929082019060010161478d565b803561175f816156fc565b600082601f8301126147c4578081fd5b813567ffffffffffffffff8111156147da578182fd5b6147ed6020601f19601f8401160161566a565b915080825283602082850101111561480457600080fd5b8060208401602084013760009082016020015292915050565b803561175f8161570a565b80356002811061175f57600080fd5b80356004811061175f57600080fd5b600060808284031215614857578081fd5b614861608061566a565b9050813567ffffffffffffffff8082111561487b57600080fd5b61488785838601614613565b8352602084013591508082111561489d57600080fd5b6148a98583860161474b565b602084015260408401359150808211156148c257600080fd5b506148cf848285016147b4565b6040830152506148e283606084016147a9565b606082015292915050565b6000608082840312156148fe578081fd5b614908608061566a565b90508135614915816156e7565b81526020820135614925816156fc565b60208201526040820135614938816156e7565b604082015260608201356148e2816156fc565b60006020828403121561495c578081fd5b813561175c816156e7565b60008060408385031215614979578081fd5b8235614984816156e7565b91506020830135614994816156e7565b809150509250929050565b6000806000606084860312156149b3578081fd5b83356149be816156e7565b925060208401356149ce816156e7565b915060408401356149de816156fc565b809150509250925092565b600080604083850312156149fb578182fd5b8235614a06816156e7565b9150602083013567ffffffffffffffff811115614a21578182fd5b614a2d85828601614613565b9150509250929050565b60006020808385031215614a49578182fd5b823567ffffffffffffffff811115614a5f578283fd5b8301601f81018513614a6f578283fd5b8035614a7d61463182615691565b818152838101908385016080808502860187018a1015614a9b578788fd5b8795505b84861015614b045780828b031215614ab5578788fd5b614abe8161566a565b614ac88b8461481d565b815287830135888201526040614ae08c828601614608565b90820152606083810135908201528452600195909501949286019290810190614a9f565b509098975050505050505050565b60006020808385031215614b24578182fd5b823567ffffffffffffffff811115614b3a578283fd5b8301601f81018513614b4a578283fd5b8035614b5861463182615691565b8181528381019083850160a0808502860187018a1015614b76578788fd5b8795505b84861015614b045780828b031215614b90578788fd5b614b998161566a565b614ba38b84614837565b8152614bb18b898501614608565b81890152604083810135908201526060614bcd8c828601614608565b908201526080614bdf8c858301614608565b908201528452600195909501949286019290810190614b7a565b600060208284031215614c0a578081fd5b813561175c816156fc565b600060208284031215614c26578081fd5b815161175c816156fc565b600060208284031215614c42578081fd5b5035919050565b60008060008060808587031215614c5e578182fd5b843593506020850135614c70816156e7565b92506040850135614c80816156e7565b9150606085013567ffffffffffffffff811115614c9b578182fd5b614ca787828801614846565b91505092959194509250565b60008060408385031215614cc5578182fd5b82359150602083013567ffffffffffffffff811115614a21578182fd5b600080600060608486031215614cf6578081fd5b8335925060208085013567ffffffffffffffff80821115614d15578384fd5b614d2188838901614613565b94506040870135915080821115614d36578384fd5b508501601f81018713614d47578283fd5b8035614d5561463182615691565b81815283810190838501858402850186018b1015614d71578687fd5b8694505b83851015614d9c578035614d88816156e7565b835260019490940193918501918501614d75565b5080955050505050509250925092565b60008060408385031215614dbe578182fd5b823591506020830135614994816156e7565b600060208284031215614de1578081fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461175c578182fd5b60008060008060808587031215614e25578182fd5b8435614e30816156e7565b9350602085013567ffffffffffffffff80821115614e4c578384fd5b614e5888838901614613565b94506040870135915080821115614e6d578384fd5b614e798883890161474b565b93506060870135915080821115614e8e578283fd5b50614ca7878288016147b4565b600060208284031215614eac578081fd5b813561175c8161570a565b60008060008060e08587031215614ecc578182fd5b614ed68686614828565b9350602085013567ffffffffffffffff80821115614ef2578384fd5b614efe8883890161468a565b94506040870135915080821115614f13578384fd5b50614f2087828801614613565b925050614f3086606087016148ed565b905092959194509250565b6000806000806000806101208789031215614f54578384fd5b614f5e8888614828565b955060208088013567ffffffffffffffff80821115614f7b578687fd5b614f878b838c0161468a565b975060408a0135915080821115614f9c578687fd5b614fa88b838c01614613565b9650614fb78b60608c016148ed565b955060e08a0135915080821115614fcc578485fd5b508801601f81018a13614fdd578384fd5b8035614feb61463182615691565b81815283810190838501858402850186018e1015615007578788fd5b8794505b8385101561502957803583526001949094019391850191850161500b565b50809650505050505061010087013590509295509295509295565b60008060008060e08587031215615059578182fd5b843567ffffffffffffffff80821115615070578384fd5b9086019060c08289031215615083578384fd5b61508d60c061566a565b8235815261509e8960208501614828565b602082015260408301356150b1816156e7565b60408201526150c38960608501614608565b60608201526080830135608082015260a0830135828111156150e3578586fd5b6150ef8a8286016147b4565b60a08301525080965050505061510886602087016148ed565b939693955050505060a08201359160c0013590565b60006020828403121561512e578081fd5b5051919050565b6001600160a01b03169052565b6000815180845260208085019450808401835b8381101561517a5781516001600160a01b031687529582019590820190600101615155565b509495945050505050565b6000815180845260208085019450808401835b8381101561517a57815187529582019590820190600101615198565b600081518084526151cc8160208601602086016156b1565b601f01601f19169290920160200192915050565b60006101208251600281106151f157fe5b8085525060208301516152076020860182615135565b50604083015161521a6040860182615135565b50606083015160608501526080830151608085015260a083015160a085015260c083015161524b60c0860182615135565b5060e083015161525e60e0860182615135565b506101008084015182828701526112eb838701826151b4565b9182527fffffffff0000000000000000000000000000000000000000000000000000000016602082015260240190565b6000828483379101908152919050565b600082516152c98184602087016156b1565b9190910192915050565b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606093841b811682529190921b16601482015260280190565b7f190100000000000000000000000000000000000000000000000000000000000081526002810192909252602282015260420190565b6001600160a01b0391909116815260200190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b038316815260408101615394836156dd565b8260208301529392505050565b6001600160a01b03929092168252602082015260400190565b60006020825261175c6020830184615142565b6000604082526153e06040830185615142565b828103602084810191909152845180835285820192820190845b8181101561541f5784516001600160a01b0316835293830193918301916001016153fa565b5090979650505050505050565b60006080825261543f6080830187615142565b82810360208401526154518187615185565b905082810360408401526154658186615185565b9050828103606084015261446681856151b4565b60006060825261548c6060830186615142565b828103602084015261549e8186615185565b915050826040830152949350505050565b6020808252825182820181905260009190848201906040850190845b818110156154e7578351835292840192918401916001016154cb565b50909695505050505050565b60006020825261175c6020830184615185565b901515815260200190565b92151583526020830191909152604082015260600190565b90815260200190565b9283526001600160a01b03918216602084015216604082015260600190565b94855260208501939093526001600160a01b039190911660408401526060830152608082015260a00190565b9485526020850193909352604084019190915260608301526001600160a01b0316608082015260a00190565b93845260ff9290921660208401526040830152606082015260800190565b602081016155d4836156dd565b91905290565b918252602082015260400190565b6000608082526155fb60808301876151e0565b828103602084015261560d8187615185565b604084019590955250506060015292915050565b60006060825261563460608301866151e0565b60208301949094525060400152919050565b938452602084019290925260408301526001600160a01b0316606082015260800190565b60405181810167ffffffffffffffff8111828210171561568957600080fd5b604052919050565b600067ffffffffffffffff8211156156a7578081fd5b5060209081020190565b60005b838110156156cc5781810151838201526020016156b4565b83811115610e2b5750506000910152565b6003811061058b57fe5b6001600160a01b038116811461058b57600080fd5b801515811461058b57600080fd5b6003811061058b57600080fdfea2646970667358221220e5cd05e46109bcf6b7b178441016be9f9277e1587a5d476b885b2564a28d497264736f6c6343000701003360c060405234801561001057600080fd5b50604051610c79380380610c7983398101604081905261002f9161004d565b30608052600160005560601b6001600160601b03191660a05261007b565b60006020828403121561005e578081fd5b81516001600160a01b0381168114610074578182fd5b9392505050565b60805160a05160601c610bd36100a66000398061042d52806105815250806102b45250610bd36000f3fe608060405234801561001057600080fd5b50600436106100a35760003560e01c8063851c1bb311610076578063d877845c1161005b578063d877845c14610129578063e42abf3514610131578063fbfa77cf14610151576100a3565b8063851c1bb314610101578063aaabadc514610114576100a3565b806338e9922e146100a857806355c67628146100bd5780636b6b9f69146100db5780636daefab6146100ee575b600080fd5b6100bb6100b63660046109fb565b610159565b005b6100c56101b8565b6040516100d29190610b1f565b60405180910390f35b6100bb6100e93660046109fb565b6101be565b6100bb6100fc366004610830565b610211565b6100c561010f366004610983565b6102b0565b61011c610302565b6040516100d29190610a94565b6100c5610311565b61014461013f3660046108b1565b610317565b6040516100d29190610adb565b61011c61042b565b61016161044f565b6101786706f05b59d3b20000821115610258610498565b60018190556040517fa9ba3ffe0b6c366b81232caab38605a0699ad5398d6cce76f91ee809e322dafc906101ad908390610b1f565b60405180910390a150565b60015490565b6101c661044f565b6101dc662386f26fc10000821115610259610498565b60028190556040517f5a0b7386237e7f07fa741efc64e59c9387d2cccafec760efed4d53387f20e19a906101ad908390610b1f565b6102196104aa565b61022161044f565b61022b84836104c3565b60005b848110156102a057600086868381811061024457fe5b905060200201602081019061025991906109df565b9050600085858481811061026957fe5b60200291909101359150610296905073ffffffffffffffffffffffffffffffffffffffff831685836104d0565b505060010161022e565b506102a9610576565b5050505050565b60007f0000000000000000000000000000000000000000000000000000000000000000826040516020016102e5929190610a2b565b604051602081830303815290604052805190602001209050919050565b600061030c61057d565b905090565b60025490565b6060815167ffffffffffffffff8111801561033157600080fd5b5060405190808252806020026020018201604052801561035b578160200160208202803683370190505b50905060005b82518110156104255782818151811061037657fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016103b69190610a94565b60206040518083038186803b1580156103ce57600080fd5b505afa1580156103e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104069190610a13565b82828151811061041257fe5b6020908102919091010152600101610361565b50919050565b7f000000000000000000000000000000000000000000000000000000000000000081565b600061047e6000357fffffffff00000000000000000000000000000000000000000000000000000000166102b0565b905061049561048d823361061d565b610191610498565b50565b816104a6576104a6816106bc565b5050565b6104bc60026000541415610190610498565b6002600055565b6104a68183146067610498565b6105718363a9059cbb60e01b84846040516024016104ef929190610ab5565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152610729565b505050565b6001600055565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663aaabadc56040518163ffffffff1660e01b815260040160206040518083038186803b1580156105e557600080fd5b505afa1580156105f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030c91906109c3565b600061062761057d565b73ffffffffffffffffffffffffffffffffffffffff16639be2a8848484306040518463ffffffff1660e01b815260040161066393929190610b28565b60206040518083038186803b15801561067b57600080fd5b505afa15801561068f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106b3919061095c565b90505b92915050565b7f08c379a0000000000000000000000000000000000000000000000000000000006000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b600060608373ffffffffffffffffffffffffffffffffffffffff16836040516107529190610a5b565b6000604051808303816000865af19150503d806000811461078f576040519150601f19603f3d011682016040523d82523d6000602084013e610794565b606091505b509150915060008214156107ac573d6000803e3d6000fd5b6107d68151600014806107ce5750818060200190518101906107ce919061095c565b6101a2610498565b50505050565b60008083601f8401126107ed578182fd5b50813567ffffffffffffffff811115610804578182fd5b602083019150836020808302850101111561081e57600080fd5b9250929050565b80356106b681610b7b565b600080600080600060608688031215610847578081fd5b853567ffffffffffffffff8082111561085e578283fd5b61086a89838a016107dc565b90975095506020880135915080821115610882578283fd5b5061088f888289016107dc565b90945092505060408601356108a381610b7b565b809150509295509295909350565b600060208083850312156108c3578182fd5b823567ffffffffffffffff808211156108da578384fd5b818501915085601f8301126108ed578384fd5b8135818111156108fb578485fd5b838102915061090b848301610b54565b8181528481019084860184860187018a1015610925578788fd5b8795505b8386101561094f5761093b8a82610825565b835260019590950194918601918601610929565b5098975050505050505050565b60006020828403121561096d578081fd5b8151801515811461097c578182fd5b9392505050565b600060208284031215610994578081fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461097c578182fd5b6000602082840312156109d4578081fd5b815161097c81610b7b565b6000602082840312156109f0578081fd5b813561097c81610b7b565b600060208284031215610a0c578081fd5b5035919050565b600060208284031215610a24578081fd5b5051919050565b9182527fffffffff0000000000000000000000000000000000000000000000000000000016602082015260240190565b60008251815b81811015610a7b5760208186018101518583015201610a61565b81811115610a895782828501525b509190910192915050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff929092168252602082015260400190565b6020808252825182820181905260009190848201906040850190845b81811015610b1357835183529284019291840191600101610af7565b50909695505050505050565b90815260200190565b92835273ffffffffffffffffffffffffffffffffffffffff918216602084015216604082015260600190565b60405181810167ffffffffffffffff81118282101715610b7357600080fd5b604052919050565b73ffffffffffffffffffffffffffffffffffffffff8116811461049557600080fdfea2646970667358221220e158ede1b623534aedbbb639420e29bd068d08f0ab83e6e7d618bab5d9c6c2c964736f6c63430007010033",
  "deployedBytecode": "0x6080604052600436106101a55760003560e01c8063945bcec9116100e1578063e6c460921161008a578063f84d066e11610064578063f84d066e14610497578063f94d4668146104b7578063fa6e671d146104e6578063fec90d7214610506576101d3565b8063e6c4609214610434578063ed24911d14610454578063f6c0092714610469576101d3565b8063b05f8e48116100bb578063b05f8e48146103dc578063b95cac281461040c578063d2946c2b1461041f576101d3565b8063945bcec914610385578063aaabadc5146103a5578063ad5c4648146103c7576101d3565b806352bbbe291161014e5780637d3aeb96116101285780637d3aeb9614610305578063851c1bb3146103255780638bdb39131461034557806390193b7c14610365576101d3565b806352bbbe29146102b25780635c38449e146102c557806366a9c7d2146102e5576101d3565b80630f5a6efa1161017f5780630f5a6efa1461024157806316c38b3c1461026e5780631c0de0511461028e576101d3565b8063058a628f146101d857806309b2760f146101f85780630e8e3e841461022e576101d3565b366101d3576101d16101b5610533565b6001600160a01b0316336001600160a01b031614610206610558565b005b600080fd5b3480156101e457600080fd5b506101d16101f336600461494b565b61056a565b34801561020457600080fd5b50610218610213366004614e9b565b61058e565b6040516102259190615529565b60405180910390f35b6101d161023c366004614b12565b61065f565b34801561024d57600080fd5b5061026161025c3660046149e9565b61079b565b60405161022591906154f3565b34801561027a57600080fd5b506101d1610289366004614bf9565b610831565b34801561029a57600080fd5b506102a361084a565b60405161022593929190615511565b6102186102c0366004615044565b610873565b3480156102d157600080fd5b506101d16102e0366004614e10565b610a14565b3480156102f157600080fd5b506101d1610300366004614ce2565b610e31565b34801561031157600080fd5b506101d1610320366004614cb3565b610fe8565b34801561033157600080fd5b50610218610340366004614dd0565b611154565b34801561035157600080fd5b506101d1610360366004614c49565b610e2b565b34801561037157600080fd5b5061021861038036600461494b565b6111a6565b610398610393366004614f3b565b6111c1565b60405161022591906154af565b3480156103b157600080fd5b506103ba6112f5565b6040516102259190615343565b3480156103d357600080fd5b506103ba611309565b3480156103e857600080fd5b506103fc6103f7366004614dac565b611318565b6040516102259493929190615646565b6101d161041a366004614c49565b6113db565b34801561042b57600080fd5b506103ba6113e3565b34801561044057600080fd5b506101d161044f366004614a37565b611407565b34801561046057600080fd5b50610218611523565b34801561047557600080fd5b50610489610484366004614c31565b61152d565b60405161022592919061537b565b3480156104a357600080fd5b506103986104b2366004614eb7565b611557565b3480156104c357600080fd5b506104d76104d2366004614c31565b61166c565b60405161022593929190615479565b3480156104f257600080fd5b506101d161050136600461499f565b6116a0565b34801561051257600080fd5b50610526610521366004614967565b611750565b6040516102259190615506565b7f00000000000000000000000000000000000000000000000000000000000000005b90565b816105665761056681611765565b5050565b6105726117d2565b61057a6117eb565b61058381611831565b61058b6118a4565b50565b60006105986117d2565b6105a06118ab565b60006105af33846006546118c0565b6000818152600560205260409020549091506105d19060ff16156101f4610558565b6000818152600560205260409081902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600190811790915560068054909101905551339082907f3c13bc30b8e878c53fd2a36b679409c073afd75950be43d8858768e956fbc20e906106489087906155c7565b60405180910390a3905061065a6118a4565b919050565b6106676117d2565b6000806000805b845181101561078657600080600080600061069c8a878151811061068e57fe5b602002602001015189611912565b9c5093985091965094509250905060018560038111156106b857fe5b14156106cf576106ca8483838661198a565b610775565b866106e1576106dc6118ab565b600196505b60008560038111156106ef57fe5b141561072057610701848383866119ad565b61070a846119cd565b156106ca5761071989846119da565b9850610775565b61073561072c856119cd565b15610207610558565b600061074085610555565b9050600286600381111561075057fe5b141561076757610762818484876119ec565b610773565b61077381848487611a05565b505b50506001909301925061066e915050565b5061079083611a73565b50505061058b6118a4565b6060815167ffffffffffffffff811180156107b557600080fd5b506040519080825280602002602001820160405280156107df578160200160208202803683370190505b50905060005b825181101561082a5761080b848483815181106107fe57fe5b6020026020010151611a96565b82828151811061081757fe5b60209081029190910101526001016107e5565b5092915050565b6108396117d2565b6108416117eb565b61058381611ac1565b6000806000610857611b5d565b159250610862611b7a565b915061086c611b9e565b9050909192565b600061087d6117d2565b6108856118ab565b835161089081611bc2565b61089f834211156101fc610558565b6108b260008760800151116101fe610558565b60006108c18760400151611bf4565b905060006108d28860600151611bf4565b90506108f5816001600160a01b0316836001600160a01b031614156101fd610558565b6108fd61455d565b8851608082015260208901518190600181111561091657fe5b9081600181111561092357fe5b9052506001600160a01b03808416602083015282811660408084019190915260808b0151606084015260a08b01516101008401528951821660c08401528901511660e082015260008061097583611c19565b919850925090506109ac60008c60200151600181111561099157fe5b1461099f57898311156109a4565b898210155b6101fb610558565b6109c48b60400151838c600001518d60200151611d0d565b6109dc8b60600151828c604001518d60600151611deb565b6109fe6109ec8c604001516119cd565b6109f75760006109f9565b825b611a73565b505050505050610a0c6118a4565b949350505050565b610a1c6117d2565b610a246118ab565b610a3083518351611ec0565b6060835167ffffffffffffffff81118015610a4a57600080fd5b50604051908082528060200260200182016040528015610a74578160200160208202803683370190505b5090506060845167ffffffffffffffff81118015610a9157600080fd5b50604051908082528060200260200182016040528015610abb578160200160208202803683370190505b5090506000805b8651811015610c34576000878281518110610ad957fe5b602002602001015190506000878381518110610af157fe5b60200260200101519050610b3c846001600160a01b0316836001600160a01b03161160006001600160a01b0316846001600160a01b031614610b34576066610b37565b60685b610558565b819350816001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610b6b9190615343565b60206040518083038186803b158015610b8357600080fd5b505afa158015610b97573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bbb919061511d565b858481518110610bc757fe5b602002602001018181525050610bdc81611ecd565b868481518110610be857fe5b602002602001018181525050610c1681868581518110610c0457fe5b60200260200101511015610210610558565b610c2a6001600160a01b0383168b83611f54565b5050600101610ac2565b506040517ff04f27070000000000000000000000000000000000000000000000000000000081526001600160a01b0388169063f04f270790610c80908990899088908a9060040161542c565b600060405180830381600087803b158015610c9a57600080fd5b505af1158015610cae573d6000803e3d6000fd5b5050505060005b8651811015610e1f576000878281518110610ccc57fe5b602002602001015190506000848381518110610ce457fe5b602002602001015190506000826001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610d1c9190615343565b60206040518083038186803b158015610d3457600080fd5b505afa158015610d48573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d6c919061511d565b9050610d7d82821015610203610558565b60008282039050610da6888681518110610d9357fe5b602002602001015182101561025a610558565b610db08482611fd7565b836001600160a01b03168c6001600160a01b03167f0d7d75e01ab95780d3cd1c8ec0dd6c2ce19e3a20427eec8bf53283b6fb8e95f08c8881518110610df157fe5b602002602001015184604051610e089291906155da565b60405180910390a350505050806001019050610cb5565b50505050610e2b6118a4565b50505050565b610e396117d2565b610e416118ab565b82610e4b81611ff9565b610e5783518351611ec0565b60005b8351811015610f0d576000848281518110610e7157fe5b60200260200101519050610e9d60006001600160a01b0316826001600160a01b03161415610135610558565b838281518110610ea957fe5b6020908102919091018101516000888152600a835260408082206001600160a01b0395861683529093529190912080547fffffffffffffffffffffffff00000000000000000000000000000000000000001692909116919091179055600101610e5a565b506000610f198561202a565b90506002816002811115610f2957fe5b1415610f7757610f3f845160021461020c610558565b610f728585600081518110610f5057fe5b602002602001015186600181518110610f6557fe5b6020026020010151612044565b610f9f565b6001816002811115610f8557fe5b1415610f9557610f728585612108565b610f9f8585612160565b847ff5847d3f2197b16cdcd2098ec95d0905cd1abdaf415f07bb7cef2bba8ac5dec48585604051610fd19291906153cd565b60405180910390a25050610fe36118a4565b505050565b610ff06117d2565b610ff86118ab565b8161100281611ff9565b600061100d8461202a565b9050600281600281111561101d57fe5b141561106b57611033835160021461020c610558565b611066848460008151811061104457fe5b60200260200101518560018151811061105957fe5b60200260200101516121b5565b611093565b600181600281111561107957fe5b141561108957611066848461223b565b61109384846122f5565b60005b835181101561111157600a600086815260200190815260200160002060008583815181106110c057fe5b6020908102919091018101516001600160a01b0316825281019190915260400160002080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055600101611096565b50837f7dcdc6d02ef40c7c1a7046a011b058bd7f988fa14e20a66344f9d4e60657d6108460405161114291906153ba565b60405180910390a250506105666118a4565b60007f000000000000000000000000000000000000000000000000000000000000000082604051602001611189929190615277565b604051602081830303815290604052805190602001209050919050565b6001600160a01b031660009081526002602052604090205490565b60606111cb6117d2565b6111d36118ab565b83516111de81611bc2565b6111ed834211156101fc610558565b6111f986518551611ec0565b6112058787878b612358565b91506000805b87518110156112d757600088828151811061122257fe5b60200260200101519050600085838151811061123a57fe5b6020026020010151905061126688848151811061125357fe5b60200260200101518213156101fb610558565b60008113156112a657885160208a015182916112859185918491611d0d565b61128e836119cd565b156112a05761129d85826119da565b94505b506112cd565b60008112156112cd5760008160000390506112cb83828c604001518d60600151611deb565b505b505060010161120b565b506112e181611a73565b50506112eb6118a4565b9695505050505050565b60035461010090046001600160a01b031690565b6000611313610533565b905090565b60008060008085611328816125e7565b6000806113348961202a565b9050600281600281111561134457fe5b141561135b576113548989612605565b9150611386565b600181600281111561136957fe5b141561137957611354898961267f565b61138389896126ed565b91505b61138f82612705565b965061139a82612718565b95506113a58261272e565b6000998a52600a60209081526040808c206001600160a01b039b8c168d5290915290992054969995989796909616955050505050565b610e2b6118ab565b7f000000000000000000000000000000000000000000000000000000000000000090565b61140f6117d2565b6114176118ab565b61141f6145ad565b60005b82518110156115195782818151811061143757fe5b60200260200101519150600082602001519050611453816125e7565b604083015161146d6114658383612734565b610209610558565b6000828152600a602090815260408083206001600160a01b0385811685529252909120546114a0911633146101f6610558565b835160608501516000806114b684878786612790565b91509150846001600160a01b0316336001600160a01b0316877f6edcaf6241105b4c94c2efdbf3a6b12458eb3d07be3a0e81d24b13c44045fe7a85856040516115009291906155da565b60405180910390a4505050505050806001019050611422565b505061058b6118a4565b60006113136127ff565b6000808261153a816125e7565b6115438461289c565b61154c8561202a565b925092505b50915091565b6060333014611642576000306001600160a01b031660003660405161157d9291906152a7565b6000604051808303816000865af19150503d80600081146115ba576040519150601f19603f3d011682016040523d82523d6000602084013e6115bf565b606091505b5050905080600081146115ce57fe5b60046000803e6000517fffffffff00000000000000000000000000000000000000000000000000000000167ffa61cc1200000000000000000000000000000000000000000000000000000000811461162a573d6000803e3d6000fd5b50602060005260043d0380600460203e602081016000f35b606061165085858589612358565b9050602081510263fa61cc126020830352600482036024820181fd5b60608060008361167b816125e7565b6060611686866128a2565b909550905061169481612904565b95979096509350505050565b6116a86117d2565b6116b06118ab565b826116ba81611bc2565b6001600160a01b038481166000818152600460209081526040808320948816808452949091529081902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016861515179055519091907f46961fdb4502b646d5095fba7600486a8ac05041d55cdf0f16ed677180b5cad89061173f908690615506565b60405180910390a350610fe36118a4565b600061175c83836129b3565b90505b92915050565b7f08c379a0000000000000000000000000000000000000000000000000000000006000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b6117e460026000541415610190610558565b6002600055565b600061181a6000357fffffffff0000000000000000000000000000000000000000000000000000000016611154565b905061058b61182982336129e1565b610191610558565b6040516001600160a01b038216907f94b979b6831a51293e2641426f97747feed46f17779fed9cd18d1ecefcfe92ef90600090a2600380546001600160a01b03909216610100027fffffffffffffffffffffff0000000000000000000000000000000000000000ff909216919091179055565b6001600055565b6118be6118b6611b5d565b610192610558565b565b600069ffffffffffffffffffff821660508460028111156118dd57fe5b901b17606085901b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000161790505b9392505050565b600080600080600080600088606001519050336001600160a01b0316816001600160a01b031614611964578761194f5761194a6117eb565b600197505b61196461195c82336129b3565b6101f7610558565b885160208a015160408b01516080909b0151919b909a9992985090965090945092505050565b61199f8361199786611bf4565b836000612a84565b50610e2b8482846000611deb565b6119c0826119ba86611bf4565b83612ada565b610e2b8482856000611d0d565b6001600160a01b03161590565b600082820161175c8482101583610558565b6119f98385836000612a84565b50610e2b828583612ada565b8015610e2b57611a206001600160a01b038516848484612b0a565b826001600160a01b0316846001600160a01b03167f540a1a3f28340caec336c81d8d7b3df139ee5cdc1839a4f283d7ebb7eaae2d5c8484604051611a659291906153a1565b60405180910390a350505050565b611a8281341015610204610558565b348190038015610566576105663382612b2b565b6001600160a01b039182166000908152600b6020908152604080832093909416825291909152205490565b8015611ae157611adc611ad2611b7a565b4210610193610558565b611af6565b611af6611aec611b9e565b42106101a9610558565b600380547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00168215151790556040517f9e3a5e37224532dea67b89face185703738a228a6e8a23dee546960180d3be6490611b52908390615506565b60405180910390a150565b6000611b67611b9e565b42118061131357505060035460ff161590565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b336001600160a01b0382161461058b57611bda6117eb565b611be481336129b3565b61058b5761058b816101f7612ba5565b6000611bff826119cd565b611c1157611c0c82610555565b61175f565b61175f610533565b600080600080611c2c856080015161289c565b90506000611c3d866080015161202a565b90506002816002811115611c4d57fe5b1415611c6457611c5d8683612bd9565b9450611c8f565b6001816002811115611c7257fe5b1415611c8257611c5d8683612c89565b611c8c8683612d1c565b94505b611ca28660000151876060015187612f5b565b809450819550505085604001516001600160a01b031686602001516001600160a01b031687608001517f2170c741c41531aec20e7c107c24eecfdd15e69c9bb0a8dd37b1840b9e0b207b8787604051611cfc9291906155da565b60405180910390a450509193909250565b82611d1757610e2b565b611d20846119cd565b15611da157611d328115610202610558565b611d4183471015610204610558565b611d49610533565b6001600160a01b031663d0e30db0846040518263ffffffff1660e01b81526004016000604051808303818588803b158015611d8357600080fd5b505af1158015611d97573d6000803e3d6000fd5b5050505050610e2b565b6000611dac85610555565b90508115611dc9576000611dc38483876001612a84565b90940393505b8315611de457611de46001600160a01b038216843087612b0a565b5050505050565b82611df557610e2b565b611dfe846119cd565b15611e8957611e108115610202610558565b611e18610533565b6001600160a01b0316632e1a7d4d846040518263ffffffff1660e01b8152600401611e439190615529565b600060405180830381600087803b158015611e5d57600080fd5b505af1158015611e71573d6000803e3d6000fd5b50610360925050506001600160a01b03831684612b2b565b6000611e9485610555565b90508115611eac57611ea7838286612ada565b611de4565b611de46001600160a01b0382168486611f54565b6105668183146067610558565b600080611ed86113e3565b6001600160a01b031663d877845c6040518163ffffffff1660e01b815260040160206040518083038186803b158015611f1057600080fd5b505afa158015611f24573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f48919061511d565b905061190b8382612f89565b610fe38363a9059cbb60e01b8484604051602401611f739291906153a1565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152612fd6565b801561056657610566611fe86113e3565b6001600160a01b0384169083611f54565b612002816125e7565b61058b61200e8261289c565b6001600160a01b0316336001600160a01b0316146101f5610558565b600061ffff605083901c1661175f600382106101f4610558565b612065816001600160a01b0316836001600160a01b0316141561020a610558565b612084816001600160a01b0316836001600160a01b0316106066610558565b600083815260096020526040902080546120c1906001600160a01b03161580156120b9575060018201546001600160a01b0316155b61020b610558565b80546001600160a01b039384167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161782556001909101805492909316911617905550565b6000828152600860205260408120905b8251811015610e2b57600061214984838151811061213257fe5b60200260200101518461307690919063ffffffff16565b90506121578161020a610558565b50600101612118565b6000828152600160205260408120905b8251811015610e2b57600061219e84838151811061218a57fe5b6020908102919091010151849060006130f1565b90506121ac8161020a610558565b50600101612170565b60008060006121c58686866131b6565b9250925092506121ef6121d78461327d565b80156121e757506121e78361327d565b61020d610558565b600095865260096020526040862080547fffffffffffffffffffffffff000000000000000000000000000000000000000090811682556001909101805490911690559490945550505050565b6000828152600860205260408120905b8251811015610e2b57600083828151811061226257fe5b602002602001015190506122ae6121e7600760008881526020019081526020016000206000846001600160a01b03166001600160a01b031681526020019081526020016000205461327d565b60008581526007602090815260408083206001600160a01b038516845290915281208190556122dd848361329f565b90506122eb81610209610558565b505060010161224b565b6000828152600160205260408120905b8251811015610e2b57600083828151811061231c57fe5b60200260200101519050600061233284836133dd565b90506123406121e78261327d565b61234a84836133ec565b505050806001019050612305565b6060835167ffffffffffffffff8111801561237257600080fd5b5060405190808252806020026020018201604052801561239c578160200160208202803683370190505b5090506123a76145d6565b6123af61455d565b60008060005b89518110156125da578981815181106123ca57fe5b602002602001015194506000895186602001511080156123ee575089518660400151105b90506123fb816064610558565b600061241d8b88602001518151811061241057fe5b6020026020010151611bf4565b905060006124348c89604001518151811061241057fe5b9050612457816001600160a01b0316836001600160a01b031614156101fd610558565b60608801516124a75761246f600085116101fe610558565b600061247c8b84846134ee565b6001600160a01b0316876001600160a01b031614905061249e816101ff610558565b50606088018590525b87516080880152868a60018111156124bb57fe5b908160018111156124c857fe5b9052506001600160a01b0380831660208901528181166040808a01919091526060808b0151908a015260808a01516101008a01528c51821660c08a01528c01511660e088015260008061251a89611c19565b9198509250905061252c8c8585613510565b975061256061253a8361352a565b8c8c602001518151811061254a57fe5b602002602001015161355e90919063ffffffff16565b8b8b602001518151811061257057fe5b6020026020010181815250506125ae6125888261352a565b8c8c604001518151811061259857fe5b602002602001015161359290919063ffffffff16565b8b8b60400151815181106125be57fe5b60200260200101818152505050505050508060010190506123b5565b5050505050949350505050565b60008181526005602052604090205461058b9060ff166101f4610558565b6000806000806000612616876135c6565b945094509450945050836001600160a01b0316866001600160a01b03161415612645578294505050505061175f565b816001600160a01b0316866001600160a01b0316141561266a57935061175f92505050565b612675610209611765565b5050505092915050565b60008281526007602090815260408083206001600160a01b0385168452909152812054816126ac8261363c565b806126ca575060008581526008602052604090206126ca908561364e565b9050806126e5576126da856125e7565b6126e5610209611765565b509392505050565b6000828152600160205260408120610a0c81846133dd565b6dffffffffffffffffffffffffffff1690565b60701c6dffffffffffffffffffffffffffff1690565b60e01c90565b6000806127408461202a565b9050600281600281111561275057fe5b141561276857612760848461366f565b91505061175f565b600181600281111561277657fe5b14156127865761276084846136c0565b61276084846136d8565b600080600061279e8661202a565b905060008760028111156127ae57fe5b14156127ca576127c0868287876136f0565b92509250506127f6565b60018760028111156127d857fe5b14156127ea576127c08682878761376b565b6127c0868287876137e7565b94509492505050565b60007f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000061286c61384a565b3060405160200161288195949392919061557d565b60405160208183030381529060405280519060200120905090565b60601c90565b60608060006128b08461202a565b905060028160028111156128c057fe5b14156128d9576128cf8461384e565b92509250506128ff565b60018160028111156128e757fe5b14156128f6576128cf84613983565b6128cf84613aaa565b915091565b60606000825167ffffffffffffffff8111801561292057600080fd5b5060405190808252806020026020018201604052801561294a578160200160208202803683370190505b5091506000905060005b825181101561155157600084828151811061296b57fe5b6020026020010151905061297e81613ba6565b84838151811061298a57fe5b6020026020010181815250506129a8836129a38361272e565b613bc1565b925050600101612954565b6001600160a01b03918216600090815260046020908152604080832093909416825291909152205460ff1690565b6003546040517f9be2a88400000000000000000000000000000000000000000000000000000000815260009161010090046001600160a01b031690639be2a88490612a3490869086903090600401615532565b60206040518083038186803b158015612a4c57600080fd5b505afa158015612a60573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061175c9190614c15565b600080612a918686611a96565b9050612aaa8380612aa25750848210155b610201610558565b612ab48185613bd8565b9150818103612ad0878783612ac88761352a565b600003613be7565b5050949350505050565b6000612ae68484611a96565b90506000612af482846119da565b9050611de4858583612b058761352a565b613be7565b610e2b846323b872dd60e01b858585604051602401611f7393929190615357565b612b3a814710156101a3610558565b6000826001600160a01b031682604051612b5390610555565b60006040518083038185875af1925050503d8060008114612b90576040519150601f19603f3d011682016040523d82523d6000602084013e612b95565b606091505b50509050610fe3816101a4610558565b6001600160a01b0382166000908152600260205260409020805460018101909155610fe3612bd38483613c42565b83610558565b600080600080612bf68660800151876020015188604001516131b6565b92509250925060008087604001516001600160a01b031688602001516001600160a01b03161015612c2b575083905082612c31565b50829050835b612c3d88888484613d68565b60408b015160208c01519199509294509092506001600160a01b03918216911610612c7157612c6c8183613e7e565b612c7b565b612c7b8282613e7e565b909255509295945050505050565b600080612c9e8460800151856020015161267f565b90506000612cb48560800151866040015161267f565b9050612cc285858484613d68565b6080880180516000908152600760208181526040808420828e01516001600160a01b03908116865290835281852098909855935183529081528282209a830151909516815298909352919096209590955550929392505050565b60808201516000908152600160209081526040822090840151829182918290612d46908390613eb9565b90506000612d61886040015184613eb990919063ffffffff16565b9050811580612d6e575080155b15612d8b57612d8088608001516125e7565b612d8b610209611765565b60001991820191016000612d9e84613ed8565b905060608167ffffffffffffffff81118015612db957600080fd5b50604051908082528060200260200182016040528015612de3578160200160208202803683370190505b50600060a08c018190529091505b82811015612e63576000612e058783613edc565b9050612e1081613ba6565b838381518110612e1c57fe5b602002602001018181525050612e398c60a001516129a38361272e565b60a08d015281861415612e4e57809850612e5a565b84821415612e5a578097505b50600101612df1565b506040517f01ec954a0000000000000000000000000000000000000000000000000000000081526001600160a01b038a16906301ec954a90612eaf908d908590899089906004016155e8565b602060405180830381600087803b158015612ec957600080fd5b505af1158015612edd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f01919061511d565b9750600080612f198c600001518d606001518c612f5b565b9092509050612f288983613ef2565b9850612f348882613f23565b9750612f4187878b613f39565b612f4c87868a613f39565b50505050505050505092915050565b60008080856001811115612f6b57fe5b1415612f7b575082905081612f81565b50819050825b935093915050565b6000828202612fad841580612fa6575083858381612fa357fe5b04145b6003610558565b80612fbc57600091505061175f565b670de0b6b3a764000060001982010460010191505061175f565b60006060836001600160a01b031683604051612ff291906152b7565b6000604051808303816000865af19150503d806000811461302f576040519150601f19603f3d011682016040523d82523d6000602084013e613034565b606091505b5091509150600082141561304c573d6000803e3d6000fd5b610e2b81516000148061306e57508180602001905181019061306e9190614c15565b6101a2610558565b6000613082838361364e565b6130e957508154600180820184556000848152602080822090930180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0386169081179091558554908252828601909352604090209190915561175f565b50600061175f565b6001600160a01b03821660009081526002840160205260408120548061319657505082546040805180820182526001600160a01b03858116808352602080840187815260008781526001808c018452878220965187547fffffffffffffffffffffffff0000000000000000000000000000000000000000169616959095178655905194840194909455948201808955908352600288019094529190209190915561190b565b60001901600090815260018086016020526040822001839055905061190b565b60008060008060006131c88787613f51565b9150915060006131d88383613f82565b60008a81526009602090815260408083208484526002019091528120805460018201549197509293509061320b8361363c565b8061321a575061321a8261363c565b8061323b575061322a8c8761366f565b801561323b575061323b8c8661366f565b9050806132565761324b8c6125e7565b613256610209611765565b6132608383613fb5565b985061326c8383613fda565b975050505050505093509350939050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6001600160a01b038116600090815260018301602052604081205480156133d357835460001980830191018082146133635760008660000182815481106132e257fe5b60009182526020909120015487546001600160a01b039091169150819088908590811061330b57fe5b600091825260208083209190910180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0394851617905592909116815260018881019092526040902090830190555b855486908061336e57fe5b60008281526020808220830160001990810180547fffffffffffffffffffffffff00000000000000000000000000000000000000001690559092019092556001600160a01b038716825260018881019091526040822091909155935061175f92505050565b600091505061175f565b600061175c8383610209613ff1565b6001600160a01b038116600090815260028301602052604081205480156133d3578354600019808301910180821461348c576000818152600180880160209081526040808420868552818520815481547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039182161782558286015491860191909155905416845260028a0190915290912090830190555b600081815260018088016020908152604080842080547fffffffffffffffffffffffff000000000000000000000000000000000000000016815583018490559389556001600160a01b038816835260028901905291812055925061175f915050565b6000808460018111156134fd57fe5b146135085781610a0c565b509092915050565b60008084600181111561351f57fe5b1461082a5782610a0c565b600061355a7f800000000000000000000000000000000000000000000000000000000000000083106101a5610558565b5090565b600082820161175c8284128015906135765750848212155b8061358b575060008412801561358b57508482125b6000610558565b600081830361175c8284128015906135aa5750848213155b806135bf57506000841280156135bf57508482135b6001610558565b6000818152600960205260408120805460018201546001600160a01b03918216928492909116908290816135fa8685613f82565b60008181526002840160205260409020805460018201549199509192506136218282613fb5565b965061362d8282613fda565b94505050505091939590929450565b60006136478261327d565b1592915050565b6001600160a01b031660009081526001919091016020526040902054151590565b600082815260096020526040812080546001600160a01b03848116911614806136a7575060018101546001600160a01b038481169116145b8015610a0c575050506001600160a01b03161515919050565b6000828152600860205260408120610a0c818461364e565b6000828152600160205260408120610a0c818461402e565b600080600285600281111561370157fe5b14156137175761371286858561404f565b613741565b600185600281111561372557fe5b14156137365761371286858561405d565b61374186858561406b565b821561375b5761375b6001600160a01b0385163385611f54565b5050600081900394909350915050565b600080600285600281111561377c57fe5b14156137925761378d868585614079565b6137bc565b60018560028111156137a057fe5b14156137b15761378d868585614087565b6137bc868585614095565b82156137d7576137d76001600160a01b038516333086612b0a565b5090946000869003945092505050565b60008060028560028111156137f857fe5b1415613810576138098685856140a3565b905061383d565b600185600281111561381e57fe5b141561382f576138098685856140b3565b61383a8685856140c3565b90505b6000915094509492505050565b4690565b606080600080600080613860876135c6565b92975090955093509150506001600160a01b038416158061388857506001600160a01b038216155b156138b157505060408051600080825260208201908152818301909252945092506128ff915050565b604080516002808252606082018352909160208301908036833701905050955083866000815181106138df57fe5b60200260200101906001600160a01b031690816001600160a01b031681525050818660018151811061390d57fe5b6001600160a01b0392909216602092830291909101820152604080516002808252606082018352909290919083019080368337019050509450828560008151811061395457fe5b602002602001018181525050808560018151811061396e57fe5b60200260200101818152505050505050915091565b6000818152600860205260409020606090819061399f81613ed8565b67ffffffffffffffff811180156139b557600080fd5b506040519080825280602002602001820160405280156139df578160200160208202803683370190505b509250825167ffffffffffffffff811180156139fa57600080fd5b50604051908082528060200260200182016040528015613a24578160200160208202803683370190505b50915060005b8351811015613aa3576000613a3f83836140d3565b905080858381518110613a4e57fe5b6001600160a01b03928316602091820292909201810191909152600088815260078252604080822093851682529290915220548451859084908110613a8f57fe5b602090810291909101015250600101613a2a565b5050915091565b60008181526001602052604090206060908190613ac681613ed8565b67ffffffffffffffff81118015613adc57600080fd5b50604051908082528060200260200182016040528015613b06578160200160208202803683370190505b509250825167ffffffffffffffff81118015613b2157600080fd5b50604051908082528060200260200182016040528015613b4b578160200160208202803683370190505b50915060005b8351811015613aa357613b648282614100565b858381518110613b7057fe5b60200260200101858481518110613b8357fe5b60209081029190910101919091526001600160a01b039091169052600101613b51565b6000613bb182612718565b613bba83612705565b0192915050565b600081831015613bd1578161175c565b5090919050565b6000818310613bd1578161175c565b6001600160a01b038085166000818152600b602090815260408083209488168084529490915290819020859055517f18e1ea4139e68413d7d08aa752e71568e36b2c5bf940893314c2c5b01eaa0c4290611a65908590615529565b600080613c4d614124565b905042811015613c6157600091505061175f565b6000613c6b614130565b905080613c7d5760009250505061175f565b600081613c88614241565b8051602091820120604051613ca4939233918a91899101615551565b6040516020818303038152906040528051906020012090506000613cc782614290565b90506000806000613cd66142ac565b925092509250600060018585858560405160008152602001604052604051613d0194939291906155a9565b6020604051602081039080840390855afa158015613d23573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811615801590613d5957508a6001600160a01b0316816001600160a01b0316145b9b9a5050505050505050505050565b600080600080613d7786613ba6565b90506000613d8486613ba6565b9050613d9b613d928861272e565b6129a38861272e565b60a08a01526040517f9d2c110c0000000000000000000000000000000000000000000000000000000081526001600160a01b03891690639d2c110c90613de9908c9086908690600401615621565b602060405180830381600087803b158015613e0357600080fd5b505af1158015613e17573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613e3b919061511d565b9250600080613e538b600001518c6060015187612f5b565b9092509050613e628983613ef2565b9650613e6e8882613f23565b9550505050509450945094915050565b600080613e96613e8d8561272e565b6129a38561272e565b9050610a0c613ea485612705565b613ead85612705565b8363ffffffff166142d3565b6001600160a01b03166000908152600291909101602052604090205490565b5490565b6000908152600191820160205260409020015490565b600080613f0883613f0286612705565b906119da565b90506000613f1585612718565b9050436112eb8383836142e1565b600080613f0883613f3386612705565b9061431a565b60009182526001928301602052604090912090910155565b600080826001600160a01b0316846001600160a01b031610613f74578284613f77565b83835b915091509250929050565b60008282604051602001613f979291906152d3565b60405160208183030381529060405280519060200120905092915050565b600061175c613fc384612705565b613fcc84612705565b613fd58661272e565b6142e1565b600061175c613fe884612718565b613fcc84612718565b6001600160a01b038216600090815260028401602052604081205461401881151584610558565b6140258560018303613edc565b95945050505050565b6001600160a01b031660009081526002919091016020526040902054151590565b610e2b83836143308461436b565b610e2b838361433084614416565b610e2b838361433084614471565b610e2b83836144c08461436b565b610e2b83836144c084614416565b610e2b83836144c084614471565b6000610a0c84846144e18561436b565b6000610a0c84846144e185614416565b6000610a0c84846144e185614471565b60008260000182815481106140e457fe5b6000918252602090912001546001600160a01b03169392505050565b600090815260019182016020526040902080549101546001600160a01b0390911691565b600061131360006144fb565b6000803560e01c8063b95cac28811461417857638bdb391381146141a0576352bbbe2981146141c85763945bcec981146141f05763fa6e671d8114614218576000925061423c565b7f3f7b71252bd19113ff48c19c6e004a9bcfcca320a0d74d58e85877cbd7dcae58925061423c565b7f8bbc57f66ea936902f50a71ce12b92c43f3c5340bb40c27c4e90ab84eeae3353925061423c565b7fe192dcbc143b1e244ad73b813fd3c097b832ad260a157340b4e5e5beda067abe925061423c565b7f9bfc43a4d98313c6766986ffd7c916c7481566d9f224c6819af0a53388aced3a925061423c565b7fa3f865aa351e51cfeb40f5178d1564bb629fe9030b83caf6361d1baaf5b90b5a92505b505090565b60606000368080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505082519293505050608010156105555760803603815290565b600061429a6127ff565b8260405160200161118992919061530d565b60008060006142bb60206144fb565b92506142c760406144fb565b915061086c60606144fb565b60e01b60709190911b010190565b600083830161430f85821080159061430757506e01000000000000000000000000000082105b61020e610558565b6140258585856142d3565b600061432a838311156001610558565b50900390565b60008061434083613f3386612705565b9050600061435184613f0287612718565b9050600061435e8661272e565b90506112eb8383836142e1565b600080600080600061437c896135c6565b9450509350935093506000836001600160a01b0316896001600160a01b031614156143c75760006143b184898b63ffffffff16565b90506143bd8185614523565b90935090506143e9565b60006143d783898b63ffffffff16565b90506143e38184614523565b90925090505b6143f38383613e7e565b85556143ff838361453f565b600190950194909455509192505050949350505050565b600080614423868661267f565b9050600061443582858763ffffffff16565b60008881526007602090815260408083206001600160a01b038b168452909152902081905590506144668183614523565b979650505050505050565b60008481526001602052604081208161448a82876133dd565b9050600061449c82868863ffffffff16565b90506144a98388836130f1565b506144b48183614523565b98975050505050505050565b6000806144d083613f0286612705565b9050600061435184613f3387612718565b6000806144ed84612705565b9050436140258285836142e1565b36017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80013590565b600061452e82612718565b61453784612718565b039392505050565b600061175c61454d84612718565b61455684612718565b60006142d3565b60408051610120810190915280600081526000602082018190526040820181905260608083018290526080830182905260a0830182905260c0830182905260e08301919091526101009091015290565b604080516080810190915280600081526000602082018190526040820181905260609091015290565b6040518060a0016040528060008019168152602001600081526020016000815260200160008152602001606081525090565b803561175f816156e7565b600082601f830112614623578081fd5b813561463661463182615691565b61566a565b81815291506020808301908481018184028601820187101561465757600080fd5b60005b8481101561467f57813561466d816156e7565b8452928201929082019060010161465a565b505050505092915050565b600082601f83011261469a578081fd5b81356146a861463182615691565b818152915060208083019084810160005b8481101561467f578135870160a080601f19838c030112156146da57600080fd5b6146e38161566a565b85830135815260408084013587830152606080850135828401526080915081850135818401525082840135925067ffffffffffffffff83111561472557600080fd5b6147338c88858701016147b4565b908201528652505092820192908201906001016146b9565b600082601f83011261475b578081fd5b813561476961463182615691565b81815291506020808301908481018184028601820187101561478a57600080fd5b60005b8481101561467f5781358452928201929082019060010161478d565b803561175f816156fc565b600082601f8301126147c4578081fd5b813567ffffffffffffffff8111156147da578182fd5b6147ed6020601f19601f8401160161566a565b915080825283602082850101111561480457600080fd5b8060208401602084013760009082016020015292915050565b803561175f8161570a565b80356002811061175f57600080fd5b80356004811061175f57600080fd5b600060808284031215614857578081fd5b614861608061566a565b9050813567ffffffffffffffff8082111561487b57600080fd5b61488785838601614613565b8352602084013591508082111561489d57600080fd5b6148a98583860161474b565b602084015260408401359150808211156148c257600080fd5b506148cf848285016147b4565b6040830152506148e283606084016147a9565b606082015292915050565b6000608082840312156148fe578081fd5b614908608061566a565b90508135614915816156e7565b81526020820135614925816156fc565b60208201526040820135614938816156e7565b604082015260608201356148e2816156fc565b60006020828403121561495c578081fd5b813561175c816156e7565b60008060408385031215614979578081fd5b8235614984816156e7565b91506020830135614994816156e7565b809150509250929050565b6000806000606084860312156149b3578081fd5b83356149be816156e7565b925060208401356149ce816156e7565b915060408401356149de816156fc565b809150509250925092565b600080604083850312156149fb578182fd5b8235614a06816156e7565b9150602083013567ffffffffffffffff811115614a21578182fd5b614a2d85828601614613565b9150509250929050565b60006020808385031215614a49578182fd5b823567ffffffffffffffff811115614a5f578283fd5b8301601f81018513614a6f578283fd5b8035614a7d61463182615691565b818152838101908385016080808502860187018a1015614a9b578788fd5b8795505b84861015614b045780828b031215614ab5578788fd5b614abe8161566a565b614ac88b8461481d565b815287830135888201526040614ae08c828601614608565b90820152606083810135908201528452600195909501949286019290810190614a9f565b509098975050505050505050565b60006020808385031215614b24578182fd5b823567ffffffffffffffff811115614b3a578283fd5b8301601f81018513614b4a578283fd5b8035614b5861463182615691565b8181528381019083850160a0808502860187018a1015614b76578788fd5b8795505b84861015614b045780828b031215614b90578788fd5b614b998161566a565b614ba38b84614837565b8152614bb18b898501614608565b81890152604083810135908201526060614bcd8c828601614608565b908201526080614bdf8c858301614608565b908201528452600195909501949286019290810190614b7a565b600060208284031215614c0a578081fd5b813561175c816156fc565b600060208284031215614c26578081fd5b815161175c816156fc565b600060208284031215614c42578081fd5b5035919050565b60008060008060808587031215614c5e578182fd5b843593506020850135614c70816156e7565b92506040850135614c80816156e7565b9150606085013567ffffffffffffffff811115614c9b578182fd5b614ca787828801614846565b91505092959194509250565b60008060408385031215614cc5578182fd5b82359150602083013567ffffffffffffffff811115614a21578182fd5b600080600060608486031215614cf6578081fd5b8335925060208085013567ffffffffffffffff80821115614d15578384fd5b614d2188838901614613565b94506040870135915080821115614d36578384fd5b508501601f81018713614d47578283fd5b8035614d5561463182615691565b81815283810190838501858402850186018b1015614d71578687fd5b8694505b83851015614d9c578035614d88816156e7565b835260019490940193918501918501614d75565b5080955050505050509250925092565b60008060408385031215614dbe578182fd5b823591506020830135614994816156e7565b600060208284031215614de1578081fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461175c578182fd5b60008060008060808587031215614e25578182fd5b8435614e30816156e7565b9350602085013567ffffffffffffffff80821115614e4c578384fd5b614e5888838901614613565b94506040870135915080821115614e6d578384fd5b614e798883890161474b565b93506060870135915080821115614e8e578283fd5b50614ca7878288016147b4565b600060208284031215614eac578081fd5b813561175c8161570a565b60008060008060e08587031215614ecc578182fd5b614ed68686614828565b9350602085013567ffffffffffffffff80821115614ef2578384fd5b614efe8883890161468a565b94506040870135915080821115614f13578384fd5b50614f2087828801614613565b925050614f3086606087016148ed565b905092959194509250565b6000806000806000806101208789031215614f54578384fd5b614f5e8888614828565b955060208088013567ffffffffffffffff80821115614f7b578687fd5b614f878b838c0161468a565b975060408a0135915080821115614f9c578687fd5b614fa88b838c01614613565b9650614fb78b60608c016148ed565b955060e08a0135915080821115614fcc578485fd5b508801601f81018a13614fdd578384fd5b8035614feb61463182615691565b81815283810190838501858402850186018e1015615007578788fd5b8794505b8385101561502957803583526001949094019391850191850161500b565b50809650505050505061010087013590509295509295509295565b60008060008060e08587031215615059578182fd5b843567ffffffffffffffff80821115615070578384fd5b9086019060c08289031215615083578384fd5b61508d60c061566a565b8235815261509e8960208501614828565b602082015260408301356150b1816156e7565b60408201526150c38960608501614608565b60608201526080830135608082015260a0830135828111156150e3578586fd5b6150ef8a8286016147b4565b60a08301525080965050505061510886602087016148ed565b939693955050505060a08201359160c0013590565b60006020828403121561512e578081fd5b5051919050565b6001600160a01b03169052565b6000815180845260208085019450808401835b8381101561517a5781516001600160a01b031687529582019590820190600101615155565b509495945050505050565b6000815180845260208085019450808401835b8381101561517a57815187529582019590820190600101615198565b600081518084526151cc8160208601602086016156b1565b601f01601f19169290920160200192915050565b60006101208251600281106151f157fe5b8085525060208301516152076020860182615135565b50604083015161521a6040860182615135565b50606083015160608501526080830151608085015260a083015160a085015260c083015161524b60c0860182615135565b5060e083015161525e60e0860182615135565b506101008084015182828701526112eb838701826151b4565b9182527fffffffff0000000000000000000000000000000000000000000000000000000016602082015260240190565b6000828483379101908152919050565b600082516152c98184602087016156b1565b9190910192915050565b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606093841b811682529190921b16601482015260280190565b7f190100000000000000000000000000000000000000000000000000000000000081526002810192909252602282015260420190565b6001600160a01b0391909116815260200190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b038316815260408101615394836156dd565b8260208301529392505050565b6001600160a01b03929092168252602082015260400190565b60006020825261175c6020830184615142565b6000604082526153e06040830185615142565b828103602084810191909152845180835285820192820190845b8181101561541f5784516001600160a01b0316835293830193918301916001016153fa565b5090979650505050505050565b60006080825261543f6080830187615142565b82810360208401526154518187615185565b905082810360408401526154658186615185565b9050828103606084015261446681856151b4565b60006060825261548c6060830186615142565b828103602084015261549e8186615185565b915050826040830152949350505050565b6020808252825182820181905260009190848201906040850190845b818110156154e7578351835292840192918401916001016154cb565b50909695505050505050565b60006020825261175c6020830184615185565b901515815260200190565b92151583526020830191909152604082015260600190565b90815260200190565b9283526001600160a01b03918216602084015216604082015260600190565b94855260208501939093526001600160a01b039190911660408401526060830152608082015260a00190565b9485526020850193909352604084019190915260608301526001600160a01b0316608082015260a00190565b93845260ff9290921660208401526040830152606082015260800190565b602081016155d4836156dd565b91905290565b918252602082015260400190565b6000608082526155fb60808301876151e0565b828103602084015261560d8187615185565b604084019590955250506060015292915050565b60006060825261563460608301866151e0565b60208301949094525060400152919050565b938452602084019290925260408301526001600160a01b0316606082015260800190565b60405181810167ffffffffffffffff8111828210171561568957600080fd5b604052919050565b600067ffffffffffffffff8211156156a7578081fd5b5060209081020190565b60005b838110156156cc5781810151838201526020016156b4565b83811115610e2b5750506000910152565b6003811061058b57fe5b6001600160a01b038116811461058b57600080fd5b801515811461058b57600080fd5b6003811061058b57600080fdfea2646970667358221220e5cd05e46109bcf6b7b178441016be9f9277e1587a5d476b885b2564a28d497264736f6c63430007010033",
  "devdoc": {
    "details": "The `Vault` is Balancer V2's core contract. A single instance of it exists for the entire network, and it is the entity used to interact with Pools by Liquidity Providers who join and exit them, Traders who swap, and Asset Managers who withdraw and deposit tokens. The `Vault`'s source code is split among a number of sub-contracts, with the goal of improving readability and making understanding the system easier. Most sub-contracts have been marked as `abstract` to explicitly indicate that only the full `Vault` is meant to be deployed. Roughly speaking, these are the contents of each sub-contract:  - `AssetManagers`: Pool token Asset Manager registry, and Asset Manager interactions.  - `Fees`: set and compute protocol fees.  - `FlashLoans`: flash loan transfers and fees.  - `PoolBalances`: Pool joins and exits.  - `PoolRegistry`: Pool registration, ID management, and basic queries.  - `PoolTokens`: Pool token registration and registration, and balance queries.  - `Swaps`: Pool swaps.  - `UserBalance`: manage user balances (Internal Balance operations and external balance transfers)  - `VaultAuthorization`: access control, relayers and signature validation. Additionally, the different Pool specializations are handled by the `GeneralPoolsBalance`, `MinimalSwapInfoPoolsBalance` and `TwoTokenPoolsBalance` sub-contracts, which in turn make use of the `BalanceAllocation` library. The most important goal of the `Vault` is to make token swaps use as little gas as possible. This is reflected in a multitude of design decisions, from minor things like the format used to store Pool IDs, to major features such as the different Pool specialization settings. Finally, the large number of tasks carried out by the Vault means its bytecode is very large, close to exceeding the contract size limit imposed by EIP 170 (https://eips.ethereum.org/EIPS/eip-170). Manual tuning of the source code was required to improve code generation and bring the bytecode size below this limit. This includes extensive utilization of `internal` functions (particularly inside modifiers), usage of named return arguments, dedicated storage access methods, dynamic revert reason generation, and usage of inline assembly, to name a few.",
    "kind": "dev",
    "methods": {
      "WETH()": {
        "details": "Returns the Vault's WETH instance."
      },
      "batchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool),int256[],uint256)": {
        "details": "Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either the amount of tokens sent to or received from the Pool, depending on the `kind` value. Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at the same index in the `assets` array. Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or `amountOut` depending on the swap kind. Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`. The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses, or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault. Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies the minimum or maximum amount of each token the vault is allowed to transfer. `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the equivalent `swap` call. Emits `Swap` events."
      },
      "deregisterTokens(bytes32,address[])": {
        "details": "Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract. Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens must be deregistered in the same `deregisterTokens` call. A deregistered token can be re-registered later on, possibly with a different Asset Manager. Emits a `TokensDeregistered` event."
      },
      "exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))": {
        "details": "Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see `getPoolTokenInfo`). If the caller is not `sender`, it must be an authorized relayer for them. The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault: it just enforces these minimums. If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit. `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final `assets` array might not be sorted. Pools with no registered tokens cannot be exited. If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise, an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to do so will trigger a revert. `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the `tokens` array. This array must match the Pool's registered tokens. This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement their own custom logic. This typically requires additional information from the user (such as the expected number of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and passed directly to the Pool's contract. Emits a `PoolBalanceChanged` event."
      },
      "flashLoan(address,address[],uint256[],bytes)": {
        "details": "Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it, and then reverting unless the tokens plus a proportional protocol fee have been returned. The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount for each token contract. `tokens` must be sorted in ascending order. The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the `receiveFlashLoan` call. Emits `FlashLoan` events."
      },
      "getActionId(bytes4)": {
        "details": "Returns the action identifier associated with the external function described by `selector`."
      },
      "getAuthorizer()": {
        "details": "Returns the Vault's Authorizer."
      },
      "getDomainSeparator()": {
        "details": "Returns the EIP712 domain separator."
      },
      "getInternalBalance(address,address[])": {
        "details": "Returns `user`'s Internal Balance for a set of tokens."
      },
      "getNextNonce(address)": {
        "details": "Returns the next nonce used by an address to sign messages."
      },
      "getPausedState()": {
        "details": "Returns the current contract pause status, as well as the end times of the Pause Window and Buffer Period."
      },
      "getPool(bytes32)": {
        "details": "Returns a Pool's contract address and specialization setting."
      },
      "getPoolTokenInfo(bytes32,address)": {
        "details": "Returns detailed information for a Pool's registered token. `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token` equals the sum of `cash` and `managed`. Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`, `managed` or `total` balance to be greater than 2^112 - 1. `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a change for this purpose, and will update `lastChangeBlock`. `assetManager` is the Pool's token Asset Manager."
      },
      "getPoolTokens(bytes32)": {
        "details": "Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of the tokens' `balances` changed. The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order. If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same order as passed to `registerTokens`. Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo` instead."
      },
      "getProtocolFeesCollector()": {
        "details": "Returns the current protocol fee module."
      },
      "hasApprovedRelayer(address,address)": {
        "details": "Returns true if `user` has approved `relayer` to act as a relayer for them."
      },
      "joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))": {
        "details": "Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized Pool shares. If the caller is not `sender`, it must be an authorized relayer for them. The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces these maximums. If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent back to the caller (not the sender, which is important for relayers). `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final `assets` array might not be sorted. Pools with no registered tokens cannot be joined. If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be withdrawn from Internal Balance: attempting to do so will trigger a revert. This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement their own custom logic. This typically requires additional information from the user (such as the expected number of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed directly to the Pool's contract, as is `recipient`. Emits a `PoolBalanceChanged` event."
      },
      "managePoolBalance((uint8,bytes32,address,uint256)[])": {
        "details": "Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates. Pool Balance management features batching, which means a single contract call can be used to perform multiple operations of different kinds, with different Pools and tokens, at once. For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`."
      },
      "manageUserBalance((uint8,address,uint256,address,address)[])": {
        "details": "Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer) and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as it lets integrators reuse a user's Vault allowance. For each operation, if the caller is not `sender`, it must be an authorized relayer for them."
      },
      "queryBatchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool))": {
        "details": "Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result. Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH) the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it receives are the same that an equivalent `batchSwap` call would receive. Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct. This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens, approve them for the Vault, or even know a user's address. Note that this function is not 'view' (due to implementation details): the client code must explicitly execute eth_call instead of eth_sendTransaction."
      },
      "registerPool(uint8)": {
        "details": "Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be changed. The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`, depending on the chosen specialization setting. This contract is known as the Pool's contract. Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words, multiple Pools may share the same contract. Emits a `PoolRegistered` event."
      },
      "registerTokens(bytes32,address[],address[])": {
        "details": "Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract. Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens, exit by receiving registered tokens, and can only swap registered tokens. Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in ascending order. The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`, depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore expected to be highly secured smart contracts with sound design principles, and the decision to register an Asset Manager should not be made lightly. Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset Manager is set, it cannot be changed except by deregistering the associated token and registering again with a different Asset Manager. Emits a `TokensRegistered` event."
      },
      "setAuthorizer(address)": {
        "details": "Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this. Emits an `AuthorizerChanged` event."
      },
      "setPaused(bool)": {
        "details": "Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an error in some part of the system. The Vault can only be paused during an initial time period, after which pausing is forever disabled. While the contract is paused, the following features are disabled: - depositing and transferring internal balance - transferring external balance (using the Vault's allowance) - swaps - joining Pools - Asset Manager interactions Internal Balance can still be withdrawn, and Pools exited."
      },
      "setRelayerApproval(address,address,bool)": {
        "details": "Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise. Emits a `RelayerApprovalChanged` event."
      },
      "swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)": {
        "details": "Performs a swap with a single Pool. If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens taken from the Pool, which must be greater than or equal to `limit`. If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens sent to the Pool, which must be less than or equal to `limit`. Internal Balance usage and the recipient are determined by the `funds` struct. Emits a `Swap` event."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 15669,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 17633,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_generalPoolsBalances",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_struct(IERC20ToBytes32Map)4262_storage)"
      },
      {
        "astId": 15732,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_nextNonce",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 15983,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_paused",
        "offset": 0,
        "slot": "3",
        "type": "t_bool"
      },
      {
        "astId": 23582,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_authorizer",
        "offset": 1,
        "slot": "3",
        "type": "t_contract(IAuthorizer)19565"
      },
      {
        "astId": 23588,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_approvedRelayers",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 20713,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_isPoolRegistered",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_bytes32,t_bool)"
      },
      {
        "astId": 20715,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_nextPoolNonce",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      },
      {
        "astId": 18049,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_minimalSwapInfoPoolsBalances",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_bytes32,t_mapping(t_contract(IERC20)5318,t_bytes32))"
      },
      {
        "astId": 18053,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_minimalSwapInfoPoolsTokens",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_bytes32,t_struct(AddressSet)5023_storage)"
      },
      {
        "astId": 18507,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_twoTokenPoolTokens",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_bytes32,t_struct(TwoTokenPoolTokens)18503_storage)"
      },
      {
        "astId": 16308,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_poolAssetManagers",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_bytes32,t_mapping(t_contract(IERC20)5318,t_address))"
      },
      {
        "astId": 22963,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_internalTokenBalance",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_address,t_mapping(t_contract(IERC20)5318,t_uint256))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IAuthorizer)19565": {
        "encoding": "inplace",
        "label": "contract IAuthorizer",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)5318": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_contract(IERC20)5318,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(contract IERC20 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_contract(IERC20)5318,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_mapping(t_contract(IERC20)5318,t_address))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(contract IERC20 => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_contract(IERC20)5318,t_address)"
      },
      "t_mapping(t_bytes32,t_mapping(t_contract(IERC20)5318,t_bytes32))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(contract IERC20 => bytes32))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_contract(IERC20)5318,t_bytes32)"
      },
      "t_mapping(t_bytes32,t_struct(AddressSet)5023_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct EnumerableSet.AddressSet)",
        "numberOfBytes": "32",
        "value": "t_struct(AddressSet)5023_storage"
      },
      "t_mapping(t_bytes32,t_struct(IERC20ToBytes32Map)4262_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct EnumerableMap.IERC20ToBytes32Map)",
        "numberOfBytes": "32",
        "value": "t_struct(IERC20ToBytes32Map)4262_storage"
      },
      "t_mapping(t_bytes32,t_struct(TwoTokenPoolBalances)18494_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct TwoTokenPoolsBalance.TwoTokenPoolBalances)",
        "numberOfBytes": "32",
        "value": "t_struct(TwoTokenPoolBalances)18494_storage"
      },
      "t_mapping(t_bytes32,t_struct(TwoTokenPoolTokens)18503_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct TwoTokenPoolsBalance.TwoTokenPoolTokens)",
        "numberOfBytes": "32",
        "value": "t_struct(TwoTokenPoolTokens)18503_storage"
      },
      "t_mapping(t_contract(IERC20)5318,t_address)": {
        "encoding": "mapping",
        "key": "t_contract(IERC20)5318",
        "label": "mapping(contract IERC20 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_contract(IERC20)5318,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_contract(IERC20)5318",
        "label": "mapping(contract IERC20 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_contract(IERC20)5318,t_uint256)": {
        "encoding": "mapping",
        "key": "t_contract(IERC20)5318",
        "label": "mapping(contract IERC20 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_struct(IERC20ToBytes32MapEntry)4251_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct EnumerableMap.IERC20ToBytes32MapEntry)",
        "numberOfBytes": "32",
        "value": "t_struct(IERC20ToBytes32MapEntry)4251_storage"
      },
      "t_struct(AddressSet)5023_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.AddressSet",
        "members": [
          {
            "astId": 5018,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_values",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 5022,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_indexes",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_uint256)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(IERC20ToBytes32Map)4262_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableMap.IERC20ToBytes32Map",
        "members": [
          {
            "astId": 4253,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_length",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 4257,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_entries",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_struct(IERC20ToBytes32MapEntry)4251_storage)"
          },
          {
            "astId": 4261,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_indexes",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_contract(IERC20)5318,t_uint256)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(IERC20ToBytes32MapEntry)4251_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableMap.IERC20ToBytes32MapEntry",
        "members": [
          {
            "astId": 4248,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_key",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(IERC20)5318"
          },
          {
            "astId": 4250,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_value",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(TwoTokenPoolBalances)18494_storage": {
        "encoding": "inplace",
        "label": "struct TwoTokenPoolsBalance.TwoTokenPoolBalances",
        "members": [
          {
            "astId": 18491,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "sharedCash",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 18493,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "sharedManaged",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(TwoTokenPoolTokens)18503_storage": {
        "encoding": "inplace",
        "label": "struct TwoTokenPoolsBalance.TwoTokenPoolTokens",
        "members": [
          {
            "astId": 18496,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "tokenA",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(IERC20)5318"
          },
          {
            "astId": 18498,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "tokenB",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(IERC20)5318"
          },
          {
            "astId": 18502,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "balances",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_bytes32,t_struct(TwoTokenPoolBalances)18494_storage)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}