{
  "language": "Solidity",
  "sources": {
    "contracts/Authentication.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./BalancerErrors.sol\";\nimport \"./IAuthentication.sol\";\n\n/**\n * @dev Building block for performing access control on external functions.\n *\n * This contract is used via the `authenticate` modifier (or the `_authenticateCaller` function), which can be applied\n * to external functions to only make them callable by authorized accounts.\n *\n * Derived contracts must implement the `_canPerform` function, which holds the actual access control logic.\n */\nabstract contract Authentication is IAuthentication {\n    bytes32 private immutable _actionIdDisambiguator;\n\n    /**\n     * @dev The main purpose of the `actionIdDisambiguator` is to prevent accidental function selector collisions in\n     * multi contract systems.\n     *\n     * There are two main uses for it:\n     *  - if the contract is a singleton, any unique identifier can be used to make the associated action identifiers\n     *    unique. The contract's own address is a good option.\n     *  - if the contract belongs to a family that shares action identifiers for the same functions, an identifier\n     *    shared by the entire family (and no other contract) should be used instead.\n     */\n    constructor(bytes32 actionIdDisambiguator) {\n        _actionIdDisambiguator = actionIdDisambiguator;\n    }\n\n    /**\n     * @dev Reverts unless the caller is allowed to call this function. Should only be applied to external functions.\n     */\n    modifier authenticate() {\n        _authenticateCaller();\n        _;\n    }\n\n    /**\n     * @dev Reverts unless the caller is allowed to call the entry point function.\n     */\n    function _authenticateCaller() internal view {\n        bytes32 actionId = getActionId(msg.sig);\n        _require(_canPerform(actionId, msg.sender), Errors.SENDER_NOT_ALLOWED);\n    }\n\n    function getActionId(bytes4 selector) public view override returns (bytes32) {\n        // Each external function is dynamically assigned an action identifier as the hash of the disambiguator and the\n        // function selector. Disambiguation is necessary to avoid potential collisions in the function selectors of\n        // multiple contracts.\n        return keccak256(abi.encodePacked(_actionIdDisambiguator, selector));\n    }\n\n    function _canPerform(bytes32 actionId, address user) internal view virtual returns (bool);\n}\n"
    },
    "contracts/BalancerErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode) pure {\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAL#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string. The \"BAL#\" part is a known constant\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_INVESTMENT_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n}\n"
    },
    "contracts/IAuthentication.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\ninterface IAuthentication {\n    /**\n     * @dev Returns the action identifier associated with the external function described by `selector`.\n     */\n    function getActionId(bytes4 selector) external view returns (bytes32);\n}\n"
    },
    "contracts/BasePool/BasePoolAuthorization.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"../Authentication.sol\";\nimport \"../vault/IAuthorizer.sol\";\n\nimport \"./BasePool.sol\";\n\n/**\n * @dev Base authorization layer implementation for Pools.\n *\n * The owner account can call some of the permissioned functions - access control of the rest is delegated to the\n * Authorizer. Note that this owner is immutable: more sophisticated permission schemes, such as multiple ownership,\n * granular roles, etc., could be built on top of this by making the owner a smart contract.\n *\n * Access control of all other permissioned functions is delegated to an Authorizer. It is also possible to delegate\n * control of *all* permissioned functions to the Authorizer by setting the owner address to `_DELEGATE_OWNER`.\n */\nabstract contract BasePoolAuthorization is Authentication {\n    address private immutable _owner;\n\n    address private constant _DELEGATE_OWNER = 0xBA1BA1ba1BA1bA1bA1Ba1BA1ba1BA1bA1ba1ba1B;\n\n    constructor(address owner) {\n        _owner = owner;\n    }\n\n    function getOwner() public view returns (address) {\n        return _owner;\n    }\n\n    function getAuthorizer() external view returns (IAuthorizer) {\n        return _getAuthorizer();\n    }\n\n    function _canPerform(bytes32 actionId, address account) internal view override returns (bool) {\n        if ((getOwner() != _DELEGATE_OWNER) && _isOwnerOnlyAction(actionId)) {\n            // Only the owner can perform \"owner only\" actions, unless the owner is delegated.\n            return msg.sender == getOwner();\n        } else {\n            // Non-owner actions are always processed via the Authorizer, as \"owner only\" ones are when delegated.\n            return _getAuthorizer().canPerform(actionId, account, address(this));\n        }\n    }\n\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual returns (bool);\n\n    function _getAuthorizer() internal view virtual returns (IAuthorizer);\n}\n"
    },
    "contracts/vault/IAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\ninterface IAuthorizer {\n    /**\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\n     */\n    function canPerform(\n        bytes32 actionId,\n        address account,\n        address where\n    ) external view returns (bool);\n}\n"
    },
    "contracts/BasePool/BasePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Math.sol\";\nimport \"../FixedPoint.sol\";\nimport \"../InputHelpers.sol\";\nimport \"../utils/TemporarilyPausable.sol\";\nimport \"../StablePool/WordCodec.sol\";\nimport \"../ERC20/ERC20.sol\";\n\n\nimport \"./BalancerPoolToken.sol\";\nimport \"./BasePoolAuthorization.sol\";\n\n// solhint-disable max-states-count\n\n/**\n * @dev Reference implementation for the base layer of a Pool contract that manages a single Pool with optional\n * Asset Managers, an admin-controlled swap fee percentage, and an emergency pause mechanism.\n *\n * Note that neither swap fees nor the pause mechanism are used by this contract. They are passed through so that\n * derived contracts can use them via the `_addSwapFeeAmount` and `_subtractSwapFeeAmount` functions, and the\n * `whenNotPaused` modifier.\n *\n * No admin permissions are checked here: instead, this contract delegates that to the Vault's own Authorizer.\n *\n * Because this contract doesn't implement the swap hooks, derived contracts should generally inherit from\n * BaseGeneralPool or BaseMinimalSwapInfoPool. Otherwise, subclasses must inherit from the corresponding interfaces\n * and implement the swap callbacks themselves.\n */\nabstract contract BasePool is BasePoolAuthorization, BalancerPoolToken, TemporarilyPausable {\n    using WordCodec for bytes32;\n    using FixedPoint for uint256;\n\n    uint256 private constant _MIN_TOKENS = 2;\n\n    uint256 private constant _MINIMUM_BPT = 1e6;\n\n    // 1e18 corresponds to 1.0, or a 100% fee\n    uint256 private constant _MIN_SWAP_FEE_PERCENTAGE = 1e12; // 0.0001%\n    uint256 private constant _MAX_SWAP_FEE_PERCENTAGE = 1e17; // 10% - this fits in 64 bits\n\n    bytes32 private _miscData;\n    uint256 private constant _SWAP_FEE_PERCENTAGE_OFFSET = 192;\n\n    event SwapFeePercentageChanged(uint256 swapFeePercentage);\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration,\n        address owner\n    )\n        Authentication(bytes32(uint256(msg.sender)))\n        BalancerPoolToken(name, symbol)\n        BasePoolAuthorization(owner)\n        TemporarilyPausable(pauseWindowDuration, bufferPeriodDuration)\n    {}\n\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {\n        return (actionId == getActionId(this.setSwapFeePercentage.selector));\n    }\n\n    function _getMiscData() internal view returns (bytes32) {\n        return _miscData;\n    }\n\n    /**\n     * Inserts data into the least-significant 192 bits of the misc data storage slot.\n     * Note that the remaining 64 bits are used for the swap fee percentage and cannot be overloaded.\n     */\n    function _setMiscData(bytes32 newData) internal {\n        _miscData = _miscData.insertBits192(newData, 0);\n    }\n\n    function getSwapFeePercentage() public view returns (uint256) {\n        return _miscData.decodeUint64(_SWAP_FEE_PERCENTAGE_OFFSET);\n    }\n\n    function setSwapFeePercentage(uint256 swapFeePercentage) external virtual authenticate whenNotPaused {\n        _setSwapFeePercentage(swapFeePercentage);\n    }\n\n    function _setSwapFeePercentage(uint256 swapFeePercentage) private {\n        _require(swapFeePercentage >= _MIN_SWAP_FEE_PERCENTAGE, Errors.MIN_SWAP_FEE_PERCENTAGE);\n        _require(swapFeePercentage <= _MAX_SWAP_FEE_PERCENTAGE, Errors.MAX_SWAP_FEE_PERCENTAGE);\n\n        _miscData = _miscData.insertUint64(swapFeePercentage, _SWAP_FEE_PERCENTAGE_OFFSET);\n        emit SwapFeePercentageChanged(swapFeePercentage);\n    }\n\n    function _getAuthorizer() internal view override returns (IAuthorizer) {\n        // Access control management is delegated to the Vault's Authorizer. This lets Balancer Governance manage which\n        // accounts can call permissioned functions: for example, to perform emergency pauses.\n        // If the owner is delegated, then *all* permissioned functions, including `setSwapFeePercentage`, will be under\n        // Governance control.\n        return IAuthorizer(address(0));\n    }\n}\n"
    },
    "contracts/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./BalancerErrors.sol\";\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\n * Adapted from OpenZeppelin's SafeMath library\n */\nlibrary Math {\n    /**\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        _require(c >= a, Errors.ADD_OVERFLOW);\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), Errors.ADD_OVERFLOW);\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b <= a, Errors.SUB_OVERFLOW);\n        uint256 c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers of 256 bits.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers of 256 bits.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        _require(a == 0 || c / a == b, Errors.MUL_OVERFLOW);\n        return c;\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        return roundUp ? divUp(a, b) : divDown(a, b);\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n        return a / b;\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            return 1 + (a - 1) / b;\n        }\n    }\n}\n"
    },
    "contracts/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./LogExpMath.sol\";\nimport \"./BalancerErrors.sol\";\n\n/* solhint-disable private-vars-leading-underscore */\n\nlibrary FixedPoint {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\n\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        uint256 c = a + b;\n        _require(c >= a, Errors.ADD_OVERFLOW);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        _require(b <= a, Errors.SUB_OVERFLOW);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\n\n        return product / ONE;\n    }\n\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\n\n        if (product == 0) {\n            return 0;\n        } else {\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((product - 1) / ONE) + 1;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            return aInflated / b;\n        }\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((aInflated - 1) / b) + 1;\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n     * the true value (that is, the error function expected - actual is always positive).\n     */\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        if (raw < maxError) {\n            return 0;\n        } else {\n            return sub(raw, maxError);\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n     * the true value (that is, the error function expected - actual is always negative).\n     */\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n        return add(raw, maxError);\n    }\n\n    /**\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n     *\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\n     * prevents intermediate negative values.\n     */\n    function complement(uint256 x) internal pure returns (uint256) {\n        return (x < ONE) ? (ONE - x) : 0;\n    }\n}\n"
    },
    "contracts/InputHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./ERC20/IERC20.sol\";\n\nimport \"./BalancerErrors.sol\";\n\nlibrary InputHelpers {\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\n        _require(a == b, Errors.INPUT_LENGTH_MISMATCH);\n    }\n\n    function ensureInputLengthMatch(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure {\n        _require(a == b && b == c, Errors.INPUT_LENGTH_MISMATCH);\n    }\n\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\n        address[] memory addressArray;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addressArray := array\n        }\n        ensureArrayIsSorted(addressArray);\n    }\n\n    function ensureArrayIsSorted(address[] memory array) internal pure {\n        if (array.length < 2) {\n            return;\n        }\n\n        address previous = array[0];\n        for (uint256 i = 1; i < array.length; ++i) {\n            address current = array[i];\n            _require(previous < current, Errors.UNSORTED_ARRAY);\n            previous = current;\n        }\n    }\n}\n"
    },
    "contracts/utils/TemporarilyPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"../BalancerErrors.sol\";\nimport \"./ITemporarilyPausable.sol\";\n\n/**\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\n * used as an emergency switch in case a security vulnerability or threat is identified.\n *\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\n * analysis later determines there was a false alarm.\n *\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\n *\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\n * irreversible.\n */\nabstract contract TemporarilyPausable is ITemporarilyPausable {\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\n    // solhint-disable not-rely-on-time\n\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\n\n    uint256 private immutable _pauseWindowEndTime;\n    uint256 private immutable _bufferPeriodEndTime;\n\n    bool private _paused;\n\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\n        _require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, Errors.MAX_PAUSE_WINDOW_DURATION);\n        _require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, Errors.MAX_BUFFER_PERIOD_DURATION);\n\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\n\n        _pauseWindowEndTime = pauseWindowEndTime;\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    modifier whenNotPaused() {\n        _ensureNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\n     * Period.\n     */\n    function getPausedState()\n        external\n        view\n        override\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        )\n    {\n        paused = !_isNotPaused();\n        pauseWindowEndTime = _getPauseWindowEndTime();\n        bufferPeriodEndTime = _getBufferPeriodEndTime();\n    }\n\n    /**\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\n     * unpaused until the end of the Buffer Period.\n     *\n     * Once the Buffer Period expires, this function reverts unconditionally.\n     */\n    function _setPaused(bool paused) internal {\n        if (paused) {\n            _require(block.timestamp < _getPauseWindowEndTime(), Errors.PAUSE_WINDOW_EXPIRED);\n        } else {\n            _require(block.timestamp < _getBufferPeriodEndTime(), Errors.BUFFER_PERIOD_EXPIRED);\n        }\n\n        _paused = paused;\n        emit PausedStateChanged(paused);\n    }\n\n    /**\n     * @dev Reverts if the contract is paused.\n     */\n    function _ensureNotPaused() internal view {\n        _require(_isNotPaused(), Errors.PAUSED);\n    }\n\n    /**\n     * @dev Returns true if the contract is unpaused.\n     *\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\n     * longer accessed.\n     */\n    function _isNotPaused() internal view returns (bool) {\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\n        return block.timestamp > _getBufferPeriodEndTime() || !_paused;\n    }\n\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\n\n    function _getPauseWindowEndTime() private view returns (uint256) {\n        return _pauseWindowEndTime;\n    }\n\n    function _getBufferPeriodEndTime() private view returns (uint256) {\n        return _bufferPeriodEndTime;\n    }\n}\n"
    },
    "contracts/StablePool/WordCodec.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for encoding and decoding values stored inside a 256 bit word. Typically used to pack multiple values in\n * a single storage slot, saving gas by performing less storage accesses.\n *\n * Each value is defined by its size and the least significant bit in the word, also known as offset. For example, two\n * 128 bit values may be encoded in a word by assigning one an offset of 0, and the other an offset of 128.\n *\n * We could use Solidity structs to pack values together in a single storage slot instead of relying on a custom and\n * error-prone library, but unfortunately Solidity only allows for structs to live in either storage, calldata or\n * memory. Because a memory struct uses not just memory but also a slot in the stack (to store its memory location),\n * using memory for word-sized values (i.e. of 256 bits or less) is strictly less gas performant, and doesn't even\n * prevent stack-too-deep issues. This is compounded by the fact that Balancer contracts typically are memory-intensive,\n * and the cost of accesing memory increases quadratically with the number of allocated words. Manual packing and\n * unpacking is therefore the preferred approach.\n */\nlibrary WordCodec {\n    // Masks are values with the least significant N bits set. They can be used to extract an encoded value from a word,\n    // or to insert a new one replacing the old.\n    uint256 private constant _MASK_1 = 2**(1) - 1;\n    uint256 private constant _MASK_5 = 2**(5) - 1;\n    uint256 private constant _MASK_7 = 2**(7) - 1;\n    uint256 private constant _MASK_10 = 2**(10) - 1;\n    uint256 private constant _MASK_16 = 2**(16) - 1;\n    uint256 private constant _MASK_22 = 2**(22) - 1;\n    uint256 private constant _MASK_31 = 2**(31) - 1;\n    uint256 private constant _MASK_32 = 2**(32) - 1;\n    uint256 private constant _MASK_53 = 2**(53) - 1;\n    uint256 private constant _MASK_64 = 2**(64) - 1;\n    uint256 private constant _MASK_128 = 2**(128) - 1;\n    uint256 private constant _MASK_192 = 2**(192) - 1;\n\n    // Largest positive values that can be represented as N bits signed integers.\n    int256 private constant _MAX_INT_22 = 2**(21) - 1;\n    int256 private constant _MAX_INT_53 = 2**(52) - 1;\n\n    // In-place insertion\n\n    /**\n     * @dev Inserts a boolean value shifted by an offset into a 256 bit word, replacing the old value. Returns the new\n     * word.\n     */\n    function insertBool(\n        bytes32 word,\n        bool value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_1 << offset));\n        return clearedWord | bytes32(uint256(value ? 1 : 0) << offset);\n    }\n\n    // Unsigned\n\n    /**\n     * @dev Inserts a 5 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 5 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint5(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_5 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 7 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 7 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint7(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_7 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 10 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 10 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint10(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_10 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 16 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value.\n     * Returns the new word.\n     *\n     * Assumes `value` only uses its least significant 16 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint16(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_16 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 31 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` can be represented using 31 bits.\n     */\n    function insertUint31(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_31 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 32 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 32 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint32(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_32 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    /**\n     * @dev Inserts a 64 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` only uses its least significant 64 bits, otherwise it may overwrite sibling bytes.\n     */\n    function insertUint64(\n        bytes32 word,\n        uint256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_64 << offset));\n        return clearedWord | bytes32(value << offset);\n    }\n\n    // Signed\n\n    /**\n     * @dev Inserts a 22 bits signed integer shifted by an offset into a 256 bit word, replacing the old value. Returns\n     * the new word.\n     *\n     * Assumes `value` can be represented using 22 bits.\n     */\n    function insertInt22(\n        bytes32 word,\n        int256 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_22 << offset));\n        // Integer values need masking to remove the upper bits of negative values.\n        return clearedWord | bytes32((uint256(value) & _MASK_22) << offset);\n    }\n\n    // Bytes\n\n    /**\n     * @dev Inserts 192 bit shifted by an offset into a 256 bit word, replacing the old value. Returns the new word.\n     *\n     * Assumes `value` can be represented using 192 bits.\n     */\n    function insertBits192(\n        bytes32 word,\n        bytes32 value,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_192 << offset));\n        return clearedWord | bytes32((uint256(value) & _MASK_192) << offset);\n    }\n\n    // Encoding\n\n    // Unsigned\n\n    /**\n     * @dev Encodes an unsigned integer shifted by an offset. This performs no size checks: it is up to the caller to\n     * ensure that the values are bounded.\n     *\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\n     */\n    function encodeUint(uint256 value, uint256 offset) internal pure returns (bytes32) {\n        return bytes32(value << offset);\n    }\n\n    // Signed\n\n    /**\n     * @dev Encodes a 22 bits signed integer shifted by an offset.\n     *\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\n     */\n    function encodeInt22(int256 value, uint256 offset) internal pure returns (bytes32) {\n        // Integer values need masking to remove the upper bits of negative values.\n        return bytes32((uint256(value) & _MASK_22) << offset);\n    }\n\n    /**\n     * @dev Encodes a 53 bits signed integer shifted by an offset.\n     *\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\n     */\n    function encodeInt53(int256 value, uint256 offset) internal pure returns (bytes32) {\n        // Integer values need masking to remove the upper bits of negative values.\n        return bytes32((uint256(value) & _MASK_53) << offset);\n    }\n\n    // Decoding\n\n    /**\n     * @dev Decodes and returns a boolean shifted by an offset from a 256 bit word.\n     */\n    function decodeBool(bytes32 word, uint256 offset) internal pure returns (bool) {\n        return (uint256(word >> offset) & _MASK_1) == 1;\n    }\n\n    // Unsigned\n\n    /**\n     * @dev Decodes and returns a 5 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint5(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_5;\n    }\n\n    /**\n     * @dev Decodes and returns a 7 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint7(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_7;\n    }\n\n    /**\n     * @dev Decodes and returns a 10 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint10(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_10;\n    }\n\n    /**\n     * @dev Decodes and returns a 16 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint16(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_16;\n    }\n\n    /**\n     * @dev Decodes and returns a 31 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint31(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_31;\n    }\n\n    /**\n     * @dev Decodes and returns a 32 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint32(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_32;\n    }\n\n    /**\n     * @dev Decodes and returns a 64 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint64(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_64;\n    }\n\n    /**\n     * @dev Decodes and returns a 128 bit unsigned integer shifted by an offset from a 256 bit word.\n     */\n    function decodeUint128(bytes32 word, uint256 offset) internal pure returns (uint256) {\n        return uint256(word >> offset) & _MASK_128;\n    }\n\n    // Signed\n\n    /**\n     * @dev Decodes and returns a 22 bits signed integer shifted by an offset from a 256 bit word.\n     */\n    function decodeInt22(bytes32 word, uint256 offset) internal pure returns (int256) {\n        int256 value = int256(uint256(word >> offset) & _MASK_22);\n        // In case the decoded value is greater than the max positive integer that can be represented with 22 bits,\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\n        // representation.\n        return value > _MAX_INT_22 ? (value | int256(~_MASK_22)) : value;\n    }\n\n    /**\n     * @dev Decodes and returns a 53 bits signed integer shifted by an offset from a 256 bit word.\n     */\n    function decodeInt53(bytes32 word, uint256 offset) internal pure returns (int256) {\n        int256 value = int256(uint256(word >> offset) & _MASK_53);\n        // In case the decoded value is greater than the max positive integer that can be represented with 53 bits,\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\n        // representation.\n\n        return value > _MAX_INT_53 ? (value | int256(~_MASK_53)) : value;\n    }\n}\n"
    },
    "contracts/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../BalancerErrors.sol\";\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_ALLOWANCE)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(subtractedValue, Errors.ERC20_DECREASED_ALLOWANCE_BELOW_ZERO)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        _require(sender != address(0), Errors.ERC20_TRANSFER_FROM_ZERO_ADDRESS);\n        _require(recipient != address(0), Errors.ERC20_TRANSFER_TO_ZERO_ADDRESS);\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_BALANCE);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _require(account != address(0), Errors.ERC20_BURN_FROM_ZERO_ADDRESS);\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, Errors.ERC20_BURN_EXCEEDS_ALLOWANCE);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/BasePool/BalancerPoolToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"../ERC20/ERC20.sol\";\nimport \"../ERC20/ERC20Permit.sol\";\n\n/**\n * @title Highly opinionated token implementation\n * @author Balancer Labs\n * @dev\n * - Includes functions to increase and decrease allowance as a workaround\n *   for the well-known issue with `approve`:\n *   https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n * - Allows for 'infinite allowance', where an allowance of 0xff..ff is not\n *   decreased by calls to transferFrom\n * - Lets a token holder use `transferFrom` to send their own tokens,\n *   without first setting allowance\n * - Emits 'Approval' events whenever allowance is changed by `transferFrom`\n * - Assigns infinite allowance for all token holders to the Vault\n */\ncontract BalancerPoolToken is ERC20, ERC20Permit {\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol\n    ) ERC20(tokenName, tokenSymbol) ERC20Permit(tokenName) {}\n\n\n    // Overrides\n\n    /**\n     * @dev Override to grant the Vault infinite allowance, causing for Pool Tokens to not require approval.\n     *\n     * This is sound as the Vault already provides authorization mechanisms when initiation token transfers, which this\n     * contract inherits.\n     */\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return super.allowance(owner, spender);\n    }\n\n    /**\n     * @dev Override to allow for 'infinite allowance' and let the token owner use `transferFrom` with no self-allowance\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        uint256 currentAllowance = allowance(sender, msg.sender);\n        _require(msg.sender == sender || currentAllowance >= amount, Errors.ERC20_TRANSFER_EXCEEDS_ALLOWANCE);\n\n        _transfer(sender, recipient, amount);\n\n        if (msg.sender != sender && currentAllowance != uint256(-1)) {\n            // Because of the previous require, we know that if msg.sender != sender then currentAllowance >= amount\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Override to allow decreasing allowance by more than the current amount (setting it to zero)\n     */\n    function decreaseAllowance(address spender, uint256 amount) public override returns (bool) {\n        uint256 currentAllowance = allowance(msg.sender, spender);\n\n        if (amount >= currentAllowance) {\n            _approve(msg.sender, spender, 0);\n        } else {\n            // No risk of underflow due to if condition\n            _approve(msg.sender, spender, currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    // Internal functions\n\n    function _mintPoolTokens(address recipient, uint256 amount) internal {\n        _mint(recipient, amount);\n    }\n\n    function _burnPoolTokens(address sender, uint256 amount) internal {\n        _burn(sender, amount);\n    }\n}\n"
    },
    "contracts/LogExpMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the “Software”), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity ^0.7.0;\n\nimport \"./BalancerErrors.sol\";\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        if (y == 0) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return uint256(ONE_18);\n        }\n\n        if (x == 0) {\n            return 0;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\n        int256 x_int256 = int256(x);\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\n        int256 y_int256 = int256(y);\n\n        int256 logx_times_y;\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n            int256 ln_36_x = _ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n        } else {\n            logx_times_y = _ln(x_int256) * y_int256;\n        }\n        logx_times_y /= ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        _require(\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n            Errors.PRODUCT_OUT_OF_BOUNDS\n        );\n\n        return uint256(exp(logx_times_y));\n    }\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return ((ONE_18 * ONE_18) / exp(-x));\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        int256 firstAN;\n        if (x >= x0) {\n            x -= x0;\n            firstAN = a0;\n        } else if (x >= x1) {\n            x -= x1;\n            firstAN = a1;\n        } else {\n            firstAN = 1; // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= 100;\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        int256 product = ONE_20;\n\n        if (x >= x2) {\n            x -= x2;\n            product = (product * a2) / ONE_20;\n        }\n        if (x >= x3) {\n            x -= x3;\n            product = (product * a3) / ONE_20;\n        }\n        if (x >= x4) {\n            x -= x4;\n            product = (product * a4) / ONE_20;\n        }\n        if (x >= x5) {\n            x -= x5;\n            product = (product * a5) / ONE_20;\n        }\n        if (x >= x6) {\n            x -= x6;\n            product = (product * a6) / ONE_20;\n        }\n        if (x >= x7) {\n            x -= x7;\n            product = (product * a7) / ONE_20;\n        }\n        if (x >= x8) {\n            x -= x8;\n            product = (product * a8) / ONE_20;\n        }\n        if (x >= x9) {\n            x -= x9;\n            product = (product * a9) / ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = ((term * x) / ONE_20) / 2;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 3;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 4;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 5;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 6;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 7;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 8;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 9;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 10;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 11;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 12;\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n    }\n\n    /**\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n     */\n    function log(int256 arg, int256 base) internal pure returns (int256) {\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n        // upscaling.\n\n        int256 logBase;\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\n            logBase = _ln_36(base);\n        } else {\n            logBase = _ln(base) * ONE_18;\n        }\n\n        int256 logArg;\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\n            logArg = _ln_36(arg);\n        } else {\n            logArg = _ln(arg) * ONE_18;\n        }\n\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n        return (logArg * ONE_18) / logBase;\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        // The real natural logarithm is not defined for negative numbers or zero.\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n            return _ln_36(a) / ONE_18;\n        } else {\n            return _ln(a);\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        if (a < ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by ONE_18.\n            return (-_ln((ONE_18 * ONE_18) / a));\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        int256 sum = 0;\n        if (a >= a0 * ONE_18) {\n            a /= a0; // Integer, not fixed point division\n            sum += x0;\n        }\n\n        if (a >= a1 * ONE_18) {\n            a /= a1; // Integer, not fixed point division\n            sum += x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= 100;\n        a *= 100;\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= a2) {\n            a = (a * ONE_20) / a2;\n            sum += x2;\n        }\n\n        if (a >= a3) {\n            a = (a * ONE_20) / a3;\n            sum += x3;\n        }\n\n        if (a >= a4) {\n            a = (a * ONE_20) / a4;\n            sum += x4;\n        }\n\n        if (a >= a5) {\n            a = (a * ONE_20) / a5;\n            sum += x5;\n        }\n\n        if (a >= a6) {\n            a = (a * ONE_20) / a6;\n            sum += x6;\n        }\n\n        if (a >= a7) {\n            a = (a * ONE_20) / a7;\n            sum += x7;\n        }\n\n        if (a >= a8) {\n            a = (a * ONE_20) / a8;\n            sum += x8;\n        }\n\n        if (a >= a9) {\n            a = (a * ONE_20) / a9;\n            sum += x9;\n        }\n\n        if (a >= a10) {\n            a = (a * ONE_20) / a10;\n            sum += x10;\n        }\n\n        if (a >= a11) {\n            a = (a * ONE_20) / a11;\n            sum += x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n        int256 z_squared = (z * z) / ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 11;\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= 2;\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / 100;\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n        int256 z_squared = (z * z) / ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 11;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 13;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 15;\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * 2;\n    }\n}\n"
    },
    "contracts/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/utils/ITemporarilyPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface for the TemporarilyPausable helper.\n */\ninterface ITemporarilyPausable {\n    /**\n     * @dev Emitted every time the pause state changes by `_setPaused`.\n     */\n    event PausedStateChanged(bool paused);\n\n    /**\n     * @dev Returns the current paused state.\n     */\n    function getPausedState()\n        external\n        view\n        returns (\n            bool paused,\n            uint256 pauseWindowEndTime,\n            uint256 bufferPeriodEndTime\n        );\n}\n"
    },
    "contracts/ERC20/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../BalancerErrors.sol\";\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        _require(c >= a, Errors.ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, Errors.SUB_OVERFLOW);\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, uint256 errorCode) internal pure returns (uint256) {\n        _require(b <= a, errorCode);\n        uint256 c = a - b;\n\n        return c;\n    }\n}\n"
    },
    "contracts/ERC20/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ERC20.sol\";\nimport \"./IERC20Permit.sol\";\nimport \"./EIP712.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    mapping(address => uint256) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        // solhint-disable-next-line not-rely-on-time\n        _require(block.timestamp <= deadline, Errors.EXPIRED_PERMIT);\n\n        uint256 nonce = _nonces[owner];\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonce, deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ecrecover(hash, v, r, s);\n        _require((signer != address(0)) && (signer == owner), Errors.INVALID_SIGNATURE);\n\n        _nonces[owner] = nonce + 1;\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "contracts/ERC20/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/ERC20/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _HASHED_NAME = keccak256(bytes(name));\n        _HASHED_VERSION = keccak256(bytes(version));\n        _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        // Silence state mutability warning without generating bytecode.\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\n        // https://github.com/ethereum/solidity/issues/2691\n        this;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/StablePool/StablePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../FixedPoint.sol\";\nimport \"../InputHelpers.sol\";\nimport \"./WordCodec.sol\";\n\nimport \"./IRateProvider.sol\";\n\nimport \"../BasePool/BasePool.sol\";\n\nimport \"./StableMath.sol\";\nimport \"./StablePoolUserDataHelpers.sol\";\n\ncontract StablePool is BasePool {\n    using WordCodec for bytes32;\n    using FixedPoint for uint256;\n    using StablePoolUserDataHelpers for bytes;\n\n    // This contract uses timestamps to slowly update its Amplification parameter over time. These changes must occur\n    // over a minimum time period much larger than the blocktime, making timestamp manipulation a non-issue.\n    // solhint-disable not-rely-on-time\n\n    // Amplification factor changes must happen over a minimum period of one day, and can at most divide or multiply the\n    // current value by 2 every day.\n    // WARNING: this only limits *a single* amplification change to have a maximum rate of change of twice the original\n    // value daily. It is possible to perform multiple amplification changes in sequence to increase this value more\n    // rapidly: for example, by doubling the value every day it can increase by a factor of 8 over three days (2^3).\n    uint256 private constant _MIN_UPDATE_TIME = 1 days;\n    uint256 private constant _MAX_AMP_UPDATE_DAILY_RATE = 2;\n\n    bytes32 private _packedAmplificationData;\n\n    event AmpUpdateStarted(uint256 startValue, uint256 endValue, uint256 startTime, uint256 endTime);\n    event AmpUpdateStopped(uint256 currentValue);\n\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT }\n    enum ExitKind { EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 amplificationParameter,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration,\n        address owner\n    )\n    BasePool(\n        name,\n        symbol,\n        pauseWindowDuration,\n        bufferPeriodDuration,\n        owner\n    )\n    {\n        _require(amplificationParameter >= StableMath._MIN_AMP, Errors.MIN_AMP);\n        _require(amplificationParameter <= StableMath._MAX_AMP, Errors.MAX_AMP);\n\n\n        uint256 initialAmp = Math.mul(amplificationParameter, StableMath._AMP_PRECISION);\n        _setAmplificationData(initialAmp);\n    }\n    // Amplification\n\n    /**\n     * @dev Begins changing the amplification parameter to `rawEndValue` over time. The value will change linearly until\n     * `endTime` is reached, when it will be `rawEndValue`.\n     *\n     * NOTE: Internally, the amplification parameter is represented using higher precision. The values returned by\n     * `getAmplificationParameter` have to be corrected to account for this when comparing to `rawEndValue`.\n     */\n    function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {\n        _require(rawEndValue >= StableMath._MIN_AMP, Errors.MIN_AMP);\n        _require(rawEndValue <= StableMath._MAX_AMP, Errors.MAX_AMP);\n\n        uint256 duration = Math.sub(endTime, block.timestamp);\n        _require(duration >= _MIN_UPDATE_TIME, Errors.AMP_END_TIME_TOO_CLOSE);\n\n        (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();\n        _require(!isUpdating, Errors.AMP_ONGOING_UPDATE);\n\n        uint256 endValue = Math.mul(rawEndValue, StableMath._AMP_PRECISION);\n\n        // daily rate = (endValue / currentValue) / duration * 1 day\n        // We perform all multiplications first to not reduce precision, and round the division up as we want to avoid\n        // large rates. Note that these are regular integer multiplications and divisions, not fixed point.\n        uint256 dailyRate = endValue > currentValue\n        ? Math.divUp(Math.mul(1 days, endValue), Math.mul(currentValue, duration))\n        : Math.divUp(Math.mul(1 days, currentValue), Math.mul(endValue, duration));\n        _require(dailyRate <= _MAX_AMP_UPDATE_DAILY_RATE, Errors.AMP_RATE_TOO_HIGH);\n\n        _setAmplificationData(currentValue, endValue, block.timestamp, endTime);\n    }\n\n    /**\n     * @dev Stops the amplification parameter change process, keeping the current value.\n     */\n    function stopAmplificationParameterUpdate() external authenticate {\n        (uint256 currentValue, bool isUpdating) = _getAmplificationParameter();\n        _require(isUpdating, Errors.AMP_NO_ONGOING_UPDATE);\n\n        _setAmplificationData(currentValue);\n    }\n\n    function _getAmplificationParameter() internal view returns (uint256 value, bool isUpdating) {\n        (uint256 startValue, uint256 endValue, uint256 startTime, uint256 endTime) = _getAmplificationData();\n\n        // Note that block.timestamp >= startTime, since startTime is set to the current time when an update starts\n\n        if (block.timestamp < endTime) {\n            isUpdating = true;\n\n            // We can skip checked arithmetic as:\n            //  - block.timestamp is always larger or equal to startTime\n            //  - endTime is always larger than startTime\n            //  - the value delta is bounded by the largest amplification parameter, which never causes the\n            //    multiplication to overflow.\n            // This also means that the following computation will never revert nor yield invalid results.\n            if (endValue > startValue) {\n                value = startValue + ((endValue - startValue) * (block.timestamp - startTime)) / (endTime - startTime);\n            } else {\n                value = startValue - ((startValue - endValue) * (block.timestamp - startTime)) / (endTime - startTime);\n            }\n        } else {\n            isUpdating = false;\n            value = endValue;\n        }\n    }\n\n    function _setAmplificationData(uint256 value) private {\n        _storeAmplificationData(value, value, block.timestamp, block.timestamp);\n        emit AmpUpdateStopped(value);\n    }\n\n    function _setAmplificationData(\n        uint256 startValue,\n        uint256 endValue,\n        uint256 startTime,\n        uint256 endTime\n    ) private {\n        _storeAmplificationData(startValue, endValue, startTime, endTime);\n        emit AmpUpdateStarted(startValue, endValue, startTime, endTime);\n    }\n\n    function _storeAmplificationData(\n        uint256 startValue,\n        uint256 endValue,\n        uint256 startTime,\n        uint256 endTime\n    ) private {\n        _packedAmplificationData =\n        WordCodec.encodeUint(uint64(startValue), 0) |\n        WordCodec.encodeUint(uint64(endValue), 64) |\n        WordCodec.encodeUint(uint64(startTime), 64 * 2) |\n        WordCodec.encodeUint(uint64(endTime), 64 * 3);\n    }\n\n    function _getAmplificationData()\n        private\n        view\n        returns (\n            uint256 startValue,\n            uint256 endValue,\n            uint256 startTime,\n            uint256 endTime\n        )\n    {\n        startValue = _packedAmplificationData.decodeUint64(0);\n        endValue = _packedAmplificationData.decodeUint64(64);\n        startTime = _packedAmplificationData.decodeUint64(64 * 2);\n        endTime = _packedAmplificationData.decodeUint64(64 * 3);\n    }\n\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {\n        return\n        (actionId == getActionId(StablePool.startAmplificationParameterUpdate.selector)) ||\n        (actionId == getActionId(StablePool.stopAmplificationParameterUpdate.selector)) ||\n        super._isOwnerOnlyAction(actionId);\n    }\n}\n"
    },
    "contracts/StablePool/IRateProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\ninterface IRateProvider {\n    function getRate() external view returns (uint256);\n}\n"
    },
    "contracts/StablePool/StableMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"../Math.sol\";\nimport \"../FixedPoint.sol\";\n\nimport \"hardhat/console.sol\";\n\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\n// should be fixed. Additionally, some variables have non mixed case names (e.g. P_D) that relate to the mathematical\n// derivations.\n// solhint-disable private-vars-leading-underscore, var-name-mixedcase\n\nlibrary StableMath {\n    using FixedPoint for uint256;\n\n    uint256 internal constant _MIN_AMP = 1;\n    uint256 internal constant _MAX_AMP = 5000;\n    uint256 internal constant _AMP_PRECISION = 1e3;\n\n    uint256 internal constant _MAX_STABLE_TOKENS = 5;\n\n    // Note on unchecked arithmetic:\n    // This contract performs a large number of additions, subtractions, multiplications and divisions, often inside\n    // loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to\n    // not make any unnecessary checks. We rely on a set of invariants to avoid having to use checked arithmetic (the\n    // Math library), including:\n    //  - the number of tokens is bounded by _MAX_STABLE_TOKENS\n    //  - the amplification parameter is bounded by _MAX_AMP * _AMP_PRECISION, which fits in 23 bits\n    //  - the token balances are bounded by 2^112 (guaranteed by the Vault) times 1e18 (the maximum scaling factor),\n    //    which fits in 172 bits\n    //\n    // This means e.g. we can safely multiply a balance by the amplification parameter without worrying about overflow.\n\n    // About swap fees on joins and exits:\n    // Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\n    // equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\n    // swap fees, it follows that (some) joins and exits should as well.\n    // On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\n    // is the one to which swap fees are applied.\n\n    // Computes the invariant given the current balances, using the Newton-Raphson approximation.\n    // The amplification parameter equals: A n^(n-1)\n    function _calculateInvariant(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        **********************************************************************************************/\n\n        // We support rounding up or down.\n        uint256 sum = 0;\n        uint256 numTokens = balances.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            sum = sum.add(balances[i]);\n        }\n        if (sum == 0) {\n            return 0;\n        }\n\n        uint256 prevInvariant = 0;\n        uint256 invariant = sum;\n        uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n//        for (uint256 i = 0; i < 255; i++) {\n//            uint256 P_D = balances[0] * numTokens;\n//            for (uint256 j = 1; j < numTokens; j++) {\n//                P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n//            }\n//            prevInvariant = invariant;\n//            invariant = Math.div(\n//                Math.mul(Math.mul(numTokens, invariant), invariant).add(\n//                    Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n//                ),\n//                Math.mul(numTokens + 1, invariant).add(\n//                    // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n//                    Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n//                ),\n//                roundUp\n//            );\n//\n//            if (invariant > prevInvariant) {\n//                if (invariant - prevInvariant <= 1) {\n//                    return invariant;\n//                }\n//            } else if (prevInvariant - invariant <= 1) {\n//                return invariant;\n//            }\n//        }\n\n        return invariant;\n        _revert(Errors.STABLE_INVARIANT_DIDNT_CONVERGE);\n    }\n\n    // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.\n    // The amplification parameter equals: A n^(n-1)\n    // The invariant should be rounded up.\n    function _calcOutGivenIn(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint256 tokenAmountIn,\n        uint256 invariant\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // outGivenIn token x for y - polynomial equation to solve                                                   //\n        // ay = amount out to calculate                                                                              //\n        // by = balance token out                                                                                    //\n        // y = by - ay (finalBalanceOut)                                                                             //\n        // D = invariant                                               D                     D^(n+1)                 //\n        // A = amplification coefficient               y^2 + ( S - ----------  - D) * y -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but y                                                                           //\n        // P = product of final balances but y                                                                       //\n        **************************************************************************************************************/\n\n        // Amount out, so we round down overall.\n        balances[tokenIndexIn] = balances[tokenIndexIn].add(tokenAmountIn);\n\n        uint256 finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amplificationParameter,\n            balances,\n            invariant,\n            tokenIndexOut\n        );\n\n        // No need to use checked arithmetic since `tokenAmountIn` was actually added to the same balance right before\n        // calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n        balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;\n\n        return balances[tokenIndexOut].sub(finalBalanceOut).sub(1);\n    }\n\n    // Computes how many tokens must be sent to a pool if `tokenAmountOut` are sent given the\n    // current balances, using the Newton-Raphson approximation.\n    // The amplification parameter equals: A n^(n-1)\n    // The invariant should be rounded up.\n    function _calcInGivenOut(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint256 tokenAmountOut,\n        uint256 invariant\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // inGivenOut token x for y - polynomial equation to solve                                                   //\n        // ax = amount in to calculate                                                                               //\n        // bx = balance token in                                                                                     //\n        // x = bx + ax (finalBalanceIn)                                                                              //\n        // D = invariant                                                D                     D^(n+1)                //\n        // A = amplification coefficient               x^2 + ( S - ----------  - D) * x -  ------------- = 0         //\n        // n = number of tokens                                     (A * n^n)               A * n^2n * P             //\n        // S = sum of final balances but x                                                                           //\n        // P = product of final balances but x                                                                       //\n        **************************************************************************************************************/\n\n        // Amount in, so we round up overall.\n        balances[tokenIndexOut] = balances[tokenIndexOut].sub(tokenAmountOut);\n\n        uint256 finalBalanceIn = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amplificationParameter,\n            balances,\n            invariant,\n            tokenIndexIn\n        );\n\n        // No need to use checked arithmetic since `tokenAmountOut` was actually subtracted from the same balance right\n        // before calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n        balances[tokenIndexOut] = balances[tokenIndexOut] + tokenAmountOut;\n\n        return finalBalanceIn.sub(balances[tokenIndexIn]).add(1);\n    }\n\n    function _calcBptOutGivenExactTokensIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256[] memory amountsIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        // BPT out, so we round down overall.\n\n        // First loop calculates the sum of all token balances, which will be used to calculate\n        // the current weights of each token, relative to this sum\n        uint256 sumBalances = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            sumBalances = sumBalances.add(balances[i]);\n        }\n\n        // Calculate the weighted balance ratio without considering fees\n        uint256[] memory balanceRatiosWithFee = new uint256[](amountsIn.length);\n        // The weighted sum of token balance ratios with fee\n        uint256 invariantRatioWithFees = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            uint256 currentWeight = balances[i].divDown(sumBalances);\n            balanceRatiosWithFee[i] = balances[i].add(amountsIn[i]).divDown(balances[i]);\n            invariantRatioWithFees = invariantRatioWithFees.add(balanceRatiosWithFee[i].mulDown(currentWeight));\n        }\n\n        // Second loop calculates new amounts in, taking into account the fee on the percentage excess\n        uint256[] memory newBalances = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            uint256 amountInWithoutFee;\n\n            // Check if the balance ratio is greater than the ideal ratio to charge fees or not\n            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees.sub(FixedPoint.ONE));\n                uint256 taxableAmount = amountsIn[i].sub(nonTaxableAmount);\n                // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n                amountInWithoutFee = nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n            } else {\n                amountInWithoutFee = amountsIn[i];\n            }\n\n            newBalances[i] = balances[i].add(amountInWithoutFee);\n        }\n\n        // Get current and new invariants, taking swap fees into account\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n        uint256 newInvariant = _calculateInvariant(amp, newBalances, false);\n        uint256 invariantRatio = newInvariant.divDown(currentInvariant);\n\n        // If the invariant didn't increase for any reason, we simply don't mint BPT\n        if (invariantRatio > FixedPoint.ONE) {\n            return bptTotalSupply.mulDown(invariantRatio - FixedPoint.ONE);\n        } else {\n            return 0;\n        }\n    }\n\n    function _calcTokenInGivenExactBptOut(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        // Token in, so we round up overall.\n\n        // Get the current invariant\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n\n        // Calculate new invariant\n        uint256 newInvariant = bptTotalSupply.add(bptAmountOut).divUp(bptTotalSupply).mulUp(currentInvariant);\n\n        // Calculate amount in without fee.\n        uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndex\n        );\n        uint256 amountInWithoutFee = newBalanceTokenIndex.sub(balances[tokenIndex]);\n\n        // First calculate the sum of all token balances, which will be used to calculate\n        // the current weight of each token\n        uint256 sumBalances = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            sumBalances = sumBalances.add(balances[i]);\n        }\n\n        // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\n        // accordingly.\n        uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n        uint256 taxablePercentage = currentWeight.complement();\n        uint256 taxableAmount = amountInWithoutFee.mulUp(taxablePercentage);\n        uint256 nonTaxableAmount = amountInWithoutFee.sub(taxableAmount);\n\n        // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n        return nonTaxableAmount.add(taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage));\n    }\n\n    /*\n    Flow of calculations:\n    amountsTokenOut -> amountsOutProportional ->\n    amountOutPercentageExcess -> amountOutBeforeFee -> newInvariant -> amountBPTIn\n    */\n    function _calcBptInGivenExactTokensOut(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256[] memory amountsOut,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        // BPT in, so we round up overall.\n\n        // First loop calculates the sum of all token balances, which will be used to calculate\n        // the current weights of each token relative to this sum\n        uint256 sumBalances = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            sumBalances = sumBalances.add(balances[i]);\n        }\n\n        // Calculate the weighted balance ratio without considering fees\n        uint256[] memory balanceRatiosWithoutFee = new uint256[](amountsOut.length);\n        uint256 invariantRatioWithoutFees = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            uint256 currentWeight = balances[i].divUp(sumBalances);\n            balanceRatiosWithoutFee[i] = balances[i].sub(amountsOut[i]).divUp(balances[i]);\n            invariantRatioWithoutFees = invariantRatioWithoutFees.add(balanceRatiosWithoutFee[i].mulUp(currentWeight));\n        }\n\n        // Second loop calculates new amounts in, taking into account the fee on the percentage excess\n        uint256[] memory newBalances = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n            // 'token out'. This results in slightly larger price impact.\n\n            uint256 amountOutWithFee;\n            if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithoutFees.complement());\n                uint256 taxableAmount = amountsOut[i].sub(nonTaxableAmount);\n                // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n                amountOutWithFee = nonTaxableAmount.add(taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage));\n            } else {\n                amountOutWithFee = amountsOut[i];\n            }\n\n            newBalances[i] = balances[i].sub(amountOutWithFee);\n        }\n\n        // Get current and new invariants, taking into account swap fees\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n        uint256 newInvariant = _calculateInvariant(amp, newBalances, false);\n        uint256 invariantRatio = newInvariant.divDown(currentInvariant);\n\n        // return amountBPTIn\n        return bptTotalSupply.mulUp(invariantRatio.complement());\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        // Token out, so we round down overall.\n\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n        uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n        uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(currentInvariant);\n\n        // Calculate amount out without fee\n        uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndex\n        );\n        uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\n\n        // First calculate the sum of all token balances, which will be used to calculate\n        // the current weight of each token\n        uint256 sumBalances = 0;\n        for (uint256 i = 0; i < balances.length; i++) {\n            sumBalances = sumBalances.add(balances[i]);\n        }\n\n        // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n        // in swap fees.\n        uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n        uint256 taxablePercentage = currentWeight.complement();\n\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n        // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n        uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n        uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n        // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n        return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n    }\n\n    function _calcTokensOutGivenExactBptIn(\n        uint256[] memory balances,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply\n    ) internal pure returns (uint256[] memory) {\n        /**********************************************************************************************\n        // exactBPTInForTokensOut                                                                    //\n        // (per token)                                                                               //\n        // aO = tokenAmountOut             /        bptIn         \\                                  //\n        // b = tokenBalance      a0 = b * | ---------------------  |                                 //\n        // bptIn = bptAmountIn             \\     bptTotalSupply    /                                 //\n        // bpt = bptTotalSupply                                                                      //\n        **********************************************************************************************/\n\n        // Since we're computing an amount out, we round down overall. This means rounding down on both the\n        // multiplication and division.\n\n        uint256 bptRatio = bptAmountIn.divDown(bptTotalSupply);\n\n        uint256[] memory amountsOut = new uint256[](balances.length);\n        for (uint256 i = 0; i < balances.length; i++) {\n            amountsOut[i] = balances[i].mulDown(bptRatio);\n        }\n\n        return amountsOut;\n    }\n\n    // The amplification parameter equals: A n^(n-1)\n    function _calcDueTokenProtocolSwapFeeAmount(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 lastInvariant,\n        uint256 tokenIndex,\n        uint256 protocolSwapFeePercentage\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // oneTokenSwapFee - polynomial equation to solve                                                            //\n        // af = fee amount to calculate in one token                                                                 //\n        // bf = balance of fee token                                                                                 //\n        // f = bf - af (finalBalanceFeeToken)                                                                        //\n        // D = old invariant                                            D                     D^(n+1)                //\n        // A = amplification coefficient               f^2 + ( S - ----------  - D) * f -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but f                                                                           //\n        // P = product of final balances but f                                                                       //\n        **************************************************************************************************************/\n\n        // Protocol swap fee amount, so we round down overall.\n\n        uint256 finalBalanceFeeToken = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amplificationParameter,\n            balances,\n            lastInvariant,\n            tokenIndex\n        );\n\n        if (balances[tokenIndex] <= finalBalanceFeeToken) {\n            // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n            // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n            return 0;\n        }\n\n        // Result is rounded down\n        uint256 accumulatedTokenSwapFees = balances[tokenIndex] - finalBalanceFeeToken;\n        return accumulatedTokenSwapFees.mulDown(protocolSwapFeePercentage);\n    }\n\n    // Private functions\n\n    // This function calculates the balance of a given token (tokenIndex)\n    // given all the other balances and the invariant\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint256 tokenIndex\n    ) internal pure returns (uint256) {\n        // Rounds result up overall\n\n        uint256 ampTimesTotal = amplificationParameter * balances.length;\n        uint256 sum = balances[0];\n        uint256 P_D = balances[0] * balances.length;\n        for (uint256 j = 1; j < balances.length; j++) {\n            P_D = Math.divDown(Math.mul(Math.mul(P_D, balances[j]), balances.length), invariant);\n            sum = sum.add(balances[j]);\n        }\n        // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n        sum = sum - balances[tokenIndex];\n\n        uint256 inv2 = Math.mul(invariant, invariant);\n        // We remove the balance from c by multiplying it\n        uint256 c = Math.mul(\n            Math.mul(Math.divUp(inv2, Math.mul(ampTimesTotal, P_D)), _AMP_PRECISION),\n            balances[tokenIndex]\n        );\n        uint256 b = sum.add(Math.mul(Math.divDown(invariant, ampTimesTotal), _AMP_PRECISION));\n\n        // We iterate to find the balance\n        uint256 prevTokenBalance = 0;\n        // We multiply the first iteration outside the loop with the invariant to set the value of the\n        // initial approximation.\n        uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));\n\n        for (uint256 i = 0; i < 255; i++) {\n            prevTokenBalance = tokenBalance;\n\n            tokenBalance = Math.divUp(\n                Math.mul(tokenBalance, tokenBalance).add(c),\n                Math.mul(tokenBalance, 2).add(b).sub(invariant)\n            );\n\n            if (tokenBalance > prevTokenBalance) {\n                if (tokenBalance - prevTokenBalance <= 1) {\n                    return tokenBalance;\n                }\n            } else if (prevTokenBalance - tokenBalance <= 1) {\n                return tokenBalance;\n            }\n        }\n\n        _revert(Errors.STABLE_GET_BALANCE_DIDNT_CONVERGE);\n    }\n}\n"
    },
    "contracts/StablePool/StablePoolUserDataHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"../ERC20/IERC20.sol\";\n\nimport \"./StablePool.sol\";\n\nlibrary StablePoolUserDataHelpers {\n    function joinKind(bytes memory self) internal pure returns (StablePool.JoinKind) {\n        return abi.decode(self, (StablePool.JoinKind));\n    }\n\n    function exitKind(bytes memory self) internal pure returns (StablePool.ExitKind) {\n        return abi.decode(self, (StablePool.ExitKind));\n    }\n\n    // Joins\n\n    function initialAmountsIn(bytes memory self) internal pure returns (uint256[] memory amountsIn) {\n        (, amountsIn) = abi.decode(self, (StablePool.JoinKind, uint256[]));\n    }\n\n    function exactTokensInForBptOut(bytes memory self)\n        internal\n        pure\n        returns (uint256[] memory amountsIn, uint256 minBPTAmountOut)\n    {\n        (, amountsIn, minBPTAmountOut) = abi.decode(self, (StablePool.JoinKind, uint256[], uint256));\n    }\n\n    function tokenInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut, uint256 tokenIndex) {\n        (, bptAmountOut, tokenIndex) = abi.decode(self, (StablePool.JoinKind, uint256, uint256));\n    }\n\n    // Exits\n\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (StablePool.ExitKind, uint256, uint256));\n    }\n\n    function exactBptInForTokensOut(bytes memory self) internal pure returns (uint256 bptAmountIn) {\n        (, bptAmountIn) = abi.decode(self, (StablePool.ExitKind, uint256));\n    }\n\n    function bptInForExactTokensOut(bytes memory self)\n        internal\n        pure\n        returns (uint256[] memory amountsOut, uint256 maxBPTAmountIn)\n    {\n        (, amountsOut, maxBPTAmountIn) = abi.decode(self, (StablePool.ExitKind, uint256[], uint256));\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/StablePool/QueryProcessor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../BalancerErrors.sol\";\nimport \"../LogCompression.sol\";\n\nimport \"./IPriceOracle.sol\";\n\nimport \"./Buffer.sol\";\nimport \"./Samples.sol\";\n\n/**\n * @dev Auxiliary library for PoolPriceOracle, offloading most of the query code to reduce bytecode size by using this\n * as a linked library. The downside is an extra DELEGATECALL is added (2600 gas as of the Berlin hardfork), but the\n * bytecode size gains are so big (specially of the oracle contract does not use `LogCompression.fromLowResLog`) that\n * it is worth it.\n */\nlibrary QueryProcessor {\n    using Buffer for uint256;\n    using Samples for bytes32;\n    using LogCompression for int256;\n\n    /**\n     * @dev Returns the value for `variable` at the indexed sample.\n     */\n    function getInstantValue(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.Variable variable,\n        uint256 index\n    ) external view returns (uint256) {\n        bytes32 sample = samples[index];\n        _require(sample.timestamp() > 0, Errors.ORACLE_NOT_INITIALIZED);\n\n        int256 rawInstantValue = sample.instant(variable);\n        return LogCompression.fromLowResLog(rawInstantValue);\n    }\n\n    /**\n     * @dev Returns the time average weighted price corresponding to `query`.\n     */\n    function getTimeWeightedAverage(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.OracleAverageQuery memory query,\n        uint256 latestIndex\n    ) external view returns (uint256) {\n        _require(query.secs != 0, Errors.ORACLE_BAD_SECS);\n\n        int256 beginAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago + query.secs);\n        int256 endAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago);\n        return LogCompression.fromLowResLog((endAccumulator - beginAccumulator) / int256(query.secs));\n    }\n\n    /**\n     * @dev Returns the value of the accumulator for `variable` `ago` seconds ago. `latestIndex` must be the index of\n     * the latest sample in the buffer.\n     *\n     * Reverts under the following conditions:\n     *  - if the buffer is empty.\n     *  - if querying past information and the buffer has not been fully initialized.\n     *  - if querying older information than available in the buffer. Note that a full buffer guarantees queries for the\n     *    past 34 hours will not revert.\n     *\n     * If requesting information for a timestamp later than the latest one, it is extrapolated using the latest\n     * available data.\n     *\n     * When no exact information is available for the requested past timestamp (as usually happens, since at most one\n     * timestamp is stored every two minutes), it is estimated by performing linear interpolation using the closest\n     * values. This process is guaranteed to complete performing at most 10 storage reads.\n     */\n    function getPastAccumulator(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.Variable variable,\n        uint256 latestIndex,\n        uint256 ago\n    ) public view returns (int256) {\n        // solhint-disable not-rely-on-time\n        // `ago` must not be before the epoch.\n        _require(block.timestamp >= ago, Errors.ORACLE_INVALID_SECONDS_QUERY);\n        uint256 lookUpTime = block.timestamp - ago;\n\n        bytes32 latestSample = samples[latestIndex];\n        uint256 latestTimestamp = latestSample.timestamp();\n\n        // The latest sample only has a non-zero timestamp if no data was ever processed and stored in the buffer.\n        _require(latestTimestamp > 0, Errors.ORACLE_NOT_INITIALIZED);\n\n        if (latestTimestamp <= lookUpTime) {\n            // The accumulator at times ahead of the latest one are computed by extrapolating the latest data. This is\n            // equivalent to the instant value not changing between the last timestamp and the look up time.\n\n            // We can use unchecked arithmetic since the accumulator can be represented in 53 bits, timestamps in 31\n            // bits, and the instant value in 22 bits.\n            uint256 elapsed = lookUpTime - latestTimestamp;\n            return latestSample.accumulator(variable) + (latestSample.instant(variable) * int256(elapsed));\n        } else {\n            // The look up time is before the latest sample, but we need to make sure that it is not before the oldest\n            // sample as well.\n\n            // Since we use a circular buffer, the oldest sample is simply the next one.\n            uint256 bufferLength;\n            uint256 oldestIndex = latestIndex.next();\n            {\n                // Local scope used to prevent stack-too-deep errors.\n                bytes32 oldestSample = samples[oldestIndex];\n                uint256 oldestTimestamp = oldestSample.timestamp();\n\n                if (oldestTimestamp > 0) {\n                    // If the oldest timestamp is not zero, it means the buffer was fully initialized.\n                    bufferLength = Buffer.SIZE;\n                } else {\n                    // If the buffer was not fully initialized, we haven't wrapped around it yet,\n                    // and can treat it as a regular array where the oldest index is the first one,\n                    // and the length the number of samples.\n                    bufferLength = oldestIndex; // Equal to latestIndex.next()\n                    oldestIndex = 0;\n                    oldestTimestamp = samples[0].timestamp();\n                }\n\n                // Finally check that the look up time is not previous to the oldest timestamp.\n                _require(oldestTimestamp <= lookUpTime, Errors.ORACLE_QUERY_TOO_OLD);\n            }\n\n            // Perform binary search to find nearest samples to the desired timestamp.\n            (bytes32 prev, bytes32 next) = findNearestSample(samples, lookUpTime, oldestIndex, bufferLength);\n\n            // `next`'s timestamp is guaranteed to be larger than `prev`'s, so we can skip checked arithmetic.\n            uint256 samplesTimeDiff = next.timestamp() - prev.timestamp();\n\n            if (samplesTimeDiff > 0) {\n                // We estimate the accumulator at the requested look up time by interpolating linearly between the\n                // previous and next accumulators.\n\n                // We can use unchecked arithmetic since the accumulators can be represented in 53 bits, and timestamps\n                // in 31 bits.\n                int256 samplesAccDiff = next.accumulator(variable) - prev.accumulator(variable);\n                uint256 elapsed = lookUpTime - prev.timestamp();\n                return prev.accumulator(variable) + ((samplesAccDiff * int256(elapsed)) / int256(samplesTimeDiff));\n            } else {\n                // Rarely, one of the samples will have the exact requested look up time, which is indicated by `prev`\n                // and `next` being the same. In this case, we simply return the accumulator at that point in time.\n                return prev.accumulator(variable);\n            }\n        }\n    }\n\n    /**\n     * @dev Finds the two samples with timestamps before and after `lookUpDate`. If one of the samples matches exactly,\n     * both `prev` and `next` will be it. `offset` is the index of the oldest sample in the buffer. `length` is the size\n     * of the samples list.\n     *\n     * Assumes `lookUpDate` is greater or equal than the timestamp of the oldest sample, and less or equal than the\n     * timestamp of the latest sample.\n     */\n    function findNearestSample(\n        mapping(uint256 => bytes32) storage samples,\n        uint256 lookUpDate,\n        uint256 offset,\n        uint256 length\n    ) public view returns (bytes32 prev, bytes32 next) {\n        // We're going to perform a binary search in the circular buffer, which requires it to be sorted. To achieve\n        // this, we offset all buffer accesses by `offset`, making the first element the oldest one.\n\n        // Auxiliary variables in a typical binary search: we will look at some value `mid` between `low` and `high`,\n        // periodically increasing `low` or decreasing `high` until we either find a match or determine the element is\n        // not in the array.\n        uint256 low = 0;\n        uint256 high = length - 1;\n        uint256 mid;\n\n        // If the search fails and no sample has a timestamp of `lookUpDate` (as is the most common scenario), `sample`\n        // will be either the sample with the largest timestamp smaller than `lookUpDate`, or the one with the smallest\n        // timestamp larger than `lookUpDate`.\n        bytes32 sample;\n        uint256 sampleTimestamp;\n\n        while (low <= high) {\n            // Mid is the floor of the average.\n            uint256 midWithoutOffset = (high + low) / 2;\n\n            // Recall that the buffer is not actually sorted: we need to apply the offset to access it in a sorted way.\n            mid = midWithoutOffset.add(offset);\n            sample = samples[mid];\n            sampleTimestamp = sample.timestamp();\n\n            if (sampleTimestamp < lookUpDate) {\n                // If the mid sample is bellow the look up date, then increase the low index to start from there.\n                low = midWithoutOffset + 1;\n            } else if (sampleTimestamp > lookUpDate) {\n                // If the mid sample is above the look up date, then decrease the high index to start from there.\n\n                // We can skip checked arithmetic: it is impossible for `high` to ever be 0, as a scenario where `low`\n                // equals 0 and `high` equals 1 would result in `low` increasing to 1 in the previous `if` clause.\n                high = midWithoutOffset - 1;\n            } else {\n                // sampleTimestamp == lookUpDate\n                // If we have an exact match, return the sample as both `prev` and `next`.\n                return (sample, sample);\n            }\n        }\n\n        // In case we reach here, it means we didn't find exactly the sample we where looking for.\n        return sampleTimestamp < lookUpDate ? (sample, samples[mid.next()]) : (samples[mid.prev()], sample);\n    }\n}\n"
    },
    "contracts/LogCompression.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./LogExpMath.sol\";\n\n/**\n * @dev Library for encoding and decoding values stored inside a 256 bit word. Typically used to pack multiple values in\n * a single storage slot, saving gas by performing less storage accesses.\n *\n * Each value is defined by its size and the least significant bit in the word, also known as offset. For example, two\n * 128 bit values may be encoded in a word by assigning one an offset of 0, and the other an offset of 128.\n */\nlibrary LogCompression {\n    int256 private constant _LOG_COMPRESSION_FACTOR = 1e14;\n    int256 private constant _HALF_LOG_COMPRESSION_FACTOR = 0.5e14;\n\n    /**\n     * @dev Returns the natural logarithm of `value`, dropping most of the decimal places to arrive at a value that,\n     * when passed to `fromLowResLog`, will have a maximum relative error of ~0.05% compared to `value`.\n     *\n     * Values returned from this function should not be mixed with other fixed-point values (as they have a different\n     * number of digits), but can be added or subtracted. Use `fromLowResLog` to undo this process and return to an\n     * 18 decimal places fixed point value.\n     *\n     * Because so much precision is lost, the logarithmic values can be stored using much fewer bits than the original\n     * value required.\n     */\n    function toLowResLog(uint256 value) internal pure returns (int256) {\n        int256 ln = LogExpMath.ln(int256(value));\n\n        // Rounding division for signed numerator\n        int256 lnWithError = (ln > 0 ? ln + _HALF_LOG_COMPRESSION_FACTOR : ln - _HALF_LOG_COMPRESSION_FACTOR);\n        return lnWithError / _LOG_COMPRESSION_FACTOR;\n    }\n\n    /**\n     * @dev Restores `value` from logarithmic space. `value` is expected to be the result of a call to `toLowResLog`,\n     * any other function that returns 4 decimals fixed point logarithms, or the sum of such values.\n     */\n    function fromLowResLog(int256 value) internal pure returns (uint256) {\n        return uint256(LogExpMath.exp(value * _LOG_COMPRESSION_FACTOR));\n    }\n}\n"
    },
    "contracts/StablePool/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Interface for querying historical data from a Pool that can be used as a Price Oracle.\n *\n * This lets third parties retrieve average prices of tokens held by a Pool over a given period of time, as well as the\n * price of the Pool share token (BPT) and invariant. Since the invariant is a sensible measure of Pool liquidity, it\n * can be used to compare two different price sources, and choose the most liquid one.\n *\n * Once the oracle is fully initialized, all queries are guaranteed to succeed as long as they require no data that\n * is not older than the largest safe query window.\n */\ninterface IPriceOracle {\n    // The three values that can be queried:\n    //\n    // - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\n    //   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\n    //   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\n    //   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\n    //\n    // - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\n    //   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\n    //   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\n    //\n    // - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\n    enum Variable { PAIR_PRICE, BPT_PRICE, INVARIANT }\n\n    /**\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\n     * decimal fixed point values.\n     */\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n\n    /**\n     * @dev Returns latest sample of `variable`. Prices are represented as 18 decimal fixed point values.\n     */\n    function getLatest(Variable variable) external view returns (uint256);\n\n    /**\n     * @dev Information for a Time Weighted Average query.\n     *\n     * Each query computes the average over a window of duration `secs` seconds that ended `ago` seconds ago. For\n     * example, the average over the past 30 minutes is computed by settings secs to 1800 and ago to 0. If secs is 1800\n     * and ago is 1800 as well, the average between 60 and 30 minutes ago is computed instead.\n     */\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    /**\n     * @dev Returns largest time window that can be safely queried, where 'safely' means the Oracle is guaranteed to be\n     * able to produce a result and not revert.\n     *\n     * If a query has a non-zero `ago` value, then `secs + ago` (the oldest point in time) must be smaller than this\n     * value for 'safe' queries.\n     */\n    function getLargestSafeQueryWindow() external view returns (uint256);\n\n    /**\n     * @dev Returns the accumulators corresponding to each of `queries`.\n     */\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n        external\n        view\n        returns (int256[] memory results);\n\n    /**\n     * @dev Information for an Accumulator query.\n     *\n     * Each query estimates the accumulator at a time `ago` seconds ago.\n     */\n    struct OracleAccumulatorQuery {\n        Variable variable;\n        uint256 ago;\n    }\n}\n"
    },
    "contracts/StablePool/Buffer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nlibrary Buffer {\n    // The buffer is a circular storage structure with 1024 slots.\n    // solhint-disable-next-line private-vars-leading-underscore\n    uint256 internal constant SIZE = 1024;\n\n    /**\n     * @dev Returns the index of the element before the one pointed by `index`.\n     */\n    function prev(uint256 index) internal pure returns (uint256) {\n        return sub(index, 1);\n    }\n\n    /**\n     * @dev Returns the index of the element after the one pointed by `index`.\n     */\n    function next(uint256 index) internal pure returns (uint256) {\n        return add(index, 1);\n    }\n\n    /**\n     * @dev Returns the index of an element `offset` slots after the one pointed by `index`.\n     */\n    function add(uint256 index, uint256 offset) internal pure returns (uint256) {\n        return (index + offset) % SIZE;\n    }\n\n    /**\n     * @dev Returns the index of an element `offset` slots before the one pointed by `index`.\n     */\n    function sub(uint256 index, uint256 offset) internal pure returns (uint256) {\n        return (index + SIZE - offset) % SIZE;\n    }\n}\n"
    },
    "contracts/StablePool/Samples.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./WordCodec.sol\";\n\nimport \"./IPriceOracle.sol\";\n\n/**\n * @dev This library provides functions to help manipulating samples for Pool Price Oracles. It handles updates,\n * encoding, and decoding of samples.\n *\n * Each sample holds the timestamp of its last update, plus information about three pieces of data: the price pair, the\n * price of BPT (the associated Pool token), and the invariant.\n *\n * Prices and invariant are not stored directly: instead, we store their logarithm. These are known as the 'instant'\n * values: the exact value at that timestamp.\n *\n * Additionally, for each value we keep an accumulator with the sum of all past values, each weighted by the time\n * elapsed since the previous update. This lets us later subtract accumulators at different points in time and divide by\n * the time elapsed between them, arriving at the geometric mean of the values (also known as log-average).\n *\n * All samples are stored in a single 256 bit word with the following structure:\n *\n * [    log pair price     |        bpt price      |       invariant       |  timestamp ]\n * [ instant | accumulator | instant | accumulator | instant | accumulator |            ]\n * [  int22  |    int53    |  int22  |    int53    |  int22  |    int53    |    uint31  ]\n * MSB                                                                                LSB\n *\n * Assuming the timestamp doesn't overflow (which holds until the year 2038), the largest elapsed time is 2^31, which\n * means the largest possible accumulator value is 2^21 * 2^31, which can be represented using a signed 53 bit integer.\n */\nlibrary Samples {\n    using WordCodec for int256;\n    using WordCodec for uint256;\n    using WordCodec for bytes32;\n\n    uint256 internal constant _TIMESTAMP_OFFSET = 0;\n    uint256 internal constant _ACC_LOG_INVARIANT_OFFSET = 31;\n    uint256 internal constant _INST_LOG_INVARIANT_OFFSET = 84;\n    uint256 internal constant _ACC_LOG_BPT_PRICE_OFFSET = 106;\n    uint256 internal constant _INST_LOG_BPT_PRICE_OFFSET = 159;\n    uint256 internal constant _ACC_LOG_PAIR_PRICE_OFFSET = 181;\n    uint256 internal constant _INST_LOG_PAIR_PRICE_OFFSET = 234;\n\n    /**\n     * @dev Updates a sample, accumulating the new data based on the elapsed time since the previous update. Returns the\n     * updated sample.\n     *\n     * IMPORTANT: This function does not perform any arithmetic checks. In particular, it assumes the caller will never\n     * pass values that cannot be represented as 22 bit signed integers. Additionally, it also assumes\n     * `currentTimestamp` is greater than `sample`'s timestamp.\n     */\n    function update(\n        bytes32 sample,\n        int256 instLogPairPrice,\n        int256 instLogBptPrice,\n        int256 instLogInvariant,\n        uint256 currentTimestamp\n    ) internal pure returns (bytes32) {\n        // Because elapsed can be represented as a 31 bit unsigned integer, and the received values can be represented\n        // as 22 bit signed integers, we don't need to perform checked arithmetic.\n\n        int256 elapsed = int256(currentTimestamp - timestamp(sample));\n        int256 accLogPairPrice = _accLogPairPrice(sample) + instLogPairPrice * elapsed;\n        int256 accLogBptPrice = _accLogBptPrice(sample) + instLogBptPrice * elapsed;\n        int256 accLogInvariant = _accLogInvariant(sample) + instLogInvariant * elapsed;\n\n        return\n            pack(\n                instLogPairPrice,\n                accLogPairPrice,\n                instLogBptPrice,\n                accLogBptPrice,\n                instLogInvariant,\n                accLogInvariant,\n                currentTimestamp\n            );\n    }\n\n    /**\n     * @dev Returns the instant value stored in `sample` for `variable`.\n     */\n    function instant(bytes32 sample, IPriceOracle.Variable variable) internal pure returns (int256) {\n        if (variable == IPriceOracle.Variable.PAIR_PRICE) {\n            return _instLogPairPrice(sample);\n        } else if (variable == IPriceOracle.Variable.BPT_PRICE) {\n            return _instLogBptPrice(sample);\n        } else {\n            // variable == IPriceOracle.Variable.INVARIANT\n            return _instLogInvariant(sample);\n        }\n    }\n\n    /**\n     * @dev Returns the accumulator value stored in `sample` for `variable`.\n     */\n    function accumulator(bytes32 sample, IPriceOracle.Variable variable) internal pure returns (int256) {\n        if (variable == IPriceOracle.Variable.PAIR_PRICE) {\n            return _accLogPairPrice(sample);\n        } else if (variable == IPriceOracle.Variable.BPT_PRICE) {\n            return _accLogBptPrice(sample);\n        } else {\n            // variable == IPriceOracle.Variable.INVARIANT\n            return _accLogInvariant(sample);\n        }\n    }\n\n    /**\n     * @dev Returns `sample`'s timestamp.\n     */\n    function timestamp(bytes32 sample) internal pure returns (uint256) {\n        return sample.decodeUint31(_TIMESTAMP_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s instant value for the logarithm of the pair price.\n     */\n    function _instLogPairPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt22(_INST_LOG_PAIR_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s accumulator of the logarithm of the pair price.\n     */\n    function _accLogPairPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt53(_ACC_LOG_PAIR_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s instant value for the logarithm of the BPT price.\n     */\n    function _instLogBptPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt22(_INST_LOG_BPT_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s accumulator of the logarithm of the BPT price.\n     */\n    function _accLogBptPrice(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt53(_ACC_LOG_BPT_PRICE_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s instant value for the logarithm of the invariant.\n     */\n    function _instLogInvariant(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt22(_INST_LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Returns `sample`'s accumulator of the logarithm of the invariant.\n     */\n    function _accLogInvariant(bytes32 sample) private pure returns (int256) {\n        return sample.decodeInt53(_ACC_LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Returns a sample created by packing together its components.\n     */\n    function pack(\n        int256 instLogPairPrice,\n        int256 accLogPairPrice,\n        int256 instLogBptPrice,\n        int256 accLogBptPrice,\n        int256 instLogInvariant,\n        int256 accLogInvariant,\n        uint256 _timestamp\n    ) internal pure returns (bytes32) {\n        return\n            instLogPairPrice.encodeInt22(_INST_LOG_PAIR_PRICE_OFFSET) |\n            accLogPairPrice.encodeInt53(_ACC_LOG_PAIR_PRICE_OFFSET) |\n            instLogBptPrice.encodeInt22(_INST_LOG_BPT_PRICE_OFFSET) |\n            accLogBptPrice.encodeInt53(_ACC_LOG_BPT_PRICE_OFFSET) |\n            instLogInvariant.encodeInt22(_INST_LOG_INVARIANT_OFFSET) |\n            accLogInvariant.encodeInt53(_ACC_LOG_INVARIANT_OFFSET) |\n            _timestamp.encodeUint(_TIMESTAMP_OFFSET); // Using 31 bits\n    }\n\n    /**\n     * @dev Unpacks a sample into its components.\n     */\n    function unpack(bytes32 sample)\n        internal\n        pure\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 _timestamp\n        )\n    {\n        logPairPrice = _instLogPairPrice(sample);\n        accLogPairPrice = _accLogPairPrice(sample);\n        logBptPrice = _instLogBptPrice(sample);\n        accLogBptPrice = _accLogBptPrice(sample);\n        logInvariant = _instLogInvariant(sample);\n        accLogInvariant = _accLogInvariant(sample);\n        _timestamp = timestamp(sample);\n    }\n}\n"
    },
    "contracts/StablePool/PoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../BalancerErrors.sol\";\n\nimport \"./IPriceOracle.sol\";\nimport \"./IPoolPriceOracle.sol\";\n\nimport \"./Buffer.sol\";\nimport \"./Samples.sol\";\nimport \"./QueryProcessor.sol\";\n\n/**\n * @dev This module allows Pools to access historical pricing information.\n *\n * It uses a 1024 long circular buffer to store past data, where the data within each sample is the result of\n * accumulating live data for no more than two minutes. Therefore, assuming the worst case scenario where new data is\n * updated in every single block, the oldest samples in the buffer (and therefore largest queryable period) will\n * be slightly over 34 hours old.\n *\n * Usage of this module requires the caller to keep track of two variables: the latest circular buffer index, and the\n * timestamp when the index last changed. Aditionally, access to the latest circular buffer index must be exposed by\n * implementing `_getOracleIndex`.\n *\n * This contract relies on the `QueryProcessor` linked library to reduce bytecode size.\n */\nabstract contract PoolPriceOracle is IPoolPriceOracle, IPriceOracle {\n    using Buffer for uint256;\n    using Samples for bytes32;\n\n    // Each sample in the buffer accumulates information for up to 2 minutes. This is simply to reduce the size of the\n    // buffer: small time deviations will not have any significant effect.\n    // solhint-disable not-rely-on-time\n    uint256 private constant _MAX_SAMPLE_DURATION = 2 minutes;\n\n    // We use a mapping to simulate an array: the buffer won't grow or shrink, and since we will always use valid\n    // indexes using a mapping saves gas by skipping the bounds checks.\n    mapping(uint256 => bytes32) internal _samples;\n\n    // IPoolPriceOracle\n\n    function getSample(uint256 index)\n        external\n        view\n        override\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        )\n    {\n        _require(index < Buffer.SIZE, Errors.ORACLE_INVALID_INDEX);\n\n        bytes32 sample = _getSample(index);\n        return sample.unpack();\n    }\n\n    function getTotalSamples() external pure override returns (uint256) {\n        return Buffer.SIZE;\n    }\n\n    /**\n     * @dev Manually dirty oracle sample storage slots with dummy data, to reduce the gas cost of the future swaps\n     * that will initialize them. This function is only useful before the oracle has been fully initialized.\n     *\n     * `endIndex` is non-inclusive.\n     */\n    function dirtyUninitializedOracleSamples(uint256 startIndex, uint256 endIndex) external {\n        _require(startIndex < endIndex && endIndex <= Buffer.SIZE, Errors.OUT_OF_BOUNDS);\n\n        // Uninitialized samples are identified by a zero timestamp -- all other fields are ignored,\n        // so any non-zero value with a zero timestamp suffices.\n        bytes32 initSample = Samples.pack(1, 0, 0, 0, 0, 0, 0);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            if (_samples[i].timestamp() == 0) {\n                _samples[i] = initSample;\n            }\n        }\n    }\n\n    // IPriceOracle\n\n    function getLargestSafeQueryWindow() external pure override returns (uint256) {\n        return 34 hours;\n    }\n\n    function getLatest(Variable variable) external view override returns (uint256) {\n        return QueryProcessor.getInstantValue(_samples, variable, _getOracleIndex());\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        override\n        returns (uint256[] memory results)\n    {\n        results = new uint256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        for (uint256 i = 0; i < queries.length; ++i) {\n            results[i] = QueryProcessor.getTimeWeightedAverage(_samples, queries[i], latestIndex);\n        }\n    }\n\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n        external\n        view\n        override\n        returns (int256[] memory results)\n    {\n        results = new int256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        OracleAccumulatorQuery memory query;\n        for (uint256 i = 0; i < queries.length; ++i) {\n            query = queries[i];\n            results[i] = _getPastAccumulator(query.variable, latestIndex, query.ago);\n        }\n    }\n\n    // Internal functions\n\n    /**\n     * @dev Processes new price and invariant data, updating the latest sample or creating a new one.\n     *\n     * Receives the new logarithms of values to store: `logPairPrice`, `logBptPrice` and `logInvariant`, as well the\n     * index of the latest sample and the timestamp of its creation.\n     *\n     * Returns the index of the latest sample. If different from `latestIndex`, the caller should also store the\n     * timestamp, and pass it on future calls to this function.\n     */\n    function _processPriceData(\n        uint256 latestSampleCreationTimestamp,\n        uint256 latestIndex,\n        int256 logPairPrice,\n        int256 logBptPrice,\n        int256 logInvariant\n    ) internal returns (uint256) {\n        // Read latest sample, and compute the next one by updating it with the newly received data.\n        bytes32 sample = _getSample(latestIndex).update(logPairPrice, logBptPrice, logInvariant, block.timestamp);\n\n        // We create a new sample if more than _MAX_SAMPLE_DURATION seconds have elapsed since the creation of the\n        // latest one. In other words, no sample accumulates data over a period larger than _MAX_SAMPLE_DURATION.\n        bool newSample = block.timestamp - latestSampleCreationTimestamp >= _MAX_SAMPLE_DURATION;\n        latestIndex = newSample ? latestIndex.next() : latestIndex;\n\n        // Store the updated or new sample.\n        _samples[latestIndex] = sample;\n\n        return latestIndex;\n    }\n\n    function _getPastAccumulator(\n        IPriceOracle.Variable variable,\n        uint256 latestIndex,\n        uint256 ago\n    ) internal view returns (int256) {\n        return QueryProcessor.getPastAccumulator(_samples, variable, latestIndex, ago);\n    }\n\n    function _findNearestSample(\n        uint256 lookUpDate,\n        uint256 offset,\n        uint256 length\n    ) internal view returns (bytes32 prev, bytes32 next) {\n        return QueryProcessor.findNearestSample(_samples, lookUpDate, offset, length);\n    }\n\n    /**\n     * @dev Returns the sample that corresponds to a given `index`.\n     *\n     * Using this function instead of accessing storage directly results in denser bytecode (since the storage slot is\n     * only computed here).\n     */\n    function _getSample(uint256 index) internal view returns (bytes32) {\n        return _samples[index];\n    }\n\n    /**\n     * @dev Virtual function to be implemented by derived contracts. Must return the current index of the oracle\n     * circular buffer.\n     */\n    function _getOracleIndex() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/StablePool/IPoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\ninterface IPoolPriceOracle {\n    /**\n     * @dev Returns the raw data of the sample at `index`.\n     */\n    function getSample(uint256 index)\n        external\n        view\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        );\n\n    /**\n     * @dev Returns the total number of samples.\n     */\n    function getTotalSamples() external view returns (uint256);\n}\n"
    },
    "contracts/StablePool/meta/MetaStablePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../StablePool/WordCodec.sol\";\nimport \"../OracleMiscData.sol\";\nimport \"../StableOracleMath.sol\";\nimport \"../../LogCompression.sol\";\nimport \"../PoolPriceOracle.sol\";\nimport \"../../BasePool/BalancerPoolToken.sol\";\n\nimport \"../StablePool.sol\";\n\n/**\n * @dev StablePool suitable for assets with proportional prices (i.e. with slow-changing exchange rates between them).\n * Requires an external feed of these exchange rates.\n *\n * It additionally features a price oracle.\n */\ncontract MetaStablePool is StablePool, StableOracleMath, PoolPriceOracle {\n    using WordCodec for bytes32;\n    using OracleMiscData for bytes32;\n\n    bytes32 private _miscData;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 amplificationParameter,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration,\n        address owner\n    )\n        StablePool(\n            name,\n            symbol,\n            amplificationParameter,\n            pauseWindowDuration,\n            bufferPeriodDuration,\n            owner\n        )\n    {}\n\n\n    // Oracle\n\n    function getOracleMiscData()\n    external\n    view\n    returns (\n        int256 logInvariant,\n        int256 logTotalSupply,\n        uint256 oracleSampleCreationTimestamp,\n        uint256 oracleIndex,\n        bool oracleEnabled\n    )\n    {\n        bytes32 miscData = _getMiscData();\n        logInvariant = miscData.logInvariant();\n        logTotalSupply = miscData.logTotalSupply();\n        oracleSampleCreationTimestamp = miscData.oracleSampleCreationTimestamp();\n        oracleIndex = miscData.oracleIndex();\n        oracleEnabled = miscData.oracleEnabled();\n    }\n\n    function getMiscDataTotalSupply() external view returns (int256) {\n        return _miscData.logTotalSupply();\n    }\n\n    function setSupply(uint256 totalSupply) external {\n        bytes32 miscData = _getMiscData();\n        miscData = miscData.setLogTotalSupply(LogCompression.toLowResLog(totalSupply));\n        _setMiscData(miscData);\n    }\n    /**\n     * @dev Updates the Price Oracle based on the Pool's current state (balances, BPT supply and invariant). Must be\n     * called on *all* state-changing functions with the balances *before* the state change happens, and with\n     * `lastChangeBlock` as the number of the block in which any of the balances last changed.\n     */\n    function updateOracle(\n        uint256 lastChangeBlock,\n        uint256 balance0,\n        uint256 balance1\n    ) public view returns (int256, int256) {\n        bytes32 miscData = _getMiscData();\n        (uint256 currentAmp, ) = _getAmplificationParameter();\n\n        (int256 logSpotPrice, int256 logBptPrice) = StableOracleMath._calcLogPrices(\n            currentAmp,\n            balance0,\n            balance1,\n            miscData.logTotalSupply()\n        );\n\n        return (logSpotPrice, logBptPrice);\n    }\n\n    function errorMethod(\n        uint256 balance0,\n        uint256 balance1\n    ) public returns (uint256) {\n        updateOracle(10000, balance0, balance1);\n        return 0;\n    }\n\n    function _getOracleIndex() internal view override returns (uint256) {\n        return _getMiscData().oracleIndex();\n    }\n\n}\n"
    },
    "contracts/StablePool/OracleMiscData.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./WordCodec.sol\";\n\n/**\n * @dev This module provides an interface to store different pieces of information used by pools with a price oracle.\n *\n * These pieces of information are all kept together in a single storage slot to reduce the number of storage reads. In\n * particular, it stores reduced-precision versions of the total BPT supply and invariant, which lets us not access\n * nor compute these values when producing oracle updates during a swap.\n *\n * Data is stored with the following structure:\n *\n * [### not used ### | oracle enabled | oracle index | oracle sample initial timestamp | log supply | log invariant ]\n * [     uint170     |      bool      |    uint10    |              uint31             |    int22   |     int22     ]\n *\n * Note that we are not using the most-significant 170 bits.\n */\nlibrary OracleMiscData {\n    using WordCodec for bytes32;\n    using WordCodec for uint256;\n\n    uint256 private constant _LOG_INVARIANT_OFFSET = 0;\n    uint256 private constant _LOG_TOTAL_SUPPLY_OFFSET = 22;\n    uint256 private constant _ORACLE_SAMPLE_CREATION_TIMESTAMP_OFFSET = 44;\n    uint256 private constant _ORACLE_INDEX_OFFSET = 75;\n    uint256 private constant _ORACLE_ENABLED_OFFSET = 85;\n\n    /**\n     * @dev Returns the cached logarithm of the invariant.\n     */\n    function logInvariant(bytes32 data) internal pure returns (int256) {\n        return data.decodeInt22(_LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Returns the cached logarithm of the total supply.\n     */\n    function logTotalSupply(bytes32 data) internal pure returns (int256) {\n        return data.decodeInt22(_LOG_TOTAL_SUPPLY_OFFSET);\n    }\n\n    /**\n     * @dev Returns the timestamp of the creation of the oracle's latest sample.\n     */\n    function oracleSampleCreationTimestamp(bytes32 data) internal pure returns (uint256) {\n        return data.decodeUint31(_ORACLE_SAMPLE_CREATION_TIMESTAMP_OFFSET);\n    }\n\n    /**\n     * @dev Returns the index of the oracle's latest sample.\n     */\n    function oracleIndex(bytes32 data) internal pure returns (uint256) {\n        return data.decodeUint10(_ORACLE_INDEX_OFFSET);\n    }\n\n    /**\n     * @dev Returns true if the oracle is enabled.\n     */\n    function oracleEnabled(bytes32 data) internal pure returns (bool) {\n        return data.decodeBool(_ORACLE_ENABLED_OFFSET);\n    }\n\n    /**\n     * @dev Sets the logarithm of the invariant in `data`, returning the updated value.\n     */\n    function setLogInvariant(bytes32 data, int256 _logInvariant) internal pure returns (bytes32) {\n        return data.insertInt22(_logInvariant, _LOG_INVARIANT_OFFSET);\n    }\n\n    /**\n     * @dev Sets the logarithm of the total supply in `data`, returning the updated value.\n     */\n    function setLogTotalSupply(bytes32 data, int256 _logTotalSupply) internal pure returns (bytes32) {\n        return data.insertInt22(_logTotalSupply, _LOG_TOTAL_SUPPLY_OFFSET);\n    }\n\n    /**\n     * @dev Sets the timestamp of the creation of the oracle's latest sample in `data`, returning the updated value.\n     */\n    function setOracleSampleCreationTimestamp(bytes32 data, uint256 _initialTimestamp) internal pure returns (bytes32) {\n        return data.insertUint31(_initialTimestamp, _ORACLE_SAMPLE_CREATION_TIMESTAMP_OFFSET);\n    }\n\n    /**\n     * @dev Sets the index of the  oracle's latest sample in `data`, returning the updated value.\n     */\n    function setOracleIndex(bytes32 data, uint256 _oracleIndex) internal pure returns (bytes32) {\n        return data.insertUint10(_oracleIndex, _ORACLE_INDEX_OFFSET);\n    }\n\n    /**\n     * @dev Enables or disables the oracle in `data`, returning the updated value.\n     */\n    function setOracleEnabled(bytes32 data, bool _oracleEnabled) internal pure returns (bytes32) {\n        return data.insertBool(_oracleEnabled, _ORACLE_ENABLED_OFFSET);\n    }\n}\n"
    },
    "contracts/StablePool/StableOracleMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"../FixedPoint.sol\";\nimport \"../LogCompression.sol\";\n\nimport \"./StableMath.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract StableOracleMath {\n    using FixedPoint for uint256;\n\n    /**\n     * @dev Calculates the spot price of token Y and BPT in token X.\n     */\n    function _calcLogPrices(\n        uint256 amplificationParameter,\n        uint256 balanceX,\n        uint256 balanceY,\n        int256 logBptTotalSupply\n    ) internal view returns (int256 logSpotPrice, int256 logBptPrice) {\n\n        console.log(\"logBptTotalSupply %s , amplificationParameter\", balanceX);\n\n        uint256 spotPrice = _calcSpotPrice(amplificationParameter, balanceX, balanceY);\n        logBptPrice = _calcLogBptPrice(spotPrice, balanceX, balanceY, logBptTotalSupply);\n        logSpotPrice = LogCompression.toLowResLog(spotPrice);\n    }\n\n    /**\n     * @dev Calculates the spot price of token Y in token X.\n     */\n    function _calcSpotPrice(\n        uint256 amplificationParameter,\n        uint256 balanceX,\n        uint256 balanceY\n    ) internal view returns (uint256) {\n        /**************************************************************************************************************\n        //                                                                                                           //\n        //                             2.a.x.y + a.y^2 + b.y                                                         //\n        // spot price Y/X = - dx/dy = -----------------------                                                        //\n        //                             2.a.x.y + a.x^2 + b.x                                                         //\n        //                                                                                                           //\n        // n = 2                                                                                                     //\n        // a = amp param * n                                                                                         //\n        // b = D + a.(S - D)                                                                                         //\n        // D = invariant                                                                                             //\n        // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\n        **************************************************************************************************************/\n\n        console.log(\"StableOracleMath\");\n        uint256 invariant = StableMath._calculateInvariant(amplificationParameter, _balances(balanceX, balanceY), true);\n\n        console.log(\"StableOracleMath amplificationParameter %s\", amplificationParameter);\n        uint256 a = (amplificationParameter * 2) / StableMath._AMP_PRECISION;\n        console.log(\"StableOracleMath a %s\", a);\n        uint256 b = Math.mul(invariant, a).sub(invariant);\n        console.log(\"StableOracleMath b %s\", b);\n\n        uint256 axy2 = Math.mul(a * 2, balanceX).mulDown(balanceY); // n = 2\n        console.log(\"StableOracleMath axy2 %s\", axy2);\n\n        // dx = a.x.y.2 + a.y^2 - b.y\n        uint256 derivativeX = axy2.add(Math.mul(a, balanceY).mulDown(balanceY)).sub(b.mulDown(balanceY));\n\n        // dy = a.x.y.2 + a.x^2 - b.x\n        uint256 derivativeY = axy2.add(Math.mul(a, balanceX).mulDown(balanceX)).sub(b.mulDown(balanceX));\n\n        // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n        // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n        // result of zero is therefore only possible with zero balances, which are prevented via other means.\n        return derivativeX.divUp(derivativeY);\n    }\n\n    /**\n     * @dev Calculates the price of BPT in token X. `logBptTotalSupply` should be the result of calling\n     * `LogCompression.toLowResLog` with the current BPT supply, and `spotPrice` the price of token\n     * Y in token X (obtainable via `_calcSpotPrice()`.\n     *\n     * The return value is a 4 decimal fixed-point number: use `LogCompression.fromLowResLog`\n     * to recover the original value.\n     */\n    function _calcLogBptPrice(\n        uint256 spotPrice,\n        uint256 balanceX,\n        uint256 balanceY,\n        int256 logBptTotalSupply\n    ) internal pure returns (int256) {\n        /**************************************************************************************************************\n        //                                                                                                           //\n        //              balance X + (spot price Y/X * balance Y)                                                     //\n        // BPT price = ------------------------------------------                                                    //\n        //                          total supply                                                                     //\n        //                                                                                                           //\n        // ln(BPT price) = ln(balance X + (spot price Y/X * balance Y)) - ln(totalSupply)                            //\n        **************************************************************************************************************/\n\n        // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n        // space. We use `mulUp` as it prevents the result from being zero, which would make the logarithm revert. A\n        // result of zero is therefore only possible with zero balances, which are prevented via other means.\n        uint256 totalBalanceX = balanceX.add(spotPrice.mulUp(balanceY));\n        int256 logTotalBalanceX = LogCompression.toLowResLog(totalBalanceX);\n\n        // Because we're subtracting two values in log space, this value has a larger error (+-0.0001 instead of\n        // +-0.00005), which results in a final larger relative error of around 0.1%.\n        return logTotalBalanceX - logBptTotalSupply;\n    }\n\n    function _balances(uint256 balanceX, uint256 balanceY) private pure returns (uint256[] memory balances) {\n        balances = new uint256[](2);\n        balances[0] = balanceX;\n        balances[1] = balanceY;\n    }\n}\n"
    },
    "contracts/StablePool/meta/MetaStablePoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n\nimport \"../../BasePool/BasePoolSplitCodeFactory.sol\";\n\nimport \"./MetaStablePool.sol\";\n\ncontract MetaStablePoolFactory is BasePoolSplitCodeFactory {\n    constructor() BasePoolSplitCodeFactory(type(MetaStablePool).creationCode) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Deploys a new `MetaStablePool`.\n     */\n    function create(\n        string memory name,\n        string memory symbol,\n        uint256 amplificationParameter,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration,\n        address owner\n    ) external returns (address) {\n        return\n            _create(\n                abi.encode(\n//                    MetaStablePool.NewPoolParams({\n//                        vault: getVault(),\n//                        name: name,\n//                        symbol: symbol,\n//                        tokens: tokens,\n//                        rateProviders: rateProviders,\n//                        priceRateCacheDuration: priceRateCacheDuration,\n//                        amplificationParameter: amplificationParameter,\n//                        swapFeePercentage: swapFeePercentage,\n//                        pauseWindowDuration: pauseWindowDuration,\n//                        bufferPeriodDuration: bufferPeriodDuration,\n//                        oracleEnabled: oracleEnabled,\n//                        owner: owner\n//                    })\n//                    getVault(),\n                    name,\n                    symbol,\n//                    tokens,\n//                    rateProviders,\n//                    priceRateCacheDuration,\n                    amplificationParameter,\n//                    swapFeePercentage,\n                    pauseWindowDuration,\n                    bufferPeriodDuration,\n                    owner\n                )\n            );\n    }\n}\n"
    },
    "contracts/BasePool/BasePoolSplitCodeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseSplitCodeFactory.sol\";\n\n/**\n * @dev Same as `BasePoolFactory`, for Pools whose creation code is so large that the factory cannot hold it.\n */\nabstract contract BasePoolSplitCodeFactory is BaseSplitCodeFactory {\n    mapping(address => bool) private _isPoolFromFactory;\n\n    event PoolCreated(address indexed pool);\n\n    constructor(bytes memory creationCode) BaseSplitCodeFactory(creationCode) {}\n\n\n    function _create(bytes memory constructorArgs) internal override returns (address) {\n        address pool = super._create(constructorArgs);\n\n        _isPoolFromFactory[pool] = true;\n        emit PoolCreated(pool);\n\n        return pool;\n    }\n}\n"
    },
    "contracts/BasePool/BaseSplitCodeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../BalancerErrors.sol\";\nimport \"../CodeDeployer.sol\";\n\n/**\n * @dev Base factory for contracts whose creation code is so large that the factory cannot hold it. This happens when\n * the contract's creation code grows close to 24kB.\n *\n * Note that this factory cannot help with contracts that have a *runtime* (deployed) bytecode larger than 24kB.\n */\nabstract contract BaseSplitCodeFactory {\n    // The contract's creation code is stored as code in two separate addresses, and retrieved via `extcodecopy`. This\n    // means this factory supports contracts with creation code of up to 48kB.\n    // We rely on inline-assembly to achieve this, both to make the entire operation highly gas efficient, and because\n    // `extcodecopy` is not available in Solidity.\n\n    // solhint-disable no-inline-assembly\n\n    address private immutable _creationCodeContractA;\n    uint256 private immutable _creationCodeSizeA;\n\n    address private immutable _creationCodeContractB;\n    uint256 private immutable _creationCodeSizeB;\n\n    /**\n     * @dev The creation code of a contract Foo can be obtained inside Solidity with `type(Foo).creationCode`.\n     */\n    constructor(bytes memory creationCode) {\n        uint256 creationCodeSize = creationCode.length;\n\n        // We are going to deploy two contracts: one with approximately the first half of `creationCode`'s contents\n        // (A), and another with the remaining half (B).\n        // We store the lengths in both immutable and stack variables, since immutable variables cannot be read during\n        // construction.\n        uint256 creationCodeSizeA = creationCodeSize / 2;\n        _creationCodeSizeA = creationCodeSizeA;\n\n        uint256 creationCodeSizeB = creationCodeSize - creationCodeSizeA;\n        _creationCodeSizeB = creationCodeSizeB;\n\n        // To deploy the contracts, we're going to use `CodeDeployer.deploy()`, which expects a memory array with\n        // the code to deploy. Note that we cannot simply create arrays for A and B's code by copying or moving\n        // `creationCode`'s contents as they are expected to be very large (> 24kB), so we must operate in-place.\n\n        // Memory: [ code length ] [ A.data ] [ B.data ]\n\n        // Creating A's array is simple: we simply replace `creationCode`'s length with A's length. We'll later restore\n        // the original length.\n\n        bytes memory creationCodeA;\n        assembly {\n            creationCodeA := creationCode\n            mstore(creationCodeA, creationCodeSizeA)\n        }\n\n        // Memory: [ A.length ] [ A.data ] [ B.data ]\n        //         ^ creationCodeA\n\n        _creationCodeContractA = CodeDeployer.deploy(creationCodeA);\n\n        // Creating B's array is a bit more involved: since we cannot move B's contents, we are going to create a 'new'\n        // memory array starting at A's last 32 bytes, which will be replaced with B's length. We'll back-up this last\n        // byte to later restore it.\n\n        bytes memory creationCodeB;\n        bytes32 lastByteA;\n\n        assembly {\n            // `creationCode` points to the array's length, not data, so by adding A's length to it we arrive at A's\n            // last 32 bytes.\n            creationCodeB := add(creationCode, creationCodeSizeA)\n            lastByteA := mload(creationCodeB)\n            mstore(creationCodeB, creationCodeSizeB)\n        }\n\n        // Memory: [ A.length ] [ A.data[ : -1] ] [ B.length ][ B.data ]\n        //         ^ creationCodeA                ^ creationCodeB\n\n        _creationCodeContractB = CodeDeployer.deploy(creationCodeB);\n\n        // We now restore the original contents of `creationCode` by writing back the original length and A's last byte.\n        assembly {\n            mstore(creationCodeA, creationCodeSize)\n            mstore(creationCodeB, lastByteA)\n        }\n    }\n\n    /**\n     * @dev Returns the two addresses where the creation code of the contract crated by this factory is stored.\n     */\n    function getCreationCodeContracts() public view returns (address contractA, address contractB) {\n        return (_creationCodeContractA, _creationCodeContractB);\n    }\n\n    /**\n     * @dev Returns the creation code of the contract this factory creates.\n     */\n    function getCreationCode() public view returns (bytes memory) {\n        return _getCreationCodeWithArgs(\"\");\n    }\n\n    /**\n     * @dev Returns the creation code that will result in a contract being deployed with `constructorArgs`.\n     */\n    function _getCreationCodeWithArgs(bytes memory constructorArgs) public view returns (bytes memory code) {\n        // This function exists because `abi.encode()` cannot be instructed to place its result at a specific address.\n        // We need for the ABI-encoded constructor arguments to be located immediately after the creation code, but\n        // cannot rely on `abi.encodePacked()` to perform concatenation as that would involve copying the creation code,\n        // which would be prohibitively expensive.\n        // Instead, we compute the creation code in a pre-allocated array that is large enough to hold *both* the\n        // creation code and the constructor arguments, and then copy the ABI-encoded arguments (which should not be\n        // overly long) right after the end of the creation code.\n\n        // Immutable variables cannot be used in assembly, so we store them in the stack first.\n        address creationCodeContractA = _creationCodeContractA;\n        uint256 creationCodeSizeA = _creationCodeSizeA;\n        address creationCodeContractB = _creationCodeContractB;\n        uint256 creationCodeSizeB = _creationCodeSizeB;\n\n        uint256 creationCodeSize = creationCodeSizeA + creationCodeSizeB;\n        uint256 constructorArgsSize = constructorArgs.length;\n\n        uint256 codeSize = creationCodeSize + constructorArgsSize;\n\n        assembly {\n            // First, we allocate memory for `code` by retrieving the free memory pointer and then moving it ahead of\n            // `code` by the size of the creation code plus constructor arguments, and 32 bytes for the array length.\n            code := mload(0x40)\n            mstore(0x40, add(code, add(codeSize, 32)))\n\n            // We now store the length of the code plus constructor arguments.\n            mstore(code, codeSize)\n\n            // Next, we concatenate the creation code stored in A and B.\n            let dataStart := add(code, 32)\n            extcodecopy(creationCodeContractA, dataStart, 0, creationCodeSizeA)\n            extcodecopy(creationCodeContractB, add(dataStart, creationCodeSizeA), 0, creationCodeSizeB)\n        }\n\n        // Finally, we copy the constructorArgs to the end of the array. Unfortunately there is no way to avoid this\n        // copy, as it is not possible to tell Solidity where to store the result of `abi.encode()`.\n        uint256 constructorArgsDataPtr;\n        uint256 constructorArgsCodeDataPtr;\n        assembly {\n            constructorArgsDataPtr := add(constructorArgs, 32)\n            constructorArgsCodeDataPtr := add(add(code, 32), creationCodeSize)\n        }\n\n        _memcpy(constructorArgsCodeDataPtr, constructorArgsDataPtr, constructorArgsSize);\n    }\n\n    /**\n     * @dev Deploys a contract with constructor arguments. To create `constructorArgs`, call `abi.encode()` with the\n     * contract's constructor arguments, in order.\n     */\n    function _create(bytes memory constructorArgs) internal virtual returns (address) {\n        bytes memory creationCode = _getCreationCodeWithArgs(constructorArgs);\n\n        address destination;\n        assembly {\n            destination := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        if (destination == address(0)) {\n            // Bubble up inner revert reason\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        return destination;\n    }\n\n    // From\n    // https://github.com/Arachnid/solidity-stringutils/blob/b9a6f6615cf18a87a823cbc461ce9e140a61c305/src/strings.sol\n    function _memcpy(\n        uint256 dest,\n        uint256 src,\n        uint256 len\n    ) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "contracts/CodeDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./BalancerErrors.sol\";\n\n/**\n * @dev Library used to deploy contracts with specific code. This can be used for long-term storage of immutable data as\n * contract code, which can be retrieved via the `extcodecopy` opcode.\n */\nlibrary CodeDeployer {\n    // During contract construction, the full code supplied exists as code, and can be accessed via `codesize` and\n    // `codecopy`. This is not the contract's final code however: whatever the constructor returns is what will be\n    // stored as its code.\n    //\n    // We use this mechanism to have a simple constructor that stores whatever is appended to it. The following opcode\n    // sequence corresponds to the creation code of the following equivalent Solidity contract, plus padding to make the\n    // full code 32 bytes long:\n    //\n    // contract CodeDeployer {\n    //     constructor() payable {\n    //         uint256 size;\n    //         assembly {\n    //             size := sub(codesize(), 32) // size of appended data, as constructor is 32 bytes long\n    //             codecopy(0, 32, size) // copy all appended data to memory at position 0\n    //             return(0, size) // return appended data for it to be stored as code\n    //         }\n    //     }\n    // }\n    //\n    // More specifically, it is composed of the following opcodes (plus padding):\n    //\n    // [1] PUSH1 0x20\n    // [2] CODESIZE\n    // [3] SUB\n    // [4] DUP1\n    // [6] PUSH1 0x20\n    // [8] PUSH1 0x00\n    // [9] CODECOPY\n    // [11] PUSH1 0x00\n    // [12] RETURN\n    //\n    // The padding is just the 0xfe sequence (invalid opcode).\n    bytes32\n        private constant _DEPLOYER_CREATION_CODE = 0x602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe;\n\n    /**\n     * @dev Deploys a contract with `code` as its code, returning the destination address.\n     *\n     * Reverts if deployment fails.\n     */\n    function deploy(bytes memory code) internal returns (address destination) {\n        bytes32 deployerCreationCode = _DEPLOYER_CREATION_CODE;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let codeLength := mload(code)\n\n            // `code` is composed of length and data. We've already stored its length in `codeLength`, so we simply\n            // replace it with the deployer creation code (which is exactly 32 bytes long).\n            mstore(code, deployerCreationCode)\n\n            // At this point, `code` now points to the deployer creation code immediately followed by `code`'s data\n            // contents. This is exactly what the deployer expects to receive when created.\n            destination := create(0, code, add(codeLength, 32))\n\n            // Finally, we restore the original length in order to not mutate `code`.\n            mstore(code, codeLength)\n        }\n\n        // The create opcode returns the zero address when contract creation fails, so we revert if this happens.\n        _require(destination != address(0), Errors.CODE_DEPLOYMENT_FAILED);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}